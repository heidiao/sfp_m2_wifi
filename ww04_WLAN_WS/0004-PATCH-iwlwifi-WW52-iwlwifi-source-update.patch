From 74844ac8b0598a918b0d98d2d657e92941994213 Mon Sep 17 00:00:00 2001
From: "Chung, Kevin" <kevin.chung@intel.com>
Date: Tue, 10 Feb 2015 18:20:15 +0800
Subject: [PATCH 4/6] [PATCH] iwlwifi: WW52 iwlwifi source update

source - iwlwifi-stack-public-modrename
tag - wcs-delivery-ww1452.04

In this delivery we have cleanups.
More work on the D0i3 low power states.
We also adapted our regulatory implementation based on
comments from upstream discussions.
We are now able to detect APs that don't support well u-APSD.
If we detect such APs, we disable the feature to allow high
throughput.
More work has been done on the firmware error dump mechanism.
This will allow to gather more data when issues arise.
We introduce support for WAKELOCK over PCIe transport.
New SKUs of devices are now supported,
along with more fixes for LnP B step.
Besides this-
lots of various bug fixes in mac80211 / cfg80211 and iwlwifi.

Signed-off-by: Benzi Zbit <benzi.zbit@intel.com>
Change-Id: I3353dcf59eb458c27e8fb92d96d60986c3786270
Signed-off-by: Chung, Kevin <kevin.chung@intel.com>
---
 uefi/modules/wlan/iwlwifi/MAINTAINERS              |    3 +-
 .../iwlwifi/backport-include/backport/redef-syms.h |    6 +-
 .../iwlwifi/backport-include/backport/undef-syms.h |    6 +-
 .../wlan/iwlwifi/defconfigs/iwlwifi-public-android |    1 -
 .../defconfigs/iwlwifi-public-android-pcie-suspend |    1 -
 .../net/wireless/iwlwifi/Kconfig.noupstream        |   14 +
 .../drivers/net/wireless/iwlwifi/iwl-7000.c        |    4 +-
 .../drivers/net/wireless/iwlwifi/iwl-8000.c        |   12 +-
 .../drivers/net/wireless/iwlwifi/iwl-config.h      |    1 +
 .../drivers/net/wireless/iwlwifi/iwl-constants.h   |  100 ++++
 .../iwlwifi/drivers/net/wireless/iwlwifi/iwl-csr.h |    1 +
 .../drivers/net/wireless/iwlwifi/iwl-dbg-cfg.c     |    1 +
 .../drivers/net/wireless/iwlwifi/iwl-dbg-cfg.h     |   36 +-
 .../net/wireless/iwlwifi/iwl-dnt-dispatch.c        |    3 +-
 .../iwlwifi/drivers/net/wireless/iwlwifi/iwl-drv.c |   66 +--
 .../net/wireless/iwlwifi/iwl-fw-error-dump.h       |   24 +-
 .../drivers/net/wireless/iwlwifi/iwl-fw-file.h     |    3 +
 .../iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw.h  |    4 +
 .../drivers/net/wireless/iwlwifi/iwl-modparams.h   |    2 +
 .../drivers/net/wireless/iwlwifi/iwl-nvm-parse.c   |    6 +
 .../drivers/net/wireless/iwlwifi/iwl-prph.h        |    5 +
 .../drivers/net/wireless/iwlwifi/iwl-trans.h       |   21 +
 .../drivers/net/wireless/iwlwifi/mvm/coex.c        |   51 +-
 .../drivers/net/wireless/iwlwifi/mvm/coex_legacy.c |   52 +-
 .../drivers/net/wireless/iwlwifi/mvm/constants.h   |   64 ++-
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/d3.c  |   67 ++-
 .../drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c |    3 +-
 .../drivers/net/wireless/iwlwifi/mvm/debugfs.c     |   56 +-
 .../drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h |    7 +-
 .../drivers/net/wireless/iwlwifi/mvm/fw-api.h      |   30 +-
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw.c  |   31 +-
 .../drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c    |    2 +-
 .../drivers/net/wireless/iwlwifi/mvm/mac80211.c    |  205 +++++--
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/mvm.h |   76 ++-
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/nvm.c |  175 ++++--
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/ops.c |   30 +-
 .../drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c    |    2 +-
 .../drivers/net/wireless/iwlwifi/mvm/power.c       |    2 +
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.c  |  171 +++---
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.h  |   39 --
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/rx.c  |   98 +++-
 .../drivers/net/wireless/iwlwifi/mvm/scan.c        |   53 +-
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/sta.c |   16 +-
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/tt.c  |    7 +-
 .../iwlwifi/drivers/net/wireless/iwlwifi/mvm/tx.c  |    2 +-
 .../drivers/net/wireless/iwlwifi/mvm/utils.c       |   95 +++-
 .../drivers/net/wireless/iwlwifi/mvm/vendor-cmd.c  |   50 ++
 .../drivers/net/wireless/iwlwifi/mvm/vendor-cmd.h  |    4 +
 .../drivers/net/wireless/iwlwifi/pcie/drv.c        |    2 +
 .../drivers/net/wireless/iwlwifi/pcie/internal.h   |   15 +
 .../drivers/net/wireless/iwlwifi/pcie/trans.c      |  122 +++-
 .../iwlwifi/drivers/net/wireless/iwlwifi/pcie/tx.c |   34 +-
 .../net/wireless/iwlwifi/trans_slave/mini_rpm.c    |    1 +
 .../net/wireless/iwlwifi/trans_slave/sdio_drv.c    |   48 +-
 .../wireless/iwlwifi/trans_slave/sdio_internal.h   |    5 +
 .../net/wireless/iwlwifi/trans_slave/sdio_rx.c     |   19 +-
 .../net/wireless/iwlwifi/trans_slave/sdio_trans.c  |  215 +++++--
 .../net/wireless/iwlwifi/trans_slave/shared.c      |   98 ++--
 .../net/wireless/iwlwifi/trans_slave/shared.h      |    8 -
 .../drivers/net/wireless/iwlwifi/xvt/utils.c       |  131 ++---
 .../iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.c |   19 +-
 .../iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.h |   64 ++-
 .../iwlwifi/drivers/net/wireless/mac80211_hwsim.c  |    5 +-
 uefi/modules/wlan/iwlwifi/include/net/cfg80211.h   |  140 ++---
 uefi/modules/wlan/iwlwifi/include/net/mac80211.h   |   32 ++
 uefi/modules/wlan/iwlwifi/include/net/regulatory.h |   51 +-
 .../wlan/iwlwifi/include/uapi/linux/nl80211.h      |   52 +-
 .../wlan/iwlwifi/net/mac80211/ieee80211_i.h        |    1 +
 uefi/modules/wlan/iwlwifi/net/mac80211/key.c       |    2 +-
 uefi/modules/wlan/iwlwifi/net/mac80211/mlme.c      |   70 ++-
 uefi/modules/wlan/iwlwifi/net/mac80211/rate.c      |    3 +-
 uefi/modules/wlan/iwlwifi/net/mac80211/rate.h      |   24 +-
 .../wlan/iwlwifi/net/mac80211/rc80211_minstrel.c   |    5 +-
 .../iwlwifi/net/mac80211/rc80211_minstrel_ht.c     |   15 +-
 uefi/modules/wlan/iwlwifi/net/mac80211/rx.c        |   11 +-
 uefi/modules/wlan/iwlwifi/net/mac80211/spectmgmt.c |    4 -
 uefi/modules/wlan/iwlwifi/net/mac80211/status.c    |  119 +++-
 uefi/modules/wlan/iwlwifi/net/mac80211/trace.h     |    6 +
 uefi/modules/wlan/iwlwifi/net/mac80211/tx.c        |    2 +-
 uefi/modules/wlan/iwlwifi/net/mac80211/util.c      |   11 +-
 uefi/modules/wlan/iwlwifi/net/mac80211/vht.c       |   73 +--
 uefi/modules/wlan/iwlwifi/net/wireless/Kconfig     |    2 +-
 uefi/modules/wlan/iwlwifi/net/wireless/core.c      |   22 +
 uefi/modules/wlan/iwlwifi/net/wireless/core.h      |    7 +
 uefi/modules/wlan/iwlwifi/net/wireless/nl80211.c   |  589 ++++++++++++++------
 uefi/modules/wlan/iwlwifi/net/wireless/nl80211.h   |    1 +
 uefi/modules/wlan/iwlwifi/net/wireless/reg.c       |  253 +++++----
 uefi/modules/wlan/iwlwifi/net/wireless/reg.h       |    1 +
 uefi/modules/wlan/iwlwifi/versions                 |    2 +-
 89 files changed, 2890 insertions(+), 1102 deletions(-)
 create mode 100644 uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-constants.h

diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/MAINTAINERS kernel/gmin/uefi/modules/wlan/iwlwifi/MAINTAINERS
index 2ab8abf..d73f69b 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/MAINTAINERS
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/MAINTAINERS
@@ -7907,11 +7907,10 @@ S:	Maintained
 F:	drivers/media/dvb-frontends/rtl2832_sdr*
 
 RTL8180 WIRELESS DRIVER
-M:	"John W. Linville" <linville@tuxdriver.com>
 L:	linux-wireless@vger.kernel.org
 W:	http://wireless.kernel.org/
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-testing.git
-S:	Maintained
+S:	Orphan
 F:	drivers/net/wireless/rtl818x/rtl8180/
 
 RTL8187 WIRELESS DRIVER
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/redef-syms.h kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/redef-syms.h
index 5fc62ad..01c2b08 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/redef-syms.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/redef-syms.h
@@ -26,6 +26,7 @@
 #define cfg80211_classify8021d __iwl_cfg80211_classify8021d
 #define cfg80211_conn_failed __iwl_cfg80211_conn_failed
 #define cfg80211_connect_result __iwl_cfg80211_connect_result
+#define cfg80211_cqm_beacon_loss_notify __iwl_cfg80211_cqm_beacon_loss_notify
 #define cfg80211_cqm_pktloss_notify __iwl_cfg80211_cqm_pktloss_notify
 #define cfg80211_cqm_rssi_notify __iwl_cfg80211_cqm_rssi_notify
 #define cfg80211_cqm_txe_notify __iwl_cfg80211_cqm_txe_notify
@@ -101,6 +102,7 @@
 #define ieee80211_channel_to_frequency __iwl_ieee80211_channel_to_frequency
 #define ieee80211_chswitch_done __iwl_ieee80211_chswitch_done
 #define ieee80211_connection_loss __iwl_ieee80211_connection_loss
+#define ieee80211_cqm_beacon_loss_notify __iwl_ieee80211_cqm_beacon_loss_notify
 #define ieee80211_cqm_rssi_notify __iwl_ieee80211_cqm_rssi_notify
 #define ieee80211_csa_finish __iwl_ieee80211_csa_finish
 #define ieee80211_csa_is_complete __iwl_ieee80211_csa_is_complete
@@ -191,6 +193,7 @@
 #define ieee80211_tx_prepare_skb __iwl_ieee80211_tx_prepare_skb
 #define ieee80211_tx_status __iwl_ieee80211_tx_status
 #define ieee80211_tx_status_irqsafe __iwl_ieee80211_tx_status_irqsafe
+#define ieee80211_tx_status_noskb __iwl_ieee80211_tx_status_noskb
 #define ieee80211_unregister_hw __iwl_ieee80211_unregister_hw
 #define ieee80211_unreserve_tid __iwl_ieee80211_unreserve_tid
 #define ieee80211_update_p2p_noa __iwl_ieee80211_update_p2p_noa
@@ -209,7 +212,8 @@
 #define rate_control_send_low __iwl_rate_control_send_low
 #define rate_control_set_rates __iwl_rate_control_set_rates
 #define reg_initiator_name __iwl_reg_initiator_name
-#define regulatory_hint_force_policy __iwl_regulatory_hint_force_policy
+#define regulatory_hint __iwl_regulatory_hint
+#define regulatory_set_wiphy_regd __iwl_regulatory_set_wiphy_regd
 #define rfc1042_header __iwl_rfc1042_header
 #define wdev_to_ieee80211_vif __iwl_wdev_to_ieee80211_vif
 #define wiphy_apply_custom_regulatory __iwl_wiphy_apply_custom_regulatory
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/undef-syms.h kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/undef-syms.h
index c205356..9a7f58f 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/undef-syms.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/backport-include/backport/undef-syms.h
@@ -25,6 +25,7 @@
 #undef cfg80211_classify8021d
 #undef cfg80211_conn_failed
 #undef cfg80211_connect_result
+#undef cfg80211_cqm_beacon_loss_notify
 #undef cfg80211_cqm_pktloss_notify
 #undef cfg80211_cqm_rssi_notify
 #undef cfg80211_cqm_txe_notify
@@ -100,6 +101,7 @@
 #undef ieee80211_channel_to_frequency
 #undef ieee80211_chswitch_done
 #undef ieee80211_connection_loss
+#undef ieee80211_cqm_beacon_loss_notify
 #undef ieee80211_cqm_rssi_notify
 #undef ieee80211_csa_finish
 #undef ieee80211_csa_is_complete
@@ -190,6 +192,7 @@
 #undef ieee80211_tx_prepare_skb
 #undef ieee80211_tx_status
 #undef ieee80211_tx_status_irqsafe
+#undef ieee80211_tx_status_noskb
 #undef ieee80211_unregister_hw
 #undef ieee80211_unreserve_tid
 #undef ieee80211_update_p2p_noa
@@ -208,7 +211,8 @@
 #undef rate_control_send_low
 #undef rate_control_set_rates
 #undef reg_initiator_name
-#undef regulatory_hint_force_policy
+#undef regulatory_hint
+#undef regulatory_set_wiphy_regd
 #undef rfc1042_header
 #undef wdev_to_ieee80211_vif
 #undef wiphy_apply_custom_regulatory
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android
index 3c75cfd..6478cac 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android
@@ -22,6 +22,5 @@ CPTCFG_IWLWIFI_PCIE=y
 # CPTCFG_IWLXVT is not set
 CPTCFG_IWLWIFI_SDIO=y
 CPTCFG_IWLWIFI_OPMODE_MODULAR=y
-
 CPTCFG_CFG80211_ANDROID_P2P_HACK=y
 CPTCFG_IWLWIFI_BCAST_FILTERING=y
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android-pcie-suspend kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android-pcie-suspend
index d24a917..9a436ee 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android-pcie-suspend
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/defconfigs/iwlwifi-public-android-pcie-suspend
@@ -22,7 +22,6 @@ CPTCFG_IWLWIFI_PCIE=y
 CPTCFG_IWLXVT=m
 # CPTCFG_IWLWIFI_SDIO is not set
 CPTCFG_IWLWIFI_OPMODE_MODULAR=y
-
 CPTCFG_CFG80211_ANDROID_P2P_HACK=y
 CPTCFG_IWLWIFI_BCAST_FILTERING=y
 CPTCFG_IWLWIFI_PCIE_SUSPEND_RESUME=y
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/Kconfig.noupstream kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/Kconfig.noupstream
index 00f98db..3224078 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/Kconfig.noupstream
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/Kconfig.noupstream
@@ -78,3 +78,17 @@ config IWLMVM_TCM
 	  monitoring for low-latency and traffic thresholds, as well as
 	  their impact on quota and other submodules.
 
+config IWLMVM_SCAN_PRECEDENCE_LEVEL
+	int "define scan fragmentation level"
+	range 1 2
+	default 1
+	depends on IWLMVM
+	help
+	  Scan precedence level defines relative priority of scan comparing to
+	  on channel activities.
+	  This level is expressed in terms of scan timing - out-of-channel time
+	  and scan suspend time.
+	  Level 1: scan is of higher precedence, decreasing overall scan
+	  duration.
+	  Level 2: scan is of lower precedence, increasing overall scan
+	  duration.
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-7000.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-7000.c
index 61ea3bc..1b4f0cf 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-7000.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-7000.c
@@ -69,8 +69,8 @@
 #include "iwl-agn-hw.h"
 
 /* Highest firmware API version supported */
-#define IWL7260_UCODE_API_MAX	12
-#define IWL3160_UCODE_API_MAX	12
+#define IWL7260_UCODE_API_MAX	13
+#define IWL3160_UCODE_API_MAX	13
 
 /* Oldest version we won't warn about */
 #define IWL7260_UCODE_API_OK	10
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-8000.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-8000.c
index 720546c..1e8d697 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-8000.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-8000.c
@@ -69,7 +69,7 @@
 #include "iwl-agn-hw.h"
 
 /* Highest firmware API version supported */
-#define IWL8000_UCODE_API_MAX	12
+#define IWL8000_UCODE_API_MAX	13
 
 /* Oldest version we won't warn about */
 #define IWL8000_UCODE_API_OK	10
@@ -156,6 +156,16 @@ const struct iwl_cfg iwl8260_2ac_cfg = {
 	.max_ht_ampdu_exponent = IEEE80211_HT_MAX_AMPDU_64K,
 };
 
+const struct iwl_cfg iwl4165_2ac_cfg = {
+	.name = "Intel(R) Dual Band Wireless AC 4165",
+	.fw_name_pre = IWL8000_FW_PRE,
+	IWL_DEVICE_8000,
+	.ht_params = &iwl8000_ht_params,
+	.nvm_ver = IWL8000_NVM_VERSION,
+	.nvm_calib_ver = IWL8000_TX_POWER_VERSION,
+	.max_ht_ampdu_exponent = IEEE80211_HT_MAX_AMPDU_64K,
+};
+
 const struct iwl_cfg iwl8260_2ac_sdio_cfg = {
 	.name = "Intel(R) Dual Band Wireless-AC 8260",
 	.fw_name_pre = IWL8000_FW_PRE,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-config.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-config.h
index 0092207..3973751 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-config.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-config.h
@@ -334,6 +334,7 @@ extern const struct iwl_cfg iwl7265d_2n_cfg;
 extern const struct iwl_cfg iwl7265d_n_cfg;
 extern const struct iwl_cfg iwl8260_2n_cfg;
 extern const struct iwl_cfg iwl8260_2ac_cfg;
+extern const struct iwl_cfg iwl4165_2ac_cfg;
 extern const struct iwl_cfg iwl8260_2ac_sdio_cfg;
 extern const struct iwl_cfg iwl4165_2ac_sdio_cfg;
 #endif /* CPTCFG_IWLMVM */
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-constants.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-constants.h
new file mode 100644
index 0000000..8d3a4f1
--- /dev/null
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-constants.h
@@ -0,0 +1,100 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 - 2014 Intel Corporation. All rights reserved.
+ * Copyright(c) 2014 - 2014 Intel Mobile Communications GmbH
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#ifndef __IWL_CONSTANTS_H
+#define __IWL_CONSTANTS_H
+
+/**
+ * enum iwl_wakelock_modes - iwlwifi wakelock management mode
+ * @IWL_WAKELOCK_MODE_IDLE: take wakelocks while the driver is
+ *	doing some activity, and release when it's idle.
+ * @IWL_WAKELOCK_MODE_OFF: don't take any wakelock.
+ * @IWL_WAKELOCK_MODE_ALWAYS_ON: wake wakelock while driver is up
+ *	and started (there is interface up).
+ */
+enum iwl_wakelock_mode {
+	IWL_WAKELOCK_MODE_IDLE		= 0,
+	IWL_WAKELOCK_MODE_OFF		= 1,
+	IWL_WAKELOCK_MODE_ALWAYS_ON	= 2,
+};
+
+enum {
+	IWL_D0I3_DBG_KEEP_BUS		= BIT(0),
+	IWL_D0I3_DBG_KEEP_WAKE_LOCK	= BIT(1),
+	IWL_D0I3_DBG_IGNORE_RX		= BIT(2),
+};
+
+#ifndef CPTCFG_IWLWIFI_SUPPORT_DEBUG_OVERRIDES
+#ifdef CONFIG_HAS_WAKELOCK
+/* wakelock timeout to use when all the references were released */
+#define IWL_WAKELOCK_TIMEOUT_MS		1500
+#endif /* CONFIG_HAS_WAKELOCK */
+#else /* CPTCFG_IWLWIFI_SUPPORT_DEBUG_OVERRIDES */
+#define IWL_D0I3_DEBUG			(trans->dbg_cfg.d0i3_debug)
+#ifdef CONFIG_HAS_WAKELOCK
+#define IWL_WAKELOCK_TIMEOUT_MS		(trans->dbg_cfg.WAKELOCK_TIMEOUT_MS)
+#endif /* CONFIG_HAS_WAKELOCK */
+#endif /* CPTCFG_IWLWIFI_SUPPORT_DEBUG_OVERRIDES */
+
+#endif /* __IWL_CONSTANTS_H */
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-csr.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-csr.h
index 5788c28..18d6026 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-csr.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-csr.h
@@ -189,6 +189,7 @@
 #define CSR_HW_IF_CONFIG_REG_BIT_NIC_READY	(0x00400000) /* PCI_OWN_SEM */
 #define CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE (0x02000000) /* ME_OWN */
 #define CSR_HW_IF_CONFIG_REG_PREPARE		  (0x08000000) /* WAKE_ME */
+#define CSR_HW_IF_CONFIG_REG_ENABLE_PME		  (0x10000000)
 #define CSR_HW_IF_CONFIG_REG_PERSIST_MODE	  (0x40000000) /* PERSISTENCE */
 
 #define CSR_MBOX_SET_REG_OS_ALIVE		BIT(5)
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.c
index f5416c4..9c0ffe9 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.c
@@ -71,6 +71,7 @@
 
 /* grab default values */
 #undef CPTCFG_IWLWIFI_SUPPORT_DEBUG_OVERRIDES
+#include "iwl-constants.h"
 #if IS_ENABLED(CPTCFG_IWLXVT)
 #include "xvt/constants.h"
 #endif
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.h
index becf21c..c190e8a 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dbg-cfg.h
@@ -141,11 +141,40 @@ struct iwl_dbg_cfg {
 	IWL_DBG_CFG(u32, MVM_TCM_LOWLAT_ENABLE_THRESH)
 	IWL_DBG_CFG(u32, MVM_QUOTA_AIRTIME_THRESH)
 	IWL_DBG_CFG(u8, MVM_LOWLAT_QUOTA_LOWTRAF_PERCENT)
+	IWL_DBG_CFG(u32, MVM_UAPSD_AGGDETECT_MIN_PKTS)
 #endif /* CPTCFG_IWLMVM_TCM */
 	IWL_DBG_CFG(u8, MVM_QUOTA_THRESHOLD)
 	IWL_DBG_CFG(u8, MVM_RS_RSSI_BASED_INIT_RATE)
-	IWL_DBG_CFG(u8, MVM_RS_DISABLE_MIMO)
+	IWL_DBG_CFG(u8, MVM_RS_DISABLE_P2P_MIMO)
 	IWL_DBG_CFG(bool, MVM_RRM_PRETEND_QUIET_SUPPORT)
+	IWL_DBG_CFG(u8, MVM_RS_NUM_TRY_BEFORE_ANT_TOGGLE)
+	IWL_DBG_CFG(u8, MVM_RS_LEGACY_RETRIES_PER_RATE)
+	IWL_DBG_CFG(u8, MVM_RS_HT_VHT_RETRIES_PER_RATE)
+	IWL_DBG_CFG(u8, MVM_RS_HT_VHT_RETRIES_PER_RATE_TW)
+	IWL_DBG_CFG(u8, MVM_RS_INITIAL_MIMO_NUM_RATES)
+	IWL_DBG_CFG(u8, MVM_RS_INITIAL_SISO_NUM_RATES)
+	IWL_DBG_CFG(u8, MVM_RS_INITIAL_LEGACY_NUM_RATES)
+	IWL_DBG_CFG(u8, MVM_RS_SECONDARY_LEGACY_NUM_RATES)
+	IWL_DBG_CFG(u8, MVM_RS_SECONDARY_SISO_NUM_RATES)
+	IWL_DBG_CFG(u8, MVM_RS_SECONDARY_SISO_RETRIES)
+	IWL_DBG_CFG(u8, MVM_RS_RATE_MIN_FAILURE_TH)
+	IWL_DBG_CFG(u8, MVM_RS_RATE_MIN_SUCCESS_TH)
+	IWL_DBG_CFG(u8, MVM_RS_STAY_IN_COLUMN_TIMEOUT)
+	IWL_DBG_CFG(u8, MVM_RS_IDLE_TIMEOUT)
+	IWL_DBG_CFG(u8, MVM_RS_MISSED_RATE_MAX)
+	IWL_DBG_CFG(u16, MVM_RS_LEGACY_FAILURE_LIMIT)
+	IWL_DBG_CFG(u16, MVM_RS_LEGACY_SUCCESS_LIMIT)
+	IWL_DBG_CFG(u16, MVM_RS_LEGACY_TABLE_COUNT)
+	IWL_DBG_CFG(u16, MVM_RS_NON_LEGACY_FAILURE_LIMIT)
+	IWL_DBG_CFG(u16, MVM_RS_NON_LEGACY_SUCCESS_LIMIT)
+	IWL_DBG_CFG(u16, MVM_RS_NON_LEGACY_TABLE_COUNT)
+	IWL_DBG_CFG(u16, MVM_RS_SR_FORCE_DECREASE)
+	IWL_DBG_CFG(u16, MVM_RS_SR_NO_DECREASE)
+	IWL_DBG_CFG(u16, MVM_RS_AGG_TIME_LIMIT)
+	IWL_DBG_CFG(u8, MVM_RS_AGG_DISABLE_START)
+	IWL_DBG_CFG(u16, MVM_RS_TPC_SR_FORCE_INCREASE)
+	IWL_DBG_CFG(u16, MVM_RS_TPC_SR_NO_INCREASE)
+	IWL_DBG_CFG(u8, MVM_RS_TPC_TX_POWER_STEP)
 #endif /* CPTCFG_IWLMVM */
 #ifdef CPTCFG_IWLWIFI_DEVICE_TESTMODE
 	IWL_DBG_CFG_NODEF(u32, dnt_out_mode)
@@ -198,7 +227,12 @@ struct iwl_dbg_cfg {
 	IWL_DBG_CFG_NODEF(u32, dbg_mon_buff_end_addr_reg_addr_b_step)
 	IWL_DBG_CFG_NODEF(u32, dbg_mon_wr_ptr_addr_b_step)
 #endif /* CPTCFG_IWLWIFI_DEVICE_TESTMODE */
+	IWL_DBG_CFG_NODEF(u8, wakelock_mode)
+	IWL_DBG_CFG_NODEF(u32, d0i3_debug)
 	IWL_DBG_CFG_NODEF(u32, valid_ants)
+#ifdef CONFIG_HAS_WAKELOCK
+	IWL_DBG_CFG(u32, WAKELOCK_TIMEOUT_MS)
+#endif /* CONFIG_HAS_WAKELOCK */
 #undef IWL_DBG_CFG
 #undef IWL_DBG_CFG_NODEF
 #undef IWL_DBG_CFG_BIN
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dnt-dispatch.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dnt-dispatch.c
index 7dc24ab..d9a692a 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dnt-dispatch.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-dnt-dispatch.c
@@ -444,7 +444,8 @@ static u32 iwl_dnt_dispatch_create_crash_tlv(struct iwl_trans *trans,
 
 	cur_tlv = (void *)dump_file->data;
 	if (crash->sram_buf_size) {
-		iwl_dnt_dispatch_create_tlv(cur_tlv, IWL_FW_ERROR_DUMP_SRAM,
+		/* TODO: Convert to the new SMEM format */
+		iwl_dnt_dispatch_create_tlv(cur_tlv, 0,
 					    crash->sram_buf_size, crash->sram);
 		cur_tlv = iwl_fw_error_next_data(cur_tlv);
 	}
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-drv.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-drv.c
index 171f567..19807a2 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-drv.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-drv.c
@@ -427,9 +427,6 @@ static int iwl_request_firmware(struct iwl_drv *drv, bool first)
 	/*
 	 * Starting 8000B - FW name format has changed. This overwrites the
 	 * previous name and uses the new format.
-	 *
-	 * TODO:
-	 * Once there is only one supported step for 8000 family - delete this!
 	 */
 	if (drv->trans->cfg->device_family == IWL_DEVICE_FAMILY_8000) {
 		char rev_step[2] = {
@@ -440,13 +437,6 @@ static int iwl_request_firmware(struct iwl_drv *drv, bool first)
 		if (CSR_HW_REV_STEP(drv->trans->hw_rev) == SILICON_A_STEP)
 			rev_step[0] = 0;
 
-		/*
-		 * If hw_rev wasn't set yet - default as B-step. If it IS A-step
-		 * we'll reload that FW later instead.
-		 */
-		if (drv->trans->hw_rev == 0)
-			rev_step[0] = 'B';
-
 		snprintf(drv->firmware_name, sizeof(drv->firmware_name),
 			 "%s%s-%s.ucode", name_pre, rev_step, tag);
 	}
@@ -1132,6 +1122,12 @@ static int iwl_parse_tlv_firmware(struct iwl_drv *drv,
 					    IWL_UCODE_REGULAR_USNIFFER,
 					    tlv_len);
 			break;
+		case IWL_UCODE_TLV_SDIO_ADMA_ADDR:
+			if (tlv_len != sizeof(u32))
+				goto invalid_tlv_len;
+			drv->fw.sdio_adma_addr =
+				le32_to_cpup((__le32 *)tlv_data);
+			break;
 		default:
 			IWL_DEBUG_INFO(drv, "unknown TLV: %d\n", tlv_type);
 			break;
@@ -1289,7 +1285,6 @@ static void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context)
 	u32 api_ver;
 	int i;
 	bool load_module = false;
-	u32 hw_rev = drv->trans->hw_rev;
 
 	fw->ucode_capa.max_probe_length = IWL_DEFAULT_MAX_PROBE_LENGTH;
 	fw->ucode_capa.standard_phy_calibration_size =
@@ -1516,50 +1511,6 @@ static void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context)
 				op->name, err);
 #endif
 	}
-
-	/*
-	 * We may have loaded the wrong FW file in 8000 HW family if it is an
-	 * A-step card, and if drv->trans->hw_rev wasn't properly read when
-	 * the FW file had been loaded. (This might happen in SDIO.) In such a
-	 * case - unload and reload the correct file.
-	 *
-	 * TODO:
-	 * Once there is only one supported step for 8000 family - delete this!
-	 */
-	if (drv->trans->cfg->device_family == IWL_DEVICE_FAMILY_8000 &&
-	    CSR_HW_REV_STEP(drv->trans->hw_rev) == SILICON_A_STEP &&
-	    drv->trans->hw_rev != hw_rev) {
-		char firmware_name[32];
-
-		/* Free previous FW resources */
-		if (drv->op_mode)
-			_iwl_op_mode_stop(drv);
-		iwl_dealloc_ucode(drv);
-
-		/* Build name of correct-step FW */
-		snprintf(firmware_name, sizeof(firmware_name),
-			 strrchr(drv->firmware_name, '-'));
-		snprintf(drv->firmware_name, sizeof(drv->firmware_name),
-			 "%s%s", drv->cfg->fw_name_pre, firmware_name);
-
-		/* Clear data before loading correct FW */
-		list_del(&drv->list);
-
-		/* Request correct FW file this time */
-		IWL_DEBUG_INFO(drv, "attempting to load A-step FW %s\n",
-			       drv->firmware_name);
-		err = request_firmware(&ucode_raw, drv->firmware_name,
-				       drv->trans->dev);
-		if (err) {
-			IWL_ERR(drv, "Failed swapping FW!\n");
-			goto out_unbind;
-		}
-
-		/* Redo callback function - this time with right FW */
-		iwl_req_fw_callback(ucode_raw, context);
-	}
-
-	kfree(pieces);
 	return;
 
  try_again:
@@ -1699,6 +1650,7 @@ struct iwl_mod_params iwlwifi_mod_params = {
 	.bt_coex_active = true,
 	.power_level = IWL_POWER_INDEX_1,
 	.wd_disable = true,
+	.d0i3_disable = true,
 #ifndef CPTCFG_IWLWIFI_UAPSD
 	.uapsd_disable = true,
 #endif /* CPTCFG_IWLWIFI_UAPSD */
@@ -1881,6 +1833,10 @@ MODULE_PARM_DESC(wd_disable,
 module_param_named(nvm_file, iwlwifi_mod_params.nvm_file, charp, S_IRUGO);
 MODULE_PARM_DESC(nvm_file, "NVM file name");
 
+module_param_named(d0i3_disable, iwlwifi_mod_params.d0i3_disable,
+		   bool, S_IRUGO);
+MODULE_PARM_DESC(d0i3_disable, "disable d0i3 functionality (default: Y)");
+
 module_param_named(uapsd_disable, iwlwifi_mod_params.uapsd_disable,
 		   bool, S_IRUGO | S_IWUSR);
 #ifdef CPTCFG_IWLWIFI_UAPSD
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h
index c6a81a7..ec115bd 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h
@@ -71,7 +71,6 @@
 
 /**
  * enum iwl_fw_error_dump_type - types of data in the dump file
- * @IWL_FW_ERROR_DUMP_SRAM:
  * @IWL_FW_ERROR_DUMP_CSR: Control Status Registers - from offset 0
  * @IWL_FW_ERROR_DUMP_RXF:
  * @IWL_FW_ERROR_DUMP_TXCMD: last TX command data, structured as
@@ -82,10 +81,10 @@
  * @IWL_FW_ERROR_DUMP_PRPH: range of periphery registers - there can be several
  *	sections like this in a single file.
  * @IWL_FW_ERROR_DUMP_FH_REGS: range of FH registers
- * @IWL_FW_ERROR_DUMP_SMEM:
+ * @IWL_FW_ERROR_DUMP_MEM: chunk of memory
  */
 enum iwl_fw_error_dump_type {
-	IWL_FW_ERROR_DUMP_SRAM = 0,
+	/* 0 is deprecated */
 	IWL_FW_ERROR_DUMP_CSR = 1,
 	IWL_FW_ERROR_DUMP_RXF = 2,
 	IWL_FW_ERROR_DUMP_TXCMD = 3,
@@ -94,7 +93,7 @@ enum iwl_fw_error_dump_type {
 	IWL_FW_ERROR_DUMP_PRPH = 6,
 	IWL_FW_ERROR_DUMP_TXF = 7,
 	IWL_FW_ERROR_DUMP_FH_REGS = 8,
-	IWL_FW_ERROR_DUMP_SMEM = 9,
+	IWL_FW_ERROR_DUMP_MEM = 9,
 
 	IWL_FW_ERROR_DUMP_MAX,
 };
@@ -182,6 +181,23 @@ struct iwl_fw_error_dump_prph {
 	__le32 data[];
 };
 
+enum iwl_fw_error_dump_mem_type {
+	IWL_FW_ERROR_DUMP_MEM_SRAM,
+	IWL_FW_ERROR_DUMP_MEM_SMEM,
+};
+
+/**
+ * struct iwl_fw_error_dump_mem - chunk of memory
+ * @type: %enum iwl_fw_error_dump_mem_type
+ * @offset: the offset from which the memory was read
+ * @data: the content of the memory
+ */
+struct iwl_fw_error_dump_mem {
+	__le32 type;
+	__le32 offset;
+	u8 data[];
+};
+
 /**
  * iwl_fw_error_next_data - advance fw error dump data pointer
  * @data: previous data block
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-file.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-file.h
index f2a047f..b58e805 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-file.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw-file.h
@@ -132,6 +132,7 @@ enum iwl_ucode_tlv_type {
 	IWL_UCODE_TLV_ENABLED_CAPABILITIES	= 30,
 	IWL_UCODE_TLV_N_SCAN_CHANNELS		= 31,
 	IWL_UCODE_TLV_SEC_RT_USNIFFER	= 34,
+	IWL_UCODE_TLV_SDIO_ADMA_ADDR	= 35,
 	IWL_UCODE_TLV_FW_DBG_DEST	= 38,
 	IWL_UCODE_TLV_FW_DBG_CONF	= 39,
 };
@@ -243,6 +244,7 @@ enum iwl_ucode_tlv_flag {
  * @IWL_UCODE_TLV_API_SF_NO_DUMMY_NOTIF: ucode supports disabling dummy notif.
  * @IWL_UCODE_TLV_API_FRAGMENTED_SCAN: This ucode supports active dwell time
  *	longer than the passive one, which is essential for fragmented scan.
+ * @IWL_UCODE_TLV_API_WIFI_MCC_UPDATE: ucode supports MCC updates with source.
  */
 enum iwl_ucode_tlv_api {
 	IWL_UCODE_TLV_API_WOWLAN_CONFIG_TID	= BIT(0),
@@ -253,6 +255,7 @@ enum iwl_ucode_tlv_api {
 	IWL_UCODE_TLV_API_LMAC_SCAN		= BIT(6),
 	IWL_UCODE_TLV_API_SF_NO_DUMMY_NOTIF	= BIT(7),
 	IWL_UCODE_TLV_API_FRAGMENTED_SCAN	= BIT(8),
+	IWL_UCODE_TLV_API_WIFI_MCC_UPDATE	= BIT(9),
 };
 
 /**
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw.h
index e6dc3b8..ffd785c 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-fw.h
@@ -152,6 +152,8 @@ struct iwl_fw_cscheme_list {
  * @mvm_fw: indicates this is MVM firmware
  * @cipher_scheme: optional external cipher scheme.
  * @human_readable: human readable version
+ * @sdio_adma_addr: the default address to set for the ADMA in SDIO mode until
+ *	we get the ALIVE from the uCode
  * @dbg_dest_tlv: points to the destination TLV for debug
  * @dbg_conf_tlv: array of pointers to configuration TLVs for debug
  * @dbg_conf_tlv_len: lengths of the @dbg_conf_tlv entries
@@ -181,6 +183,8 @@ struct iwl_fw {
 	struct ieee80211_cipher_scheme cs[IWL_UCODE_MAX_CS];
 	u8 human_readable[FW_VER_HUMAN_READABLE_SZ];
 
+	u32 sdio_adma_addr;
+
 	struct iwl_fw_dbg_dest_tlv *dbg_dest_tlv;
 	struct iwl_fw_dbg_conf_tlv *dbg_conf_tlv[FW_DBG_MAX];
 	size_t dbg_conf_tlv_len[FW_DBG_MAX];
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-modparams.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-modparams.h
index b7691c1..b45959a 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-modparams.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-modparams.h
@@ -104,6 +104,7 @@ enum iwl_disable_11n {
  * @debug_level: levels are IWL_DL_*
  * @ant_coupling: antenna coupling in dB, default = 0
  * @xvt_default_mode: xVT is the default operation mode, default = false
+ * @d0i3_disable: disable d0i3, default = 1,
  * @fw_monitor: allow to use firmware monitor
  */
 struct iwl_mod_params {
@@ -125,6 +126,7 @@ struct iwl_mod_params {
 #endif
 	char *nvm_file;
 	bool uapsd_disable;
+	bool d0i3_disable;
 	bool fw_monitor;
 };
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
index cea4873..d9423ed 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
@@ -519,6 +519,8 @@ static void iwl_set_radio_cfg(const struct iwl_cfg *cfg,
 	data->radio_cfg_step = NVM_RF_CFG_STEP_MSK_FAMILY_8000(radio_cfg);
 	data->radio_cfg_dash = NVM_RF_CFG_DASH_MSK_FAMILY_8000(radio_cfg);
 	data->radio_cfg_pnum = NVM_RF_CFG_FLAVOR_MSK_FAMILY_8000(radio_cfg);
+	data->valid_tx_ant = NVM_RF_CFG_TX_ANT_MSK_FAMILY_8000(radio_cfg);
+	data->valid_rx_ant = NVM_RF_CFG_RX_ANT_MSK_FAMILY_8000(radio_cfg);
 }
 
 static void iwl_set_hw_address(const struct iwl_cfg *cfg,
@@ -647,6 +649,10 @@ iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
 	radio_cfg =
 		iwl_get_radio_cfg(cfg, nvm_sw, phy_sku, is_family_8000_a_step);
 	iwl_set_radio_cfg(cfg, data, radio_cfg);
+	if (data->valid_tx_ant)
+		tx_chains &= data->valid_tx_ant;
+	if (data->valid_rx_ant)
+		rx_chains &= data->valid_rx_ant;
 
 	sku = iwl_get_sku(cfg, nvm_sw, phy_sku, is_family_8000_a_step);
 	data->sku_cap_band_24GHz_enable = sku & NVM_SKU_CAP_BAND_24GHZ;
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-prph.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-prph.h
index 5029edd..56a8c6b 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-prph.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-prph.h
@@ -99,6 +99,7 @@
 
 #define APMG_PCIDEV_STT_VAL_PERSIST_DIS	(0x00000200)
 #define APMG_PCIDEV_STT_VAL_L1_ACT_DIS	(0x00000800)
+#define APMG_PCIDEV_STT_VAL_WAKE_ME	(0x00004000)
 
 #define APMG_RTC_INT_STT_RFKILL		(0x10000000)
 
@@ -372,11 +373,15 @@ enum secure_load_status_reg {
 #define RXF_FIFO_RD_FENCE_ADDR		(0xa00c0c)
 
 /* FW monitor */
+#define MON_BUFF_SAMPLE_CTL		(0xa03c00)
 #define MON_BUFF_BASE_ADDR		(0xa03c3c)
 #define MON_BUFF_END_ADDR		(0xa03c40)
 #define MON_BUFF_WRPTR			(0xa03c44)
 #define MON_BUFF_CYCLE_CNT		(0xa03c48)
 
+#define DBGC_IN_SAMPLE			(0xa03c00)
+#define DBGC_OUT_CTRL			(0xa03c0c)
+
 /* enable the ID buf for read */
 #define WFPM_PS_CTL_CLR			0xA0300C
 #define LMPM_PMG_EN			0xA01CEC
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-trans.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-trans.h
index ce620ba..5f10e87 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-trans.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/iwl-trans.h
@@ -387,6 +387,8 @@ enum iwl_trans_status {
  *	are considered stuck and will trigger device restart
  * @command_names: array of command names, must be 256 entries
  *	(one for each command); for debugging only
+ * @sdio_adma_addr: the default address to set for the ADMA in SDIO mode until
+ *	we get the ALIVE from the uCode
  */
 struct iwl_trans_config {
 	struct iwl_op_mode *op_mode;
@@ -401,6 +403,8 @@ struct iwl_trans_config {
 	bool scd_set_active;
 	unsigned int queue_watchdog_timeout;
 	const char *const *command_names;
+
+	u32 sdio_adma_addr;
 };
 
 struct iwl_trans_dump_data {
@@ -562,6 +566,21 @@ enum iwl_trans_state {
 };
 
 /**
+ * enum iwl_d0i3_mode - d0i3 mode
+ *
+ * @IWL_D0I3_MODE_OFF - d0i3 is disabled
+ * @IWL_D0I3_MODE_ON_IDLE - enter d0i3 when device is idle
+ *	(e.g. no active references)
+ * @IWL_D0I3_MODE_ON_SUSPEND - enter d0i3 only on suspend
+ *	(in case of 'any' trigger)
+ */
+enum iwl_d0i3_mode {
+	IWL_D0I3_MODE_OFF = 0,
+	IWL_D0I3_MODE_ON_IDLE,
+	IWL_D0I3_MODE_ON_SUSPEND,
+};
+
+/**
  * struct iwl_trans - transport common data
  *
  * @ops - pointer to iwl_trans_ops
@@ -627,6 +646,8 @@ struct iwl_trans {
 	const struct iwl_fw_dbg_conf_tlv *dbg_conf_tlv[FW_DBG_MAX];
 	u8 dbg_dest_reg_num;
 
+	enum iwl_d0i3_mode d0i3_mode;
+
 	/* pointer to trans specific struct */
 	/*Ensure that this pointer will always be aligned to sizeof pointer */
 	char trans_specific[0] __aligned(sizeof(void *));
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex.c
index 72a7d50..c2ceb73 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex.c
@@ -725,6 +725,8 @@ struct iwl_bt_iterator_data {
 	struct ieee80211_chanctx_conf *primary;
 	struct ieee80211_chanctx_conf *secondary;
 	bool primary_ll;
+	u8 primary_load;
+	u8 secondary_load;
 };
 
 static inline
@@ -741,6 +743,36 @@ void iwl_mvm_bt_coex_enable_rssi_event(struct iwl_mvm *mvm,
 		enable ? -IWL_MVM_BT_COEX_DIS_RED_TXP_THRESH : 0;
 }
 
+#ifdef CPTCFG_IWLMVM_TCM
+#define MVM_COEX_TCM_PERIOD (HZ * 10)
+
+static void iwl_mvm_bt_coex_tcm_based_ci(struct iwl_mvm *mvm,
+					 struct iwl_bt_iterator_data *data)
+{
+	unsigned long now = jiffies;
+
+	if (!time_after(now, mvm->bt_coex_last_tcm_ts + MVM_COEX_TCM_PERIOD))
+		return;
+
+	mvm->bt_coex_last_tcm_ts = now;
+
+	/* We assume here that we don't have more than 2 vifs on 2.4GHz */
+
+	/* if the primary is low latency, it will stay primary */
+	if (data->primary_ll)
+		return;
+
+	if (data->primary_load >= data->secondary_load)
+		return;
+
+	swap(data->primary, data->secondary);
+}
+#else
+static void iwl_mvm_bt_coex_tcm_based_ci(struct iwl_mvm *mvm,
+					 struct iwl_bt_iterator_data *data)
+{}
+#endif
+
 /* must be called under rcu_read_lock */
 static void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,
 				      struct ieee80211_vif *vif)
@@ -831,6 +863,13 @@ static void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,
 			/* there is low latency vif - we will be secondary */
 			data->secondary = chanctx_conf;
 		}
+
+#ifdef CPTCFG_IWLWIFI_TCM
+		if (data->primary == chanctx_conf)
+			data->primary_load = mvm->tcm.result.load[mvmvif->id];
+		else if (data->secondary == chanctx_conf)
+			data->secondary_load = mvm->tcm.result.load[mvmvif->id];
+#endif
 		return;
 	}
 
@@ -844,6 +883,12 @@ static void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,
 		/* if secondary is not NULL, it might be a GO */
 		data->secondary = chanctx_conf;
 
+#ifdef CPTCFG_IWLWIFI_TCM
+	if (data->primary == chanctx_conf)
+		data->primary_load = mvm->tcm.result.load[mvmvif->id];
+	else if (data->secondary == chanctx_conf)
+		data->secondary_load = mvm->tcm.result.load[mvmvif->id];
+#endif
 	/*
 	 * don't reduce the Tx power if one of these is true:
 	 *  we are in LOOSE
@@ -895,6 +940,8 @@ static void iwl_mvm_bt_coex_notif_handle(struct iwl_mvm *mvm)
 					mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_bt_notif_iterator, &data);
 
+	iwl_mvm_bt_coex_tcm_based_ci(mvm, &data);
+
 	if (data.primary) {
 		struct ieee80211_chanctx_conf *chan = data.primary;
 		if (WARN_ON(!chan->def.chan)) {
@@ -989,7 +1036,7 @@ int iwl_mvm_rx_bt_coex_notif(struct iwl_mvm *mvm,
 static void iwl_mvm_bt_rssi_iterator(void *_data, u8 *mac,
 				   struct ieee80211_vif *vif)
 {
-	struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 	struct iwl_bt_iterator_data *data = _data;
 	struct iwl_mvm *mvm = data->mvm;
 
@@ -1025,7 +1072,7 @@ static void iwl_mvm_bt_rssi_iterator(void *_data, u8 *mac,
 void iwl_mvm_bt_rssi_event(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 			   enum ieee80211_rssi_event rssi_event)
 {
-	struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 	struct iwl_bt_iterator_data data = {
 		.mvm = mvm,
 	};
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex_legacy.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex_legacy.c
index b3210cf..5194ac5 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex_legacy.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/coex_legacy.c
@@ -761,6 +761,8 @@ struct iwl_bt_iterator_data {
 	struct ieee80211_chanctx_conf *primary;
 	struct ieee80211_chanctx_conf *secondary;
 	bool primary_ll;
+	u8 primary_load;
+	u8 secondary_load;
 };
 
 static inline
@@ -777,6 +779,36 @@ void iwl_mvm_bt_coex_enable_rssi_event(struct iwl_mvm *mvm,
 		enable ? -IWL_MVM_BT_COEX_DIS_RED_TXP_THRESH : 0;
 }
 
+#ifdef CPTCFG_IWLMVM_TCM
+#define MVM_COEX_TCM_PERIOD (HZ * 10)
+
+static void iwl_mvm_bt_coex_tcm_based_ci(struct iwl_mvm *mvm,
+					 struct iwl_bt_iterator_data *data)
+{
+	unsigned long now = jiffies;
+
+	if (!time_after(now, mvm->bt_coex_last_tcm_ts + MVM_COEX_TCM_PERIOD))
+		return;
+
+	mvm->bt_coex_last_tcm_ts = now;
+
+	/* We assume here that we don't have more than 2 vifs on 2.4GHz */
+
+	/* if the primary is low latency, it will stay primary */
+	if (data->primary_ll)
+		return;
+
+	if (data->primary_load >= data->secondary_load)
+		return;
+
+	swap(data->primary, data->secondary);
+}
+#else
+static void iwl_mvm_bt_coex_tcm_based_ci(struct iwl_mvm *mvm,
+					 struct iwl_bt_iterator_data *data)
+{}
+#endif
+
 /* must be called under rcu_read_lock */
 static void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,
 				      struct ieee80211_vif *vif)
@@ -870,6 +902,13 @@ static void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,
 			/* there is low latency vif - we will be secondary */
 			data->secondary = chanctx_conf;
 		}
+
+#ifdef CPTCFG_IWLWIFI_TCM
+		if (data->primary == chanctx_conf)
+			data->primary_load = mvm->tcm.result.load[mvmvif->id];
+		else if (data->secondary == chanctx_conf)
+			data->secondary_load = mvm->tcm.result.load[mvmvif->id];
+#endif
 		return;
 	}
 
@@ -883,6 +922,13 @@ static void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,
 		/* if secondary is not NULL, it might be a GO */
 		data->secondary = chanctx_conf;
 
+#ifdef CPTCFG_IWLWIFI_TCM
+	if (data->primary == chanctx_conf)
+		data->primary_load = mvm->tcm.result.load[mvmvif->id];
+	else if (data->secondary == chanctx_conf)
+		data->secondary_load = mvm->tcm.result.load[mvmvif->id];
+#endif
+
 	/*
 	 * don't reduce the Tx power if one of these is true:
 	 *  we are in LOOSE
@@ -934,6 +980,8 @@ static void iwl_mvm_bt_coex_notif_handle(struct iwl_mvm *mvm)
 					mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_bt_notif_iterator, &data);
 
+	iwl_mvm_bt_coex_tcm_based_ci(mvm, &data);
+
 	if (data.primary) {
 		struct ieee80211_chanctx_conf *chan = data.primary;
 
@@ -1034,7 +1082,7 @@ int iwl_mvm_rx_bt_coex_notif_old(struct iwl_mvm *mvm,
 static void iwl_mvm_bt_rssi_iterator(void *_data, u8 *mac,
 				     struct ieee80211_vif *vif)
 {
-	struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 	struct iwl_bt_iterator_data *data = _data;
 	struct iwl_mvm *mvm = data->mvm;
 
@@ -1070,7 +1118,7 @@ static void iwl_mvm_bt_rssi_iterator(void *_data, u8 *mac,
 void iwl_mvm_bt_rssi_event_old(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 			       enum ieee80211_rssi_event rssi_event)
 {
-	struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 	struct iwl_bt_iterator_data data = {
 		.mvm = mvm,
 	};
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/constants.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/constants.h
index b708e21..6ce2313 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/constants.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/constants.h
@@ -102,7 +102,7 @@
 #define IWL_MVM_FW_BCAST_FILTER_PASS_ALL	0
 #define IWL_MVM_QUOTA_THRESHOLD			8
 #define IWL_MVM_RS_RSSI_BASED_INIT_RATE         0
-#define IWL_MVM_RS_DISABLE_MIMO			0
+#define IWL_MVM_RS_DISABLE_P2P_MIMO		IS_ENABLED(CPTCFG_IWLMVM_DISABLE_P2P_MIMO)
 #define IWL_MVM_RRM_PRETEND_QUIET_SUPPORT	0
 #ifdef CPTCFG_IWLMVM_TCM
 #define IWL_MVM_TCM_LOAD_MEDIUM_THRESH		10 /* percentage */
@@ -110,7 +110,36 @@
 #define IWL_MVM_TCM_LOWLAT_ENABLE_THRESH	100 /* packets/10 seconds */
 #define IWL_MVM_QUOTA_AIRTIME_THRESH		16 /* 16 percent */
 #define IWL_MVM_LOWLAT_QUOTA_LOWTRAF_PERCENT	80 /* for low BSS traffic */
+#define IWL_MVM_UAPSD_AGGDETECT_MIN_PKTS	50
 #endif /* CPTCFG_IWLMVM_TCM */
+#define IWL_MVM_RS_NUM_TRY_BEFORE_ANT_TOGGLE    1
+#define IWL_MVM_RS_LEGACY_RETRIES_PER_RATE      1
+#define IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE      2
+#define IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE_TW   1
+#define IWL_MVM_RS_INITIAL_MIMO_NUM_RATES       3
+#define IWL_MVM_RS_INITIAL_SISO_NUM_RATES       3
+#define IWL_MVM_RS_INITIAL_LEGACY_NUM_RATES     16
+#define IWL_MVM_RS_SECONDARY_LEGACY_NUM_RATES   16
+#define IWL_MVM_RS_SECONDARY_SISO_NUM_RATES     3
+#define IWL_MVM_RS_SECONDARY_SISO_RETRIES       1
+#define IWL_MVM_RS_RATE_MIN_FAILURE_TH		3
+#define IWL_MVM_RS_RATE_MIN_SUCCESS_TH		8
+#define IWL_MVM_RS_STAY_IN_COLUMN_TIMEOUT	5	/* Seconds */
+#define IWL_MVM_RS_IDLE_TIMEOUT			5	/* Seconds */
+#define IWL_MVM_RS_MISSED_RATE_MAX		15
+#define IWL_MVM_RS_LEGACY_FAILURE_LIMIT		160
+#define IWL_MVM_RS_LEGACY_SUCCESS_LIMIT		480
+#define IWL_MVM_RS_LEGACY_TABLE_COUNT		160
+#define IWL_MVM_RS_NON_LEGACY_FAILURE_LIMIT	400
+#define IWL_MVM_RS_NON_LEGACY_SUCCESS_LIMIT	4500
+#define IWL_MVM_RS_NON_LEGACY_TABLE_COUNT	1500
+#define IWL_MVM_RS_SR_FORCE_DECREASE		15	/* percent */
+#define IWL_MVM_RS_SR_NO_DECREASE		85	/* percent */
+#define IWL_MVM_RS_AGG_TIME_LIMIT	        4000    /* 4 msecs. valid 100-8000 */
+#define IWL_MVM_RS_AGG_DISABLE_START	        3
+#define IWL_MVM_RS_TPC_SR_FORCE_INCREASE	75	/* percent */
+#define IWL_MVM_RS_TPC_SR_NO_INCREASE		85	/* percent */
+#define IWL_MVM_RS_TPC_TX_POWER_STEP		3
 #else /* CPTCFG_IWLWIFI_SUPPORT_DEBUG_OVERRIDES */
 #define IWL_MVM_DEFAULT_PS_TX_DATA_TIMEOUT	(mvm->trans->dbg_cfg.MVM_DEFAULT_PS_TX_DATA_TIMEOUT)
 #define IWL_MVM_DEFAULT_PS_RX_DATA_TIMEOUT	(mvm->trans->dbg_cfg.MVM_DEFAULT_PS_RX_DATA_TIMEOUT)
@@ -147,11 +176,40 @@
 #define IWL_MVM_TCM_LOWLAT_ENABLE_THRESH	(mvm->trans->dbg_cfg.MVM_TCM_LOWLAT_ENABLE_THRESH)
 #define IWL_MVM_QUOTA_AIRTIME_THRESH		(mvm->trans->dbg_cfg.MVM_QUOTA_AIRTIME_THRESH)
 #define IWL_MVM_LOWLAT_QUOTA_LOWTRAF_PERCENT	(mvm->trans->dbg_cfg.MVM_LOWLAT_QUOTA_LOWTRAF_PERCENT)
+#define IWL_MVM_UAPSD_AGGDETECT_MIN_PKTS	(mvm->trans->dbg_cfg.MVM_UAPSD_AGGDETECT_MIN_PKTS)
 #endif /* CPTCFG_IWLMVM_TCM */
 #define IWL_MVM_QUOTA_THRESHOLD			(mvm->trans->dbg_cfg.MVM_QUOTA_THRESHOLD)
-#define IWL_MVM_RS_RSSI_BASED_INIT_RATE         (mvm->trans->dbg_cfg.MVM_RS_RSSI_BASED_INIT_RATE)
-#define IWL_MVM_RS_DISABLE_MIMO                 (mvm->trans->dbg_cfg.MVM_RS_DISABLE_MIMO)
 #define IWL_MVM_RRM_PRETEND_QUIET_SUPPORT	(mvm->trans->dbg_cfg.MVM_RRM_PRETEND_QUIET_SUPPORT)
+#define IWL_MVM_RS_RSSI_BASED_INIT_RATE         (mvm->trans->dbg_cfg.MVM_RS_RSSI_BASED_INIT_RATE)
+#define IWL_MVM_RS_DISABLE_P2P_MIMO             (mvm->trans->dbg_cfg.MVM_RS_DISABLE_P2P_MIMO)
+#define IWL_MVM_RS_NUM_TRY_BEFORE_ANT_TOGGLE    (mvm->trans->dbg_cfg.MVM_RS_NUM_TRY_BEFORE_ANT_TOGGLE)
+#define IWL_MVM_RS_LEGACY_RETRIES_PER_RATE      (mvm->trans->dbg_cfg.MVM_RS_LEGACY_RETRIES_PER_RATE)
+#define IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE      (mvm->trans->dbg_cfg.MVM_RS_HT_VHT_RETRIES_PER_RATE)
+#define IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE_TW   (mvm->trans->dbg_cfg.MVM_RS_HT_VHT_RETRIES_PER_RATE_TW)
+#define IWL_MVM_RS_INITIAL_MIMO_NUM_RATES       (mvm->trans->dbg_cfg.MVM_RS_INITIAL_MIMO_NUM_RATES)
+#define IWL_MVM_RS_INITIAL_SISO_NUM_RATES       (mvm->trans->dbg_cfg.MVM_RS_INITIAL_SISO_NUM_RATES)
+#define IWL_MVM_RS_INITIAL_LEGACY_NUM_RATES     (mvm->trans->dbg_cfg.MVM_RS_INITIAL_LEGACY_NUM_RATES)
+#define IWL_MVM_RS_SECONDARY_LEGACY_NUM_RATES   (mvm->trans->dbg_cfg.MVM_RS_SECONDARY_LEGACY_NUM_RATES)
+#define IWL_MVM_RS_SECONDARY_SISO_NUM_RATES     (mvm->trans->dbg_cfg.MVM_RS_SECONDARY_SISO_NUM_RATES)
+#define IWL_MVM_RS_SECONDARY_SISO_RETRIES       (mvm->trans->dbg_cfg.MVM_RS_SECONDARY_SISO_RETRIES)
+#define IWL_MVM_RS_RATE_MIN_FAILURE_TH		(mvm->trans->dbg_cfg.MVM_RS_RATE_MIN_FAILURE_TH)
+#define IWL_MVM_RS_RATE_MIN_SUCCESS_TH		(mvm->trans->dbg_cfg.MVM_RS_RATE_MIN_SUCCESS_TH)
+#define IWL_MVM_RS_STAY_IN_COLUMN_TIMEOUT       (mvm->trans->dbg_cfg.MVM_RS_STAY_IN_COLUMN_TIMEOUT)
+#define IWL_MVM_RS_IDLE_TIMEOUT                 (mvm->trans->dbg_cfg.MVM_RS_IDLE_TIMEOUT)
+#define IWL_MVM_RS_MISSED_RATE_MAX		(mvm->trans->dbg_cfg.MVM_RS_MISSED_RATE_MAX)
+#define IWL_MVM_RS_LEGACY_FAILURE_LIMIT		(mvm->trans->dbg_cfg.MVM_RS_LEGACY_FAILURE_LIMIT)
+#define IWL_MVM_RS_LEGACY_SUCCESS_LIMIT		(mvm->trans->dbg_cfg.MVM_RS_LEGACY_SUCCESS_LIMIT)
+#define IWL_MVM_RS_LEGACY_TABLE_COUNT		(mvm->trans->dbg_cfg.MVM_RS_LEGACY_TABLE_COUNT)
+#define IWL_MVM_RS_NON_LEGACY_FAILURE_LIMIT	(mvm->trans->dbg_cfg.MVM_RS_NON_LEGACY_FAILURE_LIMIT)
+#define IWL_MVM_RS_NON_LEGACY_SUCCESS_LIMIT	(mvm->trans->dbg_cfg.MVM_RS_NON_LEGACY_SUCCESS_LIMIT)
+#define IWL_MVM_RS_NON_LEGACY_TABLE_COUNT	(mvm->trans->dbg_cfg.MVM_RS_NON_LEGACY_TABLE_COUNT)
+#define IWL_MVM_RS_SR_FORCE_DECREASE		(mvm->trans->dbg_cfg.MVM_RS_SR_FORCE_DECREASE)
+#define IWL_MVM_RS_SR_NO_DECREASE		(mvm->trans->dbg_cfg.MVM_RS_SR_NO_DECREASE)
+#define IWL_MVM_RS_AGG_TIME_LIMIT	        (mvm->trans->dbg_cfg.MVM_RS_AGG_TIME_LIMIT)
+#define IWL_MVM_RS_AGG_DISABLE_START	        (mvm->trans->dbg_cfg.MVM_RS_AGG_DISABLE_START)
+#define IWL_MVM_RS_TPC_SR_FORCE_INCREASE	(mvm->trans->dbg_cfg.MVM_RS_TPC_SR_FORCE_INCREASE)
+#define IWL_MVM_RS_TPC_SR_NO_INCREASE		(mvm->trans->dbg_cfg.MVM_RS_TPC_SR_NO_INCREASE)
+#define IWL_MVM_RS_TPC_TX_POWER_STEP		(mvm->trans->dbg_cfg.MVM_RS_TPC_TX_POWER_STEP)
 #endif /* CPTCFG_IWLWIFI_SUPPORT_DEBUG_OVERRIDES */
 
 #endif /* __MVM_CONSTANTS_H */
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/d3.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/d3.c
index db454c8..23ba51c 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/d3.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/d3.c
@@ -694,6 +694,9 @@ static int iwl_mvm_d3_reprogram(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 	if (ret)
 		IWL_ERR(mvm, "Failed to send quota: %d\n", ret);
 
+	if (iwl_mvm_is_lar_supported(mvm) && iwl_mvm_init_fw_regd(mvm))
+		IWL_ERR(mvm, "Failed to initialize D3 LAR information\n");
+
 	return 0;
 }
 
@@ -793,7 +796,7 @@ iwl_mvm_get_wowlan_config(struct iwl_mvm *mvm,
 			  struct ieee80211_sta *ap_sta)
 {
 	int ret;
-	struct iwl_mvm_sta *mvm_ap_sta = (struct iwl_mvm_sta *)ap_sta->drv_priv;
+	struct iwl_mvm_sta *mvm_ap_sta = iwl_mvm_sta_from_mac80211(ap_sta);
 
 	/* TODO: wowlan_config_cmd->wowlan_ba_teardown_tids */
 
@@ -1137,12 +1140,43 @@ static int __iwl_mvm_suspend(struct ieee80211_hw *hw,
 	return ret;
 }
 
+static int iwl_mvm_enter_d0i3_sync(struct iwl_mvm *mvm)
+{
+	struct iwl_notification_wait wait_d3;
+	static const u8 d3_notif[] = { D3_CONFIG_CMD };
+	int ret;
+
+	iwl_init_notification_wait(&mvm->notif_wait, &wait_d3,
+				   d3_notif, ARRAY_SIZE(d3_notif),
+				   NULL, NULL);
+
+	ret = iwl_mvm_enter_d0i3(mvm->hw->priv);
+	if (ret)
+		goto remove_notif;
+
+	ret = iwl_wait_notification(&mvm->notif_wait, &wait_d3, HZ);
+	WARN_ON_ONCE(ret);
+	return ret;
+
+remove_notif:
+	iwl_remove_notification(&mvm->notif_wait, &wait_d3);
+	return ret;
+}
+
 int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 {
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 
 	iwl_trans_suspend(mvm->trans);
-	if (iwl_mvm_is_d0i3_supported(mvm)) {
+	if (wowlan->any) {
+		/* 'any' trigger means d0i3 usage */
+		if (mvm->trans->d0i3_mode == IWL_D0I3_MODE_ON_SUSPEND) {
+			int ret = iwl_mvm_enter_d0i3_sync(mvm);
+
+			if (ret)
+				return ret;
+		}
+
 		mutex_lock(&mvm->d0i3_suspend_mutex);
 		__set_bit(D0I3_DEFER_WAKEUP, &mvm->d0i3_suspend_flags);
 		mutex_unlock(&mvm->d0i3_suspend_mutex);
@@ -1626,7 +1660,7 @@ static bool iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,
 	if (IS_ERR_OR_NULL(ap_sta))
 		goto out_free;
 
-	mvm_ap_sta = (struct iwl_mvm_sta *)ap_sta->drv_priv;
+	mvm_ap_sta = iwl_mvm_sta_from_mac80211(ap_sta);
 	for (i = 0; i < IWL_MAX_TID_COUNT; i++) {
 		u16 seq = status.qos_seq_ctr[i];
 		/* firmware stores last-used value, we store next value */
@@ -1843,6 +1877,19 @@ static int __iwl_mvm_resume(struct iwl_mvm *mvm, bool test)
 	/* query SRAM first in case we want event logging */
 	iwl_mvm_read_d3_sram(mvm);
 
+	/*
+	 * Query the current location and source from the D3 firmware so we
+	 * can play it back when we re-intiailize the D0 firmware
+	 */
+	if (iwl_mvm_is_lar_supported(mvm)) {
+		struct ieee80211_regdomain *regd =
+					iwl_mvm_get_current_regdomain(mvm);
+		if (!IS_ERR_OR_NULL(regd)) {
+			regulatory_set_wiphy_regd(mvm->hw->wiphy, regd);
+			kfree(regd);
+		}
+	}
+
 	if (mvm->net_detect) {
 		iwl_mvm_query_netdetect_reasons(mvm, vif);
 	} else {
@@ -1876,8 +1923,20 @@ int iwl_mvm_resume(struct ieee80211_hw *hw)
 
 	iwl_trans_resume(mvm->trans);
 
-	if (iwl_mvm_is_d0i3_supported(mvm))
+	if (mvm->hw->wiphy->wowlan_config->any) {
+		/* 'any' trigger means d0i3 usage */
+		if (mvm->trans->d0i3_mode == IWL_D0I3_MODE_ON_SUSPEND) {
+			int ret = iwl_mvm_exit_d0i3(hw->priv);
+
+			if (ret)
+				return ret;
+			/*
+			 * d0i3 exit will be deferred until reconfig_complete.
+			 * make sure there we are out of d0i3.
+			 */
+		}
 		return 0;
+	}
 
 	return __iwl_mvm_resume(mvm, false);
 }
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c
index 9aa2311..716535a 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c
@@ -268,7 +268,7 @@ static ssize_t iwl_dbgfs_mac_params_read(struct file *file,
 		sta = rcu_dereference_protected(mvm->fw_id_to_mac_id[ap_sta_id],
 						lockdep_is_held(&mvm->mutex));
 		if (!IS_ERR_OR_NULL(sta)) {
-			struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+			struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 
 			pos += scnprintf(buf+pos, bufsz-pos,
 					 "ap_sta_id %d - reduced Tx power %d\n",
@@ -546,7 +546,6 @@ void iwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 		return;
 
 	mvmvif->dbgfs_dir = debugfs_create_dir("iwlmvm", dbgfs_dir);
-	mvmvif->mvm = mvm;
 
 	if (!mvmvif->dbgfs_dir) {
 		IWL_ERR(mvm, "Failed to create debugfs directory under %s\n",
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs.c
index 2c87e2d..48c2b56 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/debugfs.c
@@ -933,7 +933,7 @@ iwl_dbgfs_scan_ant_rxchain_write(struct iwl_mvm *mvm, char *buf,
 		return -EINVAL;
 	if (scan_rx_ant > ANT_ABC)
 		return -EINVAL;
-	if (scan_rx_ant & ~mvm->fw->valid_rx_ant)
+	if (scan_rx_ant & ~(iwl_mvm_get_valid_rx_ant(mvm)))
 		return -EINVAL;
 
 	if (mvm->scan_rx_ant != scan_rx_ant) {
@@ -945,6 +945,56 @@ iwl_dbgfs_scan_ant_rxchain_write(struct iwl_mvm *mvm, char *buf,
 	return count;
 }
 
+static ssize_t iwl_dbgfs_fw_dbg_conf_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	struct iwl_mvm *mvm = file->private_data;
+	enum iwl_fw_dbg_conf conf;
+	char buf[8];
+	const size_t bufsz = sizeof(buf);
+	int pos = 0;
+
+	mutex_lock(&mvm->mutex);
+	conf = mvm->fw_dbg_conf;
+	mutex_unlock(&mvm->mutex);
+
+	pos += scnprintf(buf + pos, bufsz - pos, "%d\n", conf);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+}
+
+static ssize_t iwl_dbgfs_fw_dbg_conf_write(struct iwl_mvm *mvm,
+					   char *buf, size_t count,
+					   loff_t *ppos)
+{
+	int ret, conf_id;
+
+	ret = kstrtoint(buf, 0, &conf_id);
+	if (ret)
+		return ret;
+
+	if (WARN_ON(conf_id >= FW_DBG_MAX))
+		return -EINVAL;
+
+	mutex_lock(&mvm->mutex);
+	ret = iwl_mvm_start_fw_dbg_conf(mvm, conf_id);
+	mutex_unlock(&mvm->mutex);
+
+	return ret ?: count;
+}
+
+static ssize_t iwl_dbgfs_fw_dbg_collect_write(struct iwl_mvm *mvm,
+					      char *buf, size_t count,
+					      loff_t *ppos)
+{
+	mutex_lock(&mvm->mutex);
+	iwl_mvm_fw_dbg_collect(mvm);
+	mutex_unlock(&mvm->mutex);
+
+	return count;
+}
+
 #define ADD_TEXT(...) pos += scnprintf(buf + pos, bufsz - pos, __VA_ARGS__)
 #ifdef CPTCFG_IWLWIFI_BCAST_FILTERING
 static ssize_t iwl_dbgfs_bcast_filters_read(struct file *file,
@@ -1459,6 +1509,8 @@ MVM_DEBUGFS_WRITE_FILE_OPS(bt_tx_prio, 10);
 MVM_DEBUGFS_WRITE_FILE_OPS(bt_force_ant, 10);
 MVM_DEBUGFS_READ_WRITE_FILE_OPS(scan_ant_rxchain, 8);
 MVM_DEBUGFS_READ_WRITE_FILE_OPS(d0i3_refs, 8);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(fw_dbg_conf, 8);
+MVM_DEBUGFS_WRITE_FILE_OPS(fw_dbg_collect, 8);
 
 #ifdef CPTCFG_IWLWIFI_BCAST_FILTERING
 MVM_DEBUGFS_READ_WRITE_FILE_OPS(bcast_filters, 256);
@@ -1500,6 +1552,8 @@ int iwl_mvm_dbgfs_register(struct iwl_mvm *mvm, struct dentry *dbgfs_dir)
 			     S_IWUSR | S_IRUSR);
 	MVM_DEBUGFS_ADD_FILE(prph_reg, mvm->debugfs_dir, S_IWUSR | S_IRUSR);
 	MVM_DEBUGFS_ADD_FILE(d0i3_refs, mvm->debugfs_dir, S_IRUSR | S_IWUSR);
+	MVM_DEBUGFS_ADD_FILE(fw_dbg_conf, mvm->debugfs_dir, S_IRUSR | S_IWUSR);
+	MVM_DEBUGFS_ADD_FILE(fw_dbg_collect, mvm->debugfs_dir, S_IWUSR);
 
 #ifdef CPTCFG_IWLWIFI_BCAST_FILTERING
 	if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_BCAST_FILTERING) {
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h
index 1f2acf4..2d1a81c 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h
@@ -653,8 +653,11 @@ enum iwl_scan_channel_flags {
 };
 
 /* iwl_scan_channel_opt - CHANNEL_OPTIMIZATION_API_S
- * @flags: enum iwl_scan_channel_flgs
- * @non_ebs_ratio: how many regular scan iteration before EBS
+ * @flags: enum iwl_scan_channel_flags
+ * @non_ebs_ratio: defines the ratio of number of scan iterations where EBS is
+ *	involved.
+ *	1 - EBS is disabled.
+ *	2 - every second scan will be full scan(and so on).
  */
 struct iwl_scan_channel_opt {
 	__le16 flags;
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api.h
index 0489e8f..5c23317 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw-api.h
@@ -1671,11 +1671,13 @@ struct iwl_sf_cfg_cmd {
  * 'ZZ' MCC will be used to switch to NVM default profile; in this case, the
  * MCC in the cmd response will be the relevant MCC in the NVM.
  * @mcc: given mobile contry code
+ * @source_id: the source from where we got the MCC, see iwl_mcc_source
  * @reserved: reserved for alignment
  */
 struct iwl_mcc_update_cmd {
 	__le16 mcc;
-	__le16 reserved;
+	u8 source_id;
+	u8 reserved;
 } __packed; /* LAR_UPDATE_MCC_CMD_API_S */
 
 /**
@@ -1685,6 +1687,8 @@ struct iwl_mcc_update_cmd {
  * The new MCC may be different than what was requested in MCC_UPDATE_CMD.
  * @status: 0 for success, 1 no change in channel profile, 2 invalid input.
  * @mcc: the new applied MCC
+ * @cap: capabilities for all channels which matches the MCC
+ * @source_id: the MCC source, see iwl_mcc_source
  * @n_channels: number of channels in @channels_data (may be 14, 39, 50 or 51
  *		channels, depending on platform)
  * @channels: channel control data map, DWORD for each channel. Only the first
@@ -1693,7 +1697,8 @@ struct iwl_mcc_update_cmd {
 struct iwl_mcc_update_resp {
 	__le32 status;
 	__le16 mcc;
-	__le16 reserved;
+	u8 cap;
+	u8 source_id;
 	__le32 n_channels;
 	__le32 channels[0];
 } __packed; /* LAR_UPDATE_MCC_CMD_RESP_S */
@@ -1710,11 +1715,13 @@ struct iwl_mcc_update_resp {
  * 'ZZ' MCC will be used to switch to NVM default profile; in this case, the
  * MCC in the cmd response will be the relevant MCC in the NVM.
  * @mcc: given mobile contry code
- * @reserved: reserved for alignment
+ * @source_id: identity of the change originator, see iwl_mcc_source
+ * @reserved1: reserved for alignment
  */
 struct iwl_mcc_chub_notif {
 	u16 mcc;
-	u16 reserved1;
+	u8 source_id;
+	u8 reserved1;
 } __packed; /* LAR_MCC_NOTIFY_S */
 
 enum iwl_mcc_update_status {
@@ -1722,6 +1729,21 @@ enum iwl_mcc_update_status {
 	MCC_RESP_SAME_CHAN_PROFILE,
 	MCC_RESP_INVALID,
 	MCC_RESP_NVM_DISABLED,
+	MCC_RESP_ILLEGAL,
+	MCC_RESP_LOW_PRIORITY,
+};
+
+enum iwl_mcc_source {
+	MCC_SOURCE_OLD_FW = 0,
+	MCC_SOURCE_ME = 1,
+	MCC_SOURCE_BIOS = 2,
+	MCC_SOURCE_3G_LTE_HOST = 3,
+	MCC_SOURCE_3G_LTE_DEVICE = 4,
+	MCC_SOURCE_WIFI = 5,
+	MCC_SOURCE_RESERVED = 6,
+	MCC_SOURCE_DEFAULT = 7,
+	MCC_SOURCE_UNINITIALIZED = 8,
+	MCC_SOURCE_GET_CURRENT = 0x10
 };
 
 /* DTS measurements */
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw.c
index 88c1b1e..f21066d 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/fw.c
@@ -70,6 +70,7 @@
 #include "iwl-debug.h"
 #include "iwl-csr.h" /* for iwl_mvm_rx_card_state_notif */
 #include "iwl-io.h" /* for iwl_mvm_rx_card_state_notif */
+#include "iwl-prph.h"
 #include "iwl-eeprom-parse.h"
 
 #include "mvm.h"
@@ -279,7 +280,7 @@ static int iwl_send_phy_cfg_cmd(struct iwl_mvm *mvm)
 #endif
 
 	/* Set parameters */
-	phy_cfg_cmd.phy_cfg = cpu_to_le32(mvm->fw->phy_config);
+	phy_cfg_cmd.phy_cfg = cpu_to_le32(iwl_mvm_get_phy_config(mvm));
 	phy_cfg_cmd.calib_control.event_trigger =
 		mvm->fw->default_calib[ucode_type].event_trigger;
 	phy_cfg_cmd.calib_control.flow_trigger =
@@ -425,7 +426,7 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 	mvm->calibrating = true;
 
 	/* Send TX valid antennas before triggering calibrations */
-	ret = iwl_send_tx_ant_cfg(mvm, mvm->fw->valid_tx_ant);
+	ret = iwl_send_tx_ant_cfg(mvm, iwl_mvm_get_valid_tx_ant(mvm));
 	if (ret)
 		goto error;
 
@@ -478,8 +479,26 @@ out:
 	return ret;
 }
 
-static int iwl_mvm_start_fw_dbg_conf(struct iwl_mvm *mvm,
-				     enum iwl_fw_dbg_conf conf_id)
+void iwl_mvm_fw_dbg_collect(struct iwl_mvm *mvm)
+{
+	lockdep_assert_held(&mvm->mutex);
+
+	/* stop recording */
+	if (mvm->cfg->device_family == IWL_DEVICE_FAMILY_7000) {
+		iwl_set_bits_prph(mvm->trans, MON_BUFF_SAMPLE_CTL, 0x100);
+	} else {
+		iwl_write_prph(mvm->trans, DBGC_IN_SAMPLE, 0);
+		iwl_write_prph(mvm->trans, DBGC_OUT_CTRL, 0);
+	}
+
+	iwl_mvm_fw_error_dump(mvm);
+
+	/* start recording again */
+	WARN_ON_ONCE(mvm->fw->dbg_dest_tlv &&
+		     iwl_mvm_start_fw_dbg_conf(mvm, mvm->fw_dbg_conf));
+}
+
+int iwl_mvm_start_fw_dbg_conf(struct iwl_mvm *mvm, enum iwl_fw_dbg_conf conf_id)
 {
 	u8 *ptr;
 	int ret;
@@ -572,7 +591,7 @@ int iwl_mvm_up(struct iwl_mvm *mvm)
 	mvm->fw_dbg_conf = FW_DBG_INVALID;
 	iwl_mvm_start_fw_dbg_conf(mvm, FW_DBG_CUSTOM);
 
-	ret = iwl_send_tx_ant_cfg(mvm, mvm->fw->valid_tx_ant);
+	ret = iwl_send_tx_ant_cfg(mvm, iwl_mvm_get_valid_tx_ant(mvm));
 	if (ret)
 		goto error;
 
@@ -674,7 +693,7 @@ int iwl_mvm_load_d3_fw(struct iwl_mvm *mvm)
 #ifdef CPTCFG_IWLWIFI_DEVICE_TESTMODE
 	iwl_dnt_start(mvm->trans);
 #endif
-	ret = iwl_send_tx_ant_cfg(mvm, mvm->fw->valid_tx_ant);
+	ret = iwl_send_tx_ant_cfg(mvm, iwl_mvm_get_valid_tx_ant(mvm));
 	if (ret)
 		goto error;
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
index f6d86cc..7196b4d 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
@@ -975,7 +975,7 @@ static int iwl_mvm_mac_ctxt_send_beacon(struct iwl_mvm *mvm,
 	beacon_cmd.tx.tx_flags = cpu_to_le32(tx_flags);
 
 	mvm->mgmt_last_antenna_idx =
-		iwl_mvm_next_antenna(mvm, mvm->fw->valid_tx_ant,
+		iwl_mvm_next_antenna(mvm, iwl_mvm_get_valid_tx_ant(mvm),
 				     mvm->mgmt_last_antenna_idx);
 
 	beacon_cmd.tx.rate_n_flags =
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac80211.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac80211.c
index f50e633..c4a263e 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac80211.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mac80211.c
@@ -307,8 +307,9 @@ static void iwl_mvm_reset_phy_ctxts(struct iwl_mvm *mvm)
 	}
 }
 
-static struct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,
-							 const char *alpha2)
+struct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,
+						  const char *alpha2,
+						  enum iwl_mcc_source src_id)
 {
 	struct ieee80211_regdomain *regd = NULL;
 	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
@@ -317,39 +318,75 @@ static struct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,
 
 	IWL_DEBUG_LAR(mvm, "Getting regdomain data for %s from FW\n", alpha2);
 
-	mutex_lock(&mvm->mutex);
-
-	/* change "99" to "ZZ" for the FW */
-	if (alpha2[0] == '9' && alpha2[1] == '9')
-		alpha2 = "ZZ";
+	lockdep_assert_held(&mvm->mutex);
 
-	resp = iwl_mvm_update_mcc(mvm, alpha2);
+	resp = iwl_mvm_update_mcc(mvm, alpha2, src_id);
 	if (IS_ERR_OR_NULL(resp)) {
 		IWL_DEBUG_LAR(mvm, "Could not get update from FW %d\n",
 			      PTR_RET(resp));
-		goto out_unlock;
+		goto out;
 	}
 
 	regd = iwl_parse_nvm_mcc_info(mvm->trans->dev, mvm->cfg,
 				      __le32_to_cpu(resp->n_channels),
 				      resp->channels,
 				      __le16_to_cpu(resp->mcc));
+	/* Store the return source id */
+	src_id = resp->source_id;
 	kfree(resp);
 	if (IS_ERR_OR_NULL(regd)) {
 		IWL_DEBUG_LAR(mvm, "Could not get parse update from FW %d\n",
 			      PTR_RET(regd));
-		goto out_unlock;
+		goto out;
 	}
 
-	IWL_DEBUG_LAR(mvm, "setting alpha2 from FW to %s (0x%x, 0x%x)\n",
-		      regd->alpha2, regd->alpha2[0], regd->alpha2[1]);
+	IWL_DEBUG_LAR(mvm, "setting alpha2 from FW to %s (0x%x, 0x%x) src=%d\n",
+		      regd->alpha2, regd->alpha2[0], regd->alpha2[1], src_id);
 	mvm->lar_regdom_set = true;
+	mvm->mcc_src = src_id;
 
-out_unlock:
-	mutex_unlock(&mvm->mutex);
+out:
 	return regd;
 }
 
+struct ieee80211_regdomain *iwl_mvm_get_current_regdomain(struct iwl_mvm *mvm)
+{
+	return iwl_mvm_get_regdomain(mvm->hw->wiphy, "ZZ",
+				     iwl_mvm_is_wifi_mcc_supported(mvm) ?
+				     MCC_SOURCE_GET_CURRENT :
+				     MCC_SOURCE_OLD_FW);
+}
+
+int iwl_mvm_init_fw_regd(struct iwl_mvm *mvm)
+{
+	enum iwl_mcc_source used_src;
+	struct ieee80211_regdomain *regd;
+	const struct ieee80211_regdomain *r =
+			rtnl_dereference(mvm->hw->wiphy->regd);
+
+	if (!r)
+		return 0;
+
+	/* save the last source in case we overwrite it below */
+	used_src = mvm->mcc_src;
+	if (iwl_mvm_is_wifi_mcc_supported(mvm)) {
+		/* Notify the firmware we support wifi location updates */
+		regd = iwl_mvm_get_current_regdomain(mvm);
+		if (!IS_ERR_OR_NULL(regd))
+			kfree(regd);
+	}
+
+	/* Now set our last stored MCC and source */
+	regd = iwl_mvm_get_regdomain(mvm->hw->wiphy, r->alpha2, used_src);
+	if (IS_ERR_OR_NULL(regd))
+		return -EIO;
+
+	regulatory_set_wiphy_regd(mvm->hw->wiphy, regd);
+	kfree(regd);
+
+	return 0;
+}
+
 int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 {
 	struct ieee80211_hw *hw = mvm->hw;
@@ -408,9 +445,12 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 		BIT(NL80211_IFTYPE_ADHOC);
 
 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
-	hw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |
-				       REGULATORY_DISABLE_BEACON_HINTS |
-				       REGULATORY_ENABLE_RELAX_NO_IR;
+	hw->wiphy->regulatory_flags |= REGULATORY_ENABLE_RELAX_NO_IR;
+	if (iwl_mvm_is_lar_supported(mvm))
+		hw->wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
+	else
+		hw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |
+					       REGULATORY_DISABLE_BEACON_HINTS;
 
 	if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_GO_UAPSD)
 		hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
@@ -495,12 +535,6 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 	    IWL_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT)
 		hw->wiphy->features |= NL80211_FEATURE_WFA_TPC_IE_IN_PROBES;
 
-	if (iwl_mvm_is_lar_supported(mvm)) {
-		hw->wiphy->get_regd = iwl_mvm_get_regdomain;
-		hw->wiphy->features |= NL80211_FEATURE_CELL_BASE_REG_HINTS;
-		hw->wiphy->regulatory_flags |= REGULATORY_COUNTRY_IE_IGNORE;
-	}
-
 	mvm->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
 
 	/* currently FW API supports only one optional cipher scheme */
@@ -514,15 +548,17 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 	    device_can_wakeup(mvm->trans->dev)) {
 		mvm->wowlan.flags = WIPHY_WOWLAN_ANY;
 		hw->wiphy->wowlan = &mvm->wowlan;
-	} else if (mvm->fw->img[IWL_UCODE_WOWLAN].sec[0].len &&
+	}
+
+	if (mvm->fw->img[IWL_UCODE_WOWLAN].sec[0].len &&
 	    mvm->trans->ops->d3_suspend &&
 	    mvm->trans->ops->d3_resume &&
 	    device_can_wakeup(mvm->trans->dev)) {
-		mvm->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT |
-				    WIPHY_WOWLAN_DISCONNECT |
-				    WIPHY_WOWLAN_EAP_IDENTITY_REQ |
-				    WIPHY_WOWLAN_RFKILL_RELEASE |
-				    WIPHY_WOWLAN_NET_DETECT;
+		mvm->wowlan.flags |= WIPHY_WOWLAN_MAGIC_PKT |
+				     WIPHY_WOWLAN_DISCONNECT |
+				     WIPHY_WOWLAN_EAP_IDENTITY_REQ |
+				     WIPHY_WOWLAN_RFKILL_RELEASE |
+				     WIPHY_WOWLAN_NET_DETECT;
 		if (!iwlwifi_mod_params.sw_crypto)
 			mvm->wowlan.flags |= WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
 					     WIPHY_WOWLAN_GTK_REKEY_FAILURE |
@@ -712,6 +748,18 @@ static int iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,
 
 	switch (action) {
 	case IEEE80211_AMPDU_RX_START:
+#ifdef CPTCFG_IWLMVM_TCM
+		if (iwl_mvm_vif_from_mac80211(vif)->ap_sta_id ==
+				iwl_mvm_sta_from_mac80211(sta)->sta_id) {
+			struct iwl_mvm_vif *mvmvif;
+			u16 macid = iwl_mvm_vif_from_mac80211(vif)->id;
+			struct iwl_mvm_tcm_mac *mdata = &mvm->tcm.data[macid];
+
+			mdata->opened_rx_ba_sessions = true;
+			mvmvif = iwl_mvm_vif_from_mac80211(vif);
+			cancel_delayed_work(&mvmvif->uapsd_nonagg_detected_wk);
+		}
+#endif
 		if (!iwl_enable_rx_ampdu(mvm->cfg)) {
 			ret = -EINVAL;
 			break;
@@ -823,6 +871,7 @@ void iwl_mvm_fw_error_dump(struct iwl_mvm *mvm)
 	struct iwl_fw_error_dump_file *dump_file;
 	struct iwl_fw_error_dump_data *dump_data;
 	struct iwl_fw_error_dump_info *dump_info;
+	struct iwl_fw_error_dump_mem *dump_mem;
 	struct iwl_mvm_dump_ptrs *fw_error_dump;
 	u32 sram_len, sram_ofs;
 	u32 file_len, rxf_len;
@@ -863,13 +912,13 @@ void iwl_mvm_fw_error_dump(struct iwl_mvm *mvm)
 
 	file_len = sizeof(*dump_file) +
 		   sizeof(*dump_data) * 3 +
-		   sram_len +
+		   sram_len + sizeof(*dump_mem) +
 		   rxf_len +
 		   sizeof(*dump_info);
 
 	/* Make room for the SMEM, if it exists */
 	if (smem_len)
-		file_len += sizeof(*dump_data) + smem_len;
+		file_len += sizeof(*dump_data) + sizeof(*dump_mem) + smem_len;
 
 	dump_file = vzalloc(file_len);
 	if (!dump_file) {
@@ -889,6 +938,7 @@ void iwl_mvm_fw_error_dump(struct iwl_mvm *mvm)
 		mvm->cfg->device_family == IWL_DEVICE_FAMILY_7000 ?
 			cpu_to_le32(IWL_FW_ERROR_DUMP_FAMILY_7) :
 			cpu_to_le32(IWL_FW_ERROR_DUMP_FAMILY_8);
+	dump_info->hw_step = cpu_to_le32(CSR_HW_REV_STEP(mvm->trans->hw_rev));
 	memcpy(dump_info->fw_human_readable, mvm->fw->human_readable,
 	       sizeof(dump_info->fw_human_readable));
 	strncpy(dump_info->dev_human_readable, mvm->cfg->name,
@@ -915,17 +965,23 @@ void iwl_mvm_fw_error_dump(struct iwl_mvm *mvm)
 	}
 
 	dump_data = iwl_fw_error_next_data(dump_data);
-	dump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_SRAM);
-	dump_data->len = cpu_to_le32(sram_len);
-	iwl_trans_read_mem_bytes(mvm->trans, sram_ofs, dump_data->data,
+	dump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM);
+	dump_data->len = cpu_to_le32(sram_len + sizeof(*dump_mem));
+	dump_mem = (void *)dump_data->data;
+	dump_mem->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM_SRAM);
+	dump_mem->offset = cpu_to_le32(sram_ofs);
+	iwl_trans_read_mem_bytes(mvm->trans, sram_ofs, dump_mem->data,
 				 sram_len);
 
 	if (smem_len) {
 		dump_data = iwl_fw_error_next_data(dump_data);
-		dump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_SMEM);
-		dump_data->len = cpu_to_le32(smem_len);
+		dump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM);
+		dump_data->len = cpu_to_le32(smem_len + sizeof(*dump_mem));
+		dump_mem = (void *)dump_data->data;
+		dump_mem->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM_SMEM);
+		dump_mem->offset = cpu_to_le32(mvm->cfg->smem_offset);
 		iwl_trans_read_mem_bytes(mvm->trans, mvm->cfg->smem_offset,
-					 dump_data->data, smem_len);
+					 dump_mem->data, smem_len);
 	}
 
 	fw_error_dump->trans_ptr = iwl_trans_dump_data(mvm->trans);
@@ -952,6 +1008,11 @@ static void iwl_mvm_restart_cleanup(struct iwl_mvm *mvm)
 #endif
 	}
 
+	/* cleanup all stale references (scan, roc), but keep the
+	 * ucode_down ref until reconfig is complete
+	 */
+	iwl_mvm_unref_all_except(mvm, IWL_MVM_REF_UCODE_DOWN);
+
 	iwl_trans_stop_device(mvm->trans);
 
 	mvm->scan_status = IWL_MVM_SCAN_NONE;
@@ -981,10 +1042,6 @@ static void iwl_mvm_restart_cleanup(struct iwl_mvm *mvm)
 
 	ieee80211_wake_queues(mvm->hw);
 
-	/* cleanup all stale references (scan, roc), but keep the
-	 * ucode_down ref until reconfig is complete */
-	iwl_mvm_unref_all_except(mvm, IWL_MVM_REF_UCODE_DOWN);
-
 	/* clear any stale d0i3 state */
 	clear_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status);
 
@@ -1021,6 +1078,19 @@ static int iwl_mvm_mac_start(struct ieee80211_hw *hw)
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 	int ret;
 
+	/* Some hw restart cleanups must not hold the mutex */
+	if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {
+		/*
+		 * Make sure we are out of d0i3. This is needed
+		 * to make sure the reference accounting is correct
+		 * (and there is no stale d0i3_exit_work).
+		 */
+		wait_event_timeout(mvm->d0i3_exit_waitq,
+				   !test_bit(IWL_MVM_STATUS_IN_D0I3,
+					     &mvm->status),
+				   HZ);
+	}
+
 	mutex_lock(&mvm->mutex);
 	ret = __iwl_mvm_mac_start(mvm);
 	mutex_unlock(&mvm->mutex);
@@ -1070,6 +1140,13 @@ static void iwl_mvm_resume_complete(struct iwl_mvm *mvm)
 		IWL_DEBUG_RPM(mvm, "Run deferred d0i3 exit\n");
 		_iwl_mvm_exit_d0i3(mvm);
 	}
+
+	if (mvm->trans->d0i3_mode == IWL_D0I3_MODE_ON_SUSPEND)
+		if (!wait_event_timeout(mvm->d0i3_exit_waitq,
+					!test_bit(IWL_MVM_STATUS_IN_D0I3,
+						  &mvm->status),
+					HZ))
+			WARN_ONCE(1, "D0i3 exit on resume timed out\n");
 }
 
 static void
@@ -1092,8 +1169,13 @@ void __iwl_mvm_mac_stop(struct iwl_mvm *mvm)
 {
 	lockdep_assert_held(&mvm->mutex);
 
-	/* disallow low power states when the FW is down */
-	iwl_mvm_ref(mvm, IWL_MVM_REF_UCODE_DOWN);
+	/*
+	 * Disallow low power states when the FW is down by taking
+	 * the UCODE_DOWN ref. in case of ongoing hw restart the
+	 * ref is already taken, so don't take it again.
+	 */
+	if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))
+		iwl_mvm_ref(mvm, IWL_MVM_REF_UCODE_DOWN);
 
 	/* async_handlers_wk is now blocked */
 
@@ -1111,6 +1193,12 @@ void __iwl_mvm_mac_stop(struct iwl_mvm *mvm)
 	/* the fw is stopped, the aux sta is dead: clean up driver state */
 	iwl_mvm_del_aux_sta(mvm);
 
+	/*
+	 * Clear IN_HW_RESTART flag when stopping the hw (as restart_complete()
+	 * won't be called in this case).
+	 */
+	clear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);
+
 	mvm->ucode_loaded = false;
 }
 
@@ -1168,6 +1256,8 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 	int ret;
 
+	mvmvif->mvm = mvm;
+
 	/*
 	 * make sure D0i3 exit is completed, otherwise a target access
 	 * during tx queue configuration could be done when still in
@@ -1264,6 +1354,10 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
 		mvm->p2p_device_vif = vif;
 	}
 
+#ifdef CPTCFG_IWLMVM_TCM
+	iwl_mvm_tcm_add_vif(mvm, vif);
+#endif
+
 	iwl_mvm_vif_dbgfs_register(mvm, vif);
 	goto out_unlock;
 
@@ -1330,6 +1424,10 @@ static void iwl_mvm_mac_remove_interface(struct ieee80211_hw *hw,
 
 	iwl_mvm_prepare_mac_removal(mvm, vif);
 
+#ifdef CPTCFG_IWLMVM_TCM
+	iwl_mvm_tcm_rm_vif(mvm, vif);
+#endif
+
 	mutex_lock(&mvm->mutex);
 
 	if (mvm->bf_allowed_vif == mvmvif) {
@@ -2171,7 +2269,7 @@ static void iwl_mvm_sta_pre_rcu_remove(struct ieee80211_hw *hw,
 				       struct ieee80211_sta *sta)
 {
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 
 	/*
 	 * This is called before mac80211 does RCU synchronisation,
@@ -2191,6 +2289,14 @@ static void iwl_mvm_sta_pre_rcu_remove(struct ieee80211_hw *hw,
 static void iwl_mvm_check_uapsd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 				const u8 *bssid)
 {
+#ifdef CPTCFG_IWLMVM_TCM
+	struct iwl_mvm_tcm_mac *mdata;
+	int i;
+
+	mdata = &mvm->tcm.data[iwl_mvm_vif_from_mac80211(vif)->id];
+	mdata->opened_rx_ba_sessions = false;
+#endif
+
 	if (!(mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT))
 		return;
 
@@ -2199,6 +2305,15 @@ static void iwl_mvm_check_uapsd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 		return;
 	}
 
+#ifdef CPTCFG_IWLMVM_TCM
+	for (i = 0; i < IWL_MVM_UAPSD_NOAGG_BSSIDS_NUM; i++) {
+		if (ether_addr_equal(mvm->uapsd_noagg_bssids[i].addr, bssid)) {
+			vif->driver_flags &= ~IEEE80211_VIF_SUPPORTS_UAPSD;
+			return;
+		}
+	}
+#endif
+
 	vif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;
 }
 
@@ -3208,7 +3323,7 @@ static int iwl_mvm_set_tim(struct ieee80211_hw *hw,
 			   bool set)
 {
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 
 	if (!mvm_sta || !mvm_sta->vif) {
 		IWL_ERR(mvm, "Station is not associated to a vif\n");
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mvm.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mvm.h
index 166d7bf..d0c53fb 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mvm.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/mvm.h
@@ -79,6 +79,10 @@
 #include "fw-api.h"
 #include "constants.h"
 
+#ifdef CPTCFG_IWLMVM_TCM
+#include <linux/average.h>
+#endif
+
 #define IWL_INVALID_MAC80211_QUEUE	0xff
 #define IWL_MVM_MAX_ADDRESSES		5
 /* RSSI offset for WkP */
@@ -337,6 +341,7 @@ struct iwl_mvm_vif_bf_data {
  *	combined on update to yield the overall request to mac80211.
  */
 struct iwl_mvm_vif {
+	struct iwl_mvm *mvm;
 	u16 id;
 	u16 color;
 	u8 ap_sta_id;
@@ -394,7 +399,6 @@ struct iwl_mvm_vif {
 #endif
 
 #ifdef CPTCFG_IWLWIFI_DEBUGFS
-	struct iwl_mvm *mvm;
 	struct dentry *dbgfs_dir;
 	struct dentry *dbgfs_slink;
 	struct iwl_dbgfs_pm dbgfs_pm;
@@ -407,6 +411,10 @@ struct iwl_mvm_vif {
 	/* FW identified misbehaving AP */
 	u8 uapsd_misbehaving_bssid[ETH_ALEN];
 
+#ifdef CPTCFG_IWLMVM_TCM
+	struct delayed_work uapsd_nonagg_detected_wk;
+#endif
+
 	/* Indicates that CSA countdown may be started */
 	bool csa_countdown;
 };
@@ -546,6 +554,14 @@ struct iwl_mvm_tcm_mac {
 		u32 pkts[IEEE80211_NUM_ACS];
 		u32 airtime[IEEE80211_NUM_ACS];
 	} rx;
+	struct {
+		/* track AP's transfer in client mode */
+		u64 rx_bytes;
+		u32 rx_pkts;
+		struct ewma rate;
+		bool detected;
+	} uapsd_nonagg_detect;
+	bool opened_rx_ba_sessions;
 };
 
 struct iwl_mvm_tcm {
@@ -773,6 +789,13 @@ struct iwl_mvm {
 	bool temperature_test;  /* Debug test temperature is enabled */
 
 #ifdef CPTCFG_IWLMVM_TCM
+#define IWL_MVM_UAPSD_NOAGG_BSSIDS_NUM	20
+	unsigned long bt_coex_last_tcm_ts;
+
+	u8 uapsd_noagg_bssid_write_idx;
+	struct mac_address uapsd_noagg_bssids[IWL_MVM_UAPSD_NOAGG_BSSIDS_NUM]
+		__aligned(2);
+
 	struct iwl_mvm_tcm tcm;
 #endif
 
@@ -799,6 +822,8 @@ struct iwl_mvm {
 	u32 ap_last_beacon_gp2;
 
 	bool lar_regdom_set;
+	enum iwl_mcc_source mcc_src;
+
 	u8 low_latency_agg_frame_limit;
 
 	/* TDLS channel switch data */
@@ -888,6 +913,8 @@ iwl_mvm_sta_from_staid_protected(struct iwl_mvm *mvm, u8 sta_id)
 static inline bool iwl_mvm_is_d0i3_supported(struct iwl_mvm *mvm)
 {
 	return mvm->trans->cfg->d0i3 &&
+	       mvm->trans->d0i3_mode != IWL_D0I3_MODE_OFF &&
+	       !iwlwifi_mod_params.d0i3_disable &&
 	       (mvm->fw->ucode_capa.capa[0] & IWL_UCODE_TLV_CAPA_D0I3_SUPPORT);
 }
 
@@ -906,6 +933,11 @@ static inline bool iwl_mvm_is_lar_supported(struct iwl_mvm *mvm)
 		return tlv_lar;
 }
 
+static inline bool iwl_mvm_is_wifi_mcc_supported(struct iwl_mvm *mvm)
+{
+	return mvm->fw->ucode_capa.api[0] & IWL_UCODE_TLV_API_WIFI_MCC_UPDATE;
+}
+
 static inline bool iwl_mvm_is_dqa_supported(struct iwl_mvm *mvm)
 {
 	return mvm->fw->ucode_capa.capa[0] & IWL_UCODE_TLV_CAPA_DQA_SUPPORT;
@@ -990,6 +1022,33 @@ int iwl_mvm_rx_statistics(struct iwl_mvm *mvm,
 int iwl_nvm_init(struct iwl_mvm *mvm, bool read_nvm_from_nic);
 int iwl_mvm_load_nvm_to_nic(struct iwl_mvm *mvm);
 
+static inline u8 iwl_mvm_get_valid_tx_ant(struct iwl_mvm *mvm)
+{
+	return mvm->nvm_data && mvm->nvm_data->valid_tx_ant ?
+	       mvm->fw->valid_tx_ant & mvm->nvm_data->valid_tx_ant :
+	       mvm->fw->valid_tx_ant;
+}
+
+static inline u8 iwl_mvm_get_valid_rx_ant(struct iwl_mvm *mvm)
+{
+	return mvm->nvm_data && mvm->nvm_data->valid_rx_ant ?
+	       mvm->fw->valid_rx_ant & mvm->nvm_data->valid_rx_ant :
+	       mvm->fw->valid_rx_ant;
+}
+
+static inline u32 iwl_mvm_get_phy_config(struct iwl_mvm *mvm)
+{
+	u32 phy_config = ~(FW_PHY_CFG_TX_CHAIN |
+			   FW_PHY_CFG_RX_CHAIN);
+	u32 valid_rx_ant = iwl_mvm_get_valid_rx_ant(mvm);
+	u32 valid_tx_ant = iwl_mvm_get_valid_tx_ant(mvm);
+
+	phy_config |= valid_tx_ant << FW_PHY_CFG_TX_CHAIN_POS |
+		      valid_rx_ant << FW_PHY_CFG_RX_CHAIN_POS;
+
+	return mvm->fw->phy_config & phy_config;
+}
+
 int iwl_mvm_up(struct iwl_mvm *mvm);
 int iwl_mvm_load_d3_fw(struct iwl_mvm *mvm);
 
@@ -1233,6 +1292,8 @@ void iwl_mvm_unref(struct iwl_mvm *mvm, enum iwl_mvm_ref_type ref_type);
 int iwl_mvm_ref_sync(struct iwl_mvm *mvm, enum iwl_mvm_ref_type ref_type);
 bool iwl_mvm_ref_taken(struct iwl_mvm *mvm);
 void iwl_mvm_d0i3_enable_tx(struct iwl_mvm *mvm, __le16 *qos_seq);
+int iwl_mvm_enter_d0i3(struct iwl_op_mode *op_mode);
+int iwl_mvm_exit_d0i3(struct iwl_op_mode *op_mode);
 int _iwl_mvm_exit_d0i3(struct iwl_mvm *mvm);
 
 /* BT Coex */
@@ -1382,11 +1443,17 @@ int iwl_mvm_get_temp(struct iwl_mvm *mvm);
 
 /* Location Aware Regulatory */
 struct iwl_mcc_update_resp *
-iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2);
+iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2,
+		   enum iwl_mcc_source src_id);
 int iwl_mvm_init_mcc(struct iwl_mvm *mvm);
 int iwl_mvm_rx_chub_update_mcc(struct iwl_mvm *mvm,
 			       struct iwl_rx_cmd_buffer *rxb,
 			       struct iwl_device_cmd *cmd);
+struct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,
+						  const char *alpha2,
+						  enum iwl_mcc_source src_id);
+struct ieee80211_regdomain *iwl_mvm_get_current_regdomain(struct iwl_mvm *mvm);
+int iwl_mvm_init_fw_regd(struct iwl_mvm *mvm);
 
 /* smart fifo */
 int iwl_mvm_sf_update(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
@@ -1435,9 +1502,14 @@ void iwl_mvm_tcm_work(struct work_struct *work);
 void iwl_mvm_recalc_tcm(struct iwl_mvm *mvm);
 void iwl_mvm_pause_tcm(struct iwl_mvm *mvm);
 void iwl_mvm_resume_tcm(struct iwl_mvm *mvm);
+void iwl_mvm_tcm_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
+void iwl_mvm_tcm_rm_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
 #endif
 
 void iwl_mvm_nic_restart(struct iwl_mvm *mvm, bool fw_error);
 void iwl_mvm_fw_error_dump(struct iwl_mvm *mvm);
 
+int iwl_mvm_start_fw_dbg_conf(struct iwl_mvm *mvm, enum iwl_fw_dbg_conf id);
+void iwl_mvm_fw_dbg_collect(struct iwl_mvm *mvm);
+
 #endif /* __IWL_MVM_H__ */
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/nvm.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/nvm.c
index 19b5c93..c67c2bc 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/nvm.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/nvm.c
@@ -64,6 +64,8 @@
  *****************************************************************************/
 #include <linux/firmware.h>
 #include <linux/rtnetlink.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
 #include "iwl-trans.h"
 #include "iwl-csr.h"
 #include "mvm.h"
@@ -587,10 +589,12 @@ int iwl_nvm_init(struct iwl_mvm *mvm, bool read_nvm_from_nic)
 }
 
 struct iwl_mcc_update_resp *
-iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2)
+iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2,
+		   enum iwl_mcc_source src_id)
 {
 	struct iwl_mcc_update_cmd mcc_update_cmd = {
 		.mcc = cpu_to_le16(alpha2[0] << 8 | alpha2[1]),
+		.source_id = (u8)src_id,
 	};
 	struct iwl_mcc_update_resp *mcc_resp, *resp_cp = NULL;
 	struct iwl_rx_packet *pkt;
@@ -610,8 +614,8 @@ iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2)
 
 	cmd.len[0] = sizeof(struct iwl_mcc_update_cmd);
 
-	IWL_DEBUG_LAR(mvm, "send MCC update to FW with '%c%c'\n",
-		      alpha2[0], alpha2[1]);
+	IWL_DEBUG_LAR(mvm, "send MCC update to FW with '%c%c' src = %d\n",
+		      alpha2[0], alpha2[1], src_id);
 
 	ret = iwl_mvm_send_cmd(mvm, &cmd);
 	if (ret)
@@ -629,18 +633,6 @@ iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2)
 	mcc_resp = (void *)pkt->data;
 	status = le32_to_cpu(mcc_resp->status);
 
-	if (status == MCC_RESP_INVALID) {
-		IWL_ERR(mvm,
-			"FW ERROR: MCC update with invalid parameter '%c%c'\n",
-			alpha2[0], alpha2[1]);
-		ret = -EINVAL;
-		goto exit;
-	} else if (status == MCC_RESP_NVM_DISABLED) {
-		ret = 0;
-		/* resp_cp will be NULL */
-		goto exit;
-	}
-
 	mcc = le16_to_cpu(mcc_resp->mcc);
 
 	/* W/A for a FW/NVM issue - returns 0x00 for the world domain */
@@ -670,10 +662,104 @@ exit:
 	return resp_cp;
 }
 
+#ifdef CONFIG_ACPI
+#define WRD_METHOD		"WRDD"
+#define WRDD_WIFI		(0x07)
+#define WRDD_WIGIG		(0x10)
+
+static u32 iwl_mvm_wrdd_get_mcc(struct iwl_mvm *mvm, union acpi_object *wrdd)
+{
+	union acpi_object *mcc_pkg, *domain_type, *mcc_value;
+	u32 i;
+
+	if (wrdd->type != ACPI_TYPE_PACKAGE ||
+	    wrdd->package.count < 2 ||
+	    wrdd->package.elements[0].type != ACPI_TYPE_INTEGER ||
+	    wrdd->package.elements[0].integer.value != 0) {
+		IWL_DEBUG_LAR(mvm, "Unsupported wrdd structure\n");
+		return 0;
+	}
+
+	for (i = 1 ; i < wrdd->package.count ; ++i) {
+		mcc_pkg = &wrdd->package.elements[i];
+
+		if (mcc_pkg->type != ACPI_TYPE_PACKAGE ||
+		    mcc_pkg->package.count < 2 ||
+		    mcc_pkg->package.elements[0].type != ACPI_TYPE_INTEGER ||
+		    mcc_pkg->package.elements[1].type != ACPI_TYPE_INTEGER) {
+			mcc_pkg = NULL;
+			continue;
+		}
+
+		domain_type = &mcc_pkg->package.elements[0];
+		if (domain_type->integer.value == WRDD_WIFI)
+			break;
+
+		mcc_pkg = NULL;
+	}
+
+	if (mcc_pkg) {
+		mcc_value = &mcc_pkg->package.elements[1];
+		return mcc_value->integer.value;
+	}
+
+	return 0;
+}
+
+static int iwl_mvm_get_bios_mcc(struct iwl_mvm *mvm, char *mcc)
+{
+	acpi_handle root_handle;
+	acpi_handle handle;
+	struct acpi_buffer wrdd = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_status status;
+	u32 mcc_val;
+	struct pci_dev *pdev = to_pci_dev(mvm->dev);
+
+	root_handle = ACPI_HANDLE(&pdev->dev);
+	if (!root_handle) {
+		IWL_DEBUG_LAR(mvm,
+			      "Could not retrieve root port ACPI handle\n");
+		return -ENOENT;
+	}
+
+	/* Get the method's handle */
+	status = acpi_get_handle(root_handle, (acpi_string)WRD_METHOD, &handle);
+	if (ACPI_FAILURE(status)) {
+		IWL_DEBUG_LAR(mvm, "WRD method not found\n");
+		return -ENOENT;
+	}
+
+	/* Call WRDD with no arguments */
+	status = acpi_evaluate_object(handle, NULL, NULL, &wrdd);
+	if (ACPI_FAILURE(status)) {
+		IWL_DEBUG_LAR(mvm, "WRDC invocation failed (0x%x)\n", status);
+		return -ENOENT;
+	}
+
+	mcc_val = iwl_mvm_wrdd_get_mcc(mvm, wrdd.pointer);
+	kfree(wrdd.pointer);
+	if (!mcc_val)
+		return -ENOENT;
+
+	mcc[0] = (mcc_val >> 8) & 0xff;
+	mcc[1] = mcc_val & 0xff;
+	mcc[2] = '\0';
+	return 0;
+}
+#else /* CONFIG_ACPI */
+static int iwl_mvm_get_bios_mcc(struct iwl_mvm *mvm, char *mcc)
+{
+	return -ENOENT;
+}
+#endif
+
 int iwl_mvm_init_mcc(struct iwl_mvm *mvm)
 {
 	bool tlv_lar;
 	bool nvm_lar;
+	int retval;
+	struct ieee80211_regdomain *regd;
+	char mcc[3];
 
 	if (mvm->cfg->device_family == IWL_DEVICE_FAMILY_8000) {
 		tlv_lar = mvm->fw->ucode_capa.capa[0] &
@@ -695,32 +781,33 @@ int iwl_mvm_init_mcc(struct iwl_mvm *mvm)
 	 */
 	if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {
 		/* This should only be called during vif up and hold RTNL */
-		const struct ieee80211_regdomain *r =
-				rtnl_dereference(mvm->hw->wiphy->regd);
-
-		if (r) {
-			struct iwl_mcc_update_resp *resp;
-
-			resp = iwl_mvm_update_mcc(mvm, r->alpha2);
-			if (IS_ERR_OR_NULL(resp))
-				return -EIO;
-
-			kfree(resp);
-		}
-
-		return 0;
+		return iwl_mvm_init_fw_regd(mvm);
 	}
 
 	/*
-	 * Driver regulatory hint for initial update - use the special
-	 * unknown-country "99" code. This will also clear the "custom reg"
-	 * flag and allow regdomain changes. It will happen after init since
-	 * RTNL is required.
+	 * Driver regulatory hint for initial update, this also informs the
+	 * firmware we support wifi location updates.
 	 * Disallow scans that might crash the FW while the LAR regdomain
 	 * is not set.
 	 */
 	mvm->lar_regdom_set = false;
-	return regulatory_hint(mvm->hw->wiphy, "99");
+
+	regd = iwl_mvm_get_current_regdomain(mvm);
+	if (IS_ERR_OR_NULL(regd))
+		return -EIO;
+
+	if (iwl_mvm_is_wifi_mcc_supported(mvm) &&
+	    !iwl_mvm_get_bios_mcc(mvm, mcc)) {
+		kfree(regd);
+		regd = iwl_mvm_get_regdomain(mvm->hw->wiphy, mcc,
+					     MCC_SOURCE_BIOS);
+		if (!IS_ERR_OR_NULL(regd))
+			return -EIO;
+	}
+
+	retval = regulatory_set_wiphy_regd(mvm->hw->wiphy, regd);
+	kfree(regd);
+	return retval;
 }
 
 int iwl_mvm_rx_chub_update_mcc(struct iwl_mvm *mvm,
@@ -729,19 +816,29 @@ int iwl_mvm_rx_chub_update_mcc(struct iwl_mvm *mvm,
 {
 	struct iwl_rx_packet *pkt = rxb_addr(rxb);
 	struct iwl_mcc_chub_notif *notif = (void *)pkt->data;
+	enum iwl_mcc_source src;
 	char mcc[3];
+	struct ieee80211_regdomain *regd;
+
+	lockdep_assert_held(&mvm->mutex);
 
 	if (WARN_ON_ONCE(!iwl_mvm_is_lar_supported(mvm)))
-		return -EOPNOTSUPP;
+		return 0;
 
 	mcc[0] = notif->mcc >> 8;
 	mcc[1] = notif->mcc & 0xff;
 	mcc[2] = '\0';
+	src = notif->source_id;
 
 	IWL_DEBUG_LAR(mvm,
-		      "RX: received chub update mcc command (mcc 0x%x '%s')\n",
-		      notif->mcc, mcc);
+		      "RX: received chub update mcc cmd (mcc '%s' src %d)\n",
+		      mcc, src);
+	regd = iwl_mvm_get_regdomain(mvm->hw->wiphy, mcc, src);
+	if (IS_ERR_OR_NULL(regd))
+		return 0;
+
+	regulatory_set_wiphy_regd(mvm->hw->wiphy, regd);
+	kfree(regd);
 
-	return regulatory_hint_force_policy(mvm->hw->wiphy, mcc,
-					    DRIVER_REG_HINT_OVERRIDE);
+	return 0;
 }
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/ops.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/ops.c
index c77e31d..100f1f1 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/ops.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/ops.c
@@ -160,13 +160,14 @@ static void iwl_mvm_nic_config(struct iwl_op_mode *op_mode)
 	struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
 	u8 radio_cfg_type, radio_cfg_step, radio_cfg_dash;
 	u32 reg_val = 0;
+	u32 phy_config = iwl_mvm_get_phy_config(mvm);
 
-	radio_cfg_type = (mvm->fw->phy_config & FW_PHY_CFG_RADIO_TYPE) >>
-			  FW_PHY_CFG_RADIO_TYPE_POS;
-	radio_cfg_step = (mvm->fw->phy_config & FW_PHY_CFG_RADIO_STEP) >>
-			  FW_PHY_CFG_RADIO_STEP_POS;
-	radio_cfg_dash = (mvm->fw->phy_config & FW_PHY_CFG_RADIO_DASH) >>
-			  FW_PHY_CFG_RADIO_DASH_POS;
+	radio_cfg_type = (phy_config & FW_PHY_CFG_RADIO_TYPE) >>
+			 FW_PHY_CFG_RADIO_TYPE_POS;
+	radio_cfg_step = (phy_config & FW_PHY_CFG_RADIO_STEP) >>
+			 FW_PHY_CFG_RADIO_STEP_POS;
+	radio_cfg_dash = (phy_config & FW_PHY_CFG_RADIO_DASH) >>
+			 FW_PHY_CFG_RADIO_DASH_POS;
 
 	/* SKU control */
 	reg_val |= CSR_HW_REV_STEP(mvm->trans->hw_rev) <<
@@ -249,7 +250,7 @@ static const struct iwl_rx_handlers iwl_mvm_rx_handlers[] = {
 		   iwl_mvm_rx_ant_coupling_notif, true),
 
 	RX_HANDLER(TIME_EVENT_NOTIFICATION, iwl_mvm_rx_time_event_notif, false),
-	RX_HANDLER(MCC_CHUB_UPDATE_CMD, iwl_mvm_rx_chub_update_mcc, false),
+	RX_HANDLER(MCC_CHUB_UPDATE_CMD, iwl_mvm_rx_chub_update_mcc, true),
 
 	RX_HANDLER(EOSP_NOTIFICATION, iwl_mvm_rx_eosp_notif, false),
 
@@ -416,6 +417,9 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	};
 	int err, scan_size;
 	u32 min_backoff;
+#ifdef CPTCFG_IWLMVM_TCM
+	int i;
+#endif
 
 	/*
 	 * We use IWL_MVM_STATION_COUNT to check the validity of the station
@@ -490,6 +494,8 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	INIT_WORK(&mvm->tcm.work, iwl_mvm_tcm_work);
 	mvm->tcm.ts = jiffies;
 	mvm->tcm.ll_ts = jiffies;
+	for (i = 0; i < NUM_MAC_INDEX_DRIVER; i++)
+		ewma_init(&mvm->tcm.data[i].uapsd_nonagg_detect.rate, 16, 16);
 #endif
 
 	/*
@@ -520,6 +526,8 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	trans_cfg.cmd_fifo = IWL_MVM_TX_FIFO_CMD;
 	trans_cfg.scd_set_active = true;
 
+	trans_cfg.sdio_adma_addr = fw->sdio_adma_addr;
+
 	snprintf(mvm->hw->wiphy->fw_version,
 		 sizeof(mvm->hw->wiphy->fw_version),
 		 "%s", fw->fw_version);
@@ -1094,7 +1102,8 @@ static void iwl_mvm_set_wowlan_data(struct iwl_mvm *mvm,
 out:
 	rcu_read_unlock();
 }
-static int iwl_mvm_enter_d0i3(struct iwl_op_mode *op_mode)
+
+int iwl_mvm_enter_d0i3(struct iwl_op_mode *op_mode)
 {
 	struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
 	u32 flags = CMD_ASYNC | CMD_HIGH_PRIO | CMD_SEND_IN_IDLE;
@@ -1110,6 +1119,7 @@ static int iwl_mvm_enter_d0i3(struct iwl_op_mode *op_mode)
 	};
 	struct iwl_d3_manager_config d3_cfg_cmd = {
 		.min_sleep_time = cpu_to_le32(1000),
+		.wakeup_flags = cpu_to_le32(IWL_WAKEUP_D3_CONFIG_FW_ERROR),
 	};
 
 	IWL_DEBUG_RPM(mvm, "MVM entering D0i3\n");
@@ -1209,7 +1219,7 @@ void iwl_mvm_d0i3_enable_tx(struct iwl_mvm *mvm, __le16 *qos_seq)
 
 	if (mvm->d0i3_offloading && qos_seq) {
 		/* update qos seq numbers if offloading was enabled */
-		mvm_ap_sta = (struct iwl_mvm_sta *)sta->drv_priv;
+		mvm_ap_sta = iwl_mvm_sta_from_mac80211(sta);
 		for (i = 0; i < IWL_MAX_TID_COUNT; i++) {
 			u16 seq = le16_to_cpu(qos_seq[i]);
 			/* firmware stores last-used one, we store next one */
@@ -1308,7 +1318,7 @@ out:
 	return ret;
 }
 
-static int iwl_mvm_exit_d0i3(struct iwl_op_mode *op_mode)
+int iwl_mvm_exit_d0i3(struct iwl_op_mode *op_mode)
 {
 	struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
index 1c0d4a4..540c36b 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
@@ -176,7 +176,7 @@ static void iwl_mvm_phy_ctxt_cmd_data(struct iwl_mvm *mvm,
 	cmd->rxchain_info |= cpu_to_le32(active_cnt <<
 					 PHY_RX_CHAIN_MIMO_CNT_POS);
 
-	cmd->txchain_info = cpu_to_le32(mvm->fw->valid_tx_ant);
+	cmd->txchain_info = cpu_to_le32(iwl_mvm_get_valid_tx_ant(mvm));
 }
 
 /*
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/power.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/power.c
index 506d772..764d081 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/power.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/power.c
@@ -367,12 +367,14 @@ static void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm,
 
 	cmd->flags |= cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK);
 
+#if 0
 	if (vif->bss_conf.beacon_rate &&
 	    (vif->bss_conf.beacon_rate->bitrate == 10 ||
 	     vif->bss_conf.beacon_rate->bitrate == 60)) {
 		cmd->flags |= cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK);
 		cmd->lprx_rssi_threshold = POWER_LPRX_RSSI_THRESHOLD;
 	}
+#endif
 
 	/* Check if radar detection is required on current channel */
 	radar_detect = iwl_mvm_power_is_radar(vif);
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.c
index cf25e6b..ce14d6a 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.c
@@ -42,25 +42,12 @@
 
 #define RS_NAME "iwl-mvm-rs"
 
-#define NUM_TRY_BEFORE_ANT_TOGGLE       1
-#define RS_LEGACY_RETRIES_PER_RATE      1
-#define RS_HT_VHT_RETRIES_PER_RATE      2
-#define RS_HT_VHT_RETRIES_PER_RATE_TW   1
-#define RS_INITIAL_MIMO_NUM_RATES       3
-#define RS_INITIAL_SISO_NUM_RATES       3
-#define RS_INITIAL_LEGACY_NUM_RATES     LINK_QUAL_MAX_RETRY_NUM
-#define RS_SECONDARY_LEGACY_NUM_RATES   LINK_QUAL_MAX_RETRY_NUM
-#define RS_SECONDARY_SISO_NUM_RATES     3
-#define RS_SECONDARY_SISO_RETRIES       1
-
 #define IWL_RATE_MAX_WINDOW		62	/* # tx in history window */
-#define IWL_RATE_MIN_FAILURE_TH		3	/* min failures to calc tpt */
-#define IWL_RATE_MIN_SUCCESS_TH		8	/* min successes to calc tpt */
 
-/* max allowed rate miss before sync LQ cmd */
-#define IWL_MISSED_RATE_MAX		15
-#define RS_STAY_IN_COLUMN_TIMEOUT       (5*HZ)
-#define RS_IDLE_TIMEOUT                 (5*HZ)
+/* Calculations of success ratio are done in fixed point where 12800 is 100%.
+ * Use this macro when dealing with thresholds consts set as a percentage
+ */
+#define RS_PERCENT(x) (128 * x)
 
 static u8 rs_ht_to_legacy[] = {
 	[IWL_RATE_MCS_0_INDEX] = IWL_RATE_6M_INDEX,
@@ -173,7 +160,7 @@ static bool rs_mimo_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 	if (sta->smps_mode == IEEE80211_SMPS_STATIC)
 		return false;
 
-	if (num_of_ant(mvm->fw->valid_tx_ant) < 2)
+	if (num_of_ant(iwl_mvm_get_valid_tx_ant(mvm)) < 2)
 		return false;
 
 	if (!iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta))
@@ -613,7 +600,8 @@ static s32 get_expected_tpt(struct iwl_scale_tbl_info *tbl, int rs_index)
  * at this rate.  window->data contains the bitmask of successful
  * packets.
  */
-static int _rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,
+static int _rs_collect_tx_data(struct iwl_mvm *mvm,
+			       struct iwl_scale_tbl_info *tbl,
 			       int scale_index, int attempts, int successes,
 			       struct iwl_rate_scale_data *window)
 {
@@ -668,8 +656,8 @@ static int _rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,
 	fail_count = window->counter - window->success_counter;
 
 	/* Calculate average throughput, if we have enough history. */
-	if ((fail_count >= IWL_RATE_MIN_FAILURE_TH) ||
-	    (window->success_counter >= IWL_RATE_MIN_SUCCESS_TH))
+	if ((fail_count >= IWL_MVM_RS_RATE_MIN_FAILURE_TH) ||
+	    (window->success_counter >= IWL_MVM_RS_RATE_MIN_SUCCESS_TH))
 		window->average_tpt = (window->success_ratio * tpt + 64) / 128;
 	else
 		window->average_tpt = IWL_INVALID_VALUE;
@@ -677,7 +665,8 @@ static int _rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,
 	return 0;
 }
 
-static int rs_collect_tx_data(struct iwl_lq_sta *lq_sta,
+static int rs_collect_tx_data(struct iwl_mvm *mvm,
+			      struct iwl_lq_sta *lq_sta,
 			      struct iwl_scale_tbl_info *tbl,
 			      int scale_index, int attempts, int successes,
 			      u8 reduced_txp)
@@ -698,7 +687,7 @@ static int rs_collect_tx_data(struct iwl_lq_sta *lq_sta,
 	/* Select window for current tx bit rate */
 	window = &(tbl->win[scale_index]);
 
-	ret = _rs_collect_tx_data(tbl, scale_index, attempts, successes,
+	ret = _rs_collect_tx_data(mvm, tbl, scale_index, attempts, successes,
 				  window);
 	if (ret)
 		return ret;
@@ -707,7 +696,7 @@ static int rs_collect_tx_data(struct iwl_lq_sta *lq_sta,
 		return -EINVAL;
 
 	window = &tbl->tpc_win[reduced_txp];
-	return _rs_collect_tx_data(tbl, scale_index, attempts, successes,
+	return _rs_collect_tx_data(mvm, tbl, scale_index, attempts, successes,
 				   window);
 }
 
@@ -1004,7 +993,7 @@ static void rs_get_lower_rate_down_column(struct iwl_lq_sta *lq_sta,
 	}
 
 	if (num_of_ant(rate->ant) > 1)
-		rate->ant = first_antenna(mvm->fw->valid_tx_ant);
+		rate->ant = first_antenna(iwl_mvm_get_valid_tx_ant(mvm));
 
 	/* Relevant in both switching to SISO or Legacy */
 	rate->sgi = false;
@@ -1125,7 +1114,8 @@ void iwl_mvm_rs_tx_status(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 	}
 
 	if (time_after(jiffies,
-		       (unsigned long)(lq_sta->last_tx + RS_IDLE_TIMEOUT))) {
+		       (unsigned long)(lq_sta->last_tx +
+				       (IWL_MVM_RS_IDLE_TIMEOUT * HZ)))) {
 		int t;
 
 		IWL_DEBUG_RATE(mvm, "Tx idle for too long. reinit rs\n");
@@ -1158,7 +1148,7 @@ void iwl_mvm_rs_tx_status(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 		 * ... driver.
 		 */
 		lq_sta->missed_rate_counter++;
-		if (lq_sta->missed_rate_counter > IWL_MISSED_RATE_MAX) {
+		if (lq_sta->missed_rate_counter > IWL_MVM_RS_MISSED_RATE_MAX) {
 			lq_sta->missed_rate_counter = 0;
 			IWL_DEBUG_RATE(mvm,
 				       "Too many rates mismatch. Send sync LQ. rs_state %d\n",
@@ -1213,7 +1203,7 @@ void iwl_mvm_rs_tx_status(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 
 		ucode_rate = le32_to_cpu(table->rs_table[0]);
 		rs_rate_from_ucode_rate(ucode_rate, info->band, &rate);
-		rs_collect_tx_data(lq_sta, curr_tbl, rate.index,
+		rs_collect_tx_data(mvm, lq_sta, curr_tbl, rate.index,
 				   info->status.ampdu_len,
 				   info->status.ampdu_ack_len,
 				   reduced_txp);
@@ -1249,7 +1239,7 @@ void iwl_mvm_rs_tx_status(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 			else
 				continue;
 
-			rs_collect_tx_data(lq_sta, tmp_tbl, rate.index, 1,
+			rs_collect_tx_data(mvm, lq_sta, tmp_tbl, rate.index, 1,
 					   i < retries ? 0 : legacy_success,
 					   reduced_txp);
 		}
@@ -1303,13 +1293,13 @@ static void rs_set_stay_in_table(struct iwl_mvm *mvm, u8 is_legacy,
 	IWL_DEBUG_RATE(mvm, "Moving to RS_STATE_STAY_IN_COLUMN\n");
 	lq_sta->rs_state = RS_STATE_STAY_IN_COLUMN;
 	if (is_legacy) {
-		lq_sta->table_count_limit = IWL_LEGACY_TABLE_COUNT;
-		lq_sta->max_failure_limit = IWL_LEGACY_FAILURE_LIMIT;
-		lq_sta->max_success_limit = IWL_LEGACY_SUCCESS_LIMIT;
+		lq_sta->table_count_limit = IWL_MVM_RS_LEGACY_TABLE_COUNT;
+		lq_sta->max_failure_limit = IWL_MVM_RS_LEGACY_FAILURE_LIMIT;
+		lq_sta->max_success_limit = IWL_MVM_RS_LEGACY_SUCCESS_LIMIT;
 	} else {
-		lq_sta->table_count_limit = IWL_NONE_LEGACY_TABLE_COUNT;
-		lq_sta->max_failure_limit = IWL_NONE_LEGACY_FAILURE_LIMIT;
-		lq_sta->max_success_limit = IWL_NONE_LEGACY_SUCCESS_LIMIT;
+		lq_sta->table_count_limit = IWL_MVM_RS_NON_LEGACY_TABLE_COUNT;
+		lq_sta->max_failure_limit = IWL_MVM_RS_NON_LEGACY_FAILURE_LIMIT;
+		lq_sta->max_success_limit = IWL_MVM_RS_NON_LEGACY_SUCCESS_LIMIT;
 	}
 	lq_sta->table_count = 0;
 	lq_sta->total_failed = 0;
@@ -1318,6 +1308,13 @@ static void rs_set_stay_in_table(struct iwl_mvm *mvm, u8 is_legacy,
 	lq_sta->visited_columns = 0;
 }
 
+static inline int rs_get_max_rate_from_mask(unsigned long rate_mask)
+{
+	if (rate_mask)
+		return find_last_bit(&rate_mask, BITS_PER_LONG);
+	return IWL_RATE_INVALID;
+}
+
 static int rs_get_max_allowed_rate(struct iwl_lq_sta *lq_sta,
 				   const struct rs_tx_column *column)
 {
@@ -1420,7 +1417,7 @@ static s32 rs_get_best_rate(struct iwl_mvm *mvm,
 	u32 target_tpt;
 	int rate_idx;
 
-	if (success_ratio > RS_SR_NO_DECREASE) {
+	if (success_ratio > IWL_MVM_RS_SR_NO_DECREASE) {
 		target_tpt = 100 * expected_current_tpt;
 		IWL_DEBUG_RATE(mvm,
 			       "SR %d high. Find rate exceeding EXPECTED_CURRENT %d\n",
@@ -1488,7 +1485,7 @@ static void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search)
 			flush_interval_passed =
 				time_after(jiffies,
 					   (unsigned long)(lq_sta->flush_timer +
-						RS_STAY_IN_COLUMN_TIMEOUT));
+							   (IWL_MVM_RS_STAY_IN_COLUMN_TIMEOUT * HZ)));
 
 		/*
 		 * Check if we should allow search for new modulation mode.
@@ -1567,7 +1564,7 @@ static enum rs_column rs_get_next_column(struct iwl_mvm *mvm,
 	const struct rs_tx_column *curr_col = &rs_tx_columns[tbl->column];
 	const struct rs_tx_column *next_col;
 	allow_column_func_t allow_func;
-	u8 valid_ants = mvm->fw->valid_tx_ant;
+	u8 valid_ants = iwl_mvm_get_valid_tx_ant(mvm);
 	const u16 *expected_tpt_tbl;
 	u16 tpt, max_expected_tpt;
 
@@ -1613,8 +1610,12 @@ static enum rs_column rs_get_next_column(struct iwl_mvm *mvm,
 			continue;
 
 		max_rate = rs_get_max_allowed_rate(lq_sta, next_col);
-		if (WARN_ON_ONCE(max_rate == IWL_RATE_INVALID))
+		if (max_rate == IWL_RATE_INVALID) {
+			IWL_DEBUG_RATE(mvm,
+				       "Skip column %d: no rate is allowed in this column\n",
+				       next_col_id);
 			continue;
+		}
 
 		max_expected_tpt = expected_tpt_tbl[max_rate];
 		if (tpt >= max_expected_tpt) {
@@ -1724,7 +1725,8 @@ static enum rs_action rs_get_rate_action(struct iwl_mvm *mvm,
 {
 	enum rs_action action = RS_ACTION_STAY;
 
-	if ((sr <= RS_SR_FORCE_DECREASE) || (current_tpt == 0)) {
+	if ((sr <= RS_PERCENT(IWL_MVM_RS_SR_FORCE_DECREASE)) ||
+	    (current_tpt == 0)) {
 		IWL_DEBUG_RATE(mvm,
 			       "Decrease rate because of low SR\n");
 		return RS_ACTION_DOWNSCALE;
@@ -1783,7 +1785,7 @@ static enum rs_action rs_get_rate_action(struct iwl_mvm *mvm,
 
 out:
 	if ((action == RS_ACTION_DOWNSCALE) && (low != IWL_RATE_INVALID)) {
-		if (sr >= RS_SR_NO_DECREASE) {
+		if (sr >= RS_PERCENT(IWL_MVM_RS_SR_NO_DECREASE)) {
 			IWL_DEBUG_RATE(mvm,
 				       "SR is above NO DECREASE. Avoid downscale\n");
 			action = RS_ACTION_STAY;
@@ -1825,11 +1827,11 @@ static bool rs_stbc_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 static void rs_get_adjacent_txp(struct iwl_mvm *mvm, int index,
 				int *weaker, int *stronger)
 {
-	*weaker = index + TPC_TX_POWER_STEP;
+	*weaker = index + IWL_MVM_RS_TPC_TX_POWER_STEP;
 	if (*weaker > TPC_MAX_REDUCTION)
 		*weaker = TPC_INVALID;
 
-	*stronger = index - TPC_TX_POWER_STEP;
+	*stronger = index - IWL_MVM_RS_TPC_TX_POWER_STEP;
 	if (*stronger < 0)
 		*stronger = TPC_INVALID;
 }
@@ -1885,7 +1887,8 @@ static enum tpc_action rs_get_tpc_action(struct iwl_mvm *mvm,
 	}
 
 	/* Too many failures, increase txp */
-	if (sr <= TPC_SR_FORCE_INCREASE || current_tpt == 0) {
+	if (sr <= RS_PERCENT(IWL_MVM_RS_TPC_SR_FORCE_INCREASE) ||
+	    current_tpt == 0) {
 		IWL_DEBUG_RATE(mvm, "increase txp because of weak SR\n");
 		return TPC_ACTION_NO_RESTIRCTION;
 	}
@@ -1908,7 +1911,8 @@ static enum tpc_action rs_get_tpc_action(struct iwl_mvm *mvm,
 	}
 
 	/* next, increase if needed */
-	if (sr < TPC_SR_NO_INCREASE && strong != TPC_INVALID) {
+	if (sr < RS_PERCENT(IWL_MVM_RS_TPC_SR_NO_INCREASE) &&
+	    strong != TPC_INVALID) {
 		if (weak_tpt == IWL_INVALID_VALUE &&
 		    strong_tpt != IWL_INVALID_VALUE &&
 		    current_tpt < strong_tpt) {
@@ -1935,7 +1939,7 @@ static bool rs_tpc_perform(struct iwl_mvm *mvm,
 			   struct iwl_lq_sta *lq_sta,
 			   struct iwl_scale_tbl_info *tbl)
 {
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 	struct ieee80211_vif *vif = mvm_sta->vif;
 	struct ieee80211_chanctx_conf *chanctx_conf;
 	enum ieee80211_band band;
@@ -2044,7 +2048,7 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
 	u16 high_low;
 	s32 sr;
 	u8 prev_agg = lq_sta->is_agg;
-	struct iwl_mvm_sta *sta_priv = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *sta_priv = iwl_mvm_sta_from_mac80211(sta);
 	struct iwl_mvm_tid_data *tid_data;
 	struct rs_rate *rate;
 
@@ -2106,8 +2110,8 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
 	 * in current association (use new rate found above).
 	 */
 	fail_count = window->counter - window->success_counter;
-	if ((fail_count < IWL_RATE_MIN_FAILURE_TH) &&
-	    (window->success_counter < IWL_RATE_MIN_SUCCESS_TH)) {
+	if ((fail_count < IWL_MVM_RS_RATE_MIN_FAILURE_TH) &&
+	    (window->success_counter < IWL_MVM_RS_RATE_MIN_SUCCESS_TH)) {
 		IWL_DEBUG_RATE(mvm,
 			       "(%s: %d): Test Window: succ %d total %d\n",
 			       rs_pretty_lq_type(rate->type),
@@ -2385,7 +2389,7 @@ static void rs_get_initial_rate(struct iwl_mvm *mvm,
 	int i, nentries;
 	s8 best_rssi = S8_MIN;
 	u8 best_ant = ANT_NONE;
-	u8 valid_tx_ant = mvm->fw->valid_tx_ant;
+	u8 valid_tx_ant = iwl_mvm_get_valid_tx_ant(mvm);
 	const struct rs_init_rate_info *initial_rates;
 
 	for (i = 0; i < ARRAY_SIZE(lq_sta->pers.chain_signal); i++) {
@@ -2530,7 +2534,7 @@ static void rs_get_rate(void *mvm_r, struct ieee80211_sta *sta, void *mvm_sta,
 static void *rs_alloc_sta(void *mvm_rate, struct ieee80211_sta *sta,
 			  gfp_t gfp)
 {
-	struct iwl_mvm_sta *sta_priv = (struct iwl_mvm_sta *)sta->drv_priv;
+	struct iwl_mvm_sta *sta_priv = iwl_mvm_sta_from_mac80211(sta);
 	struct iwl_op_mode *op_mode = (struct iwl_op_mode *)mvm_rate;
 	struct iwl_mvm *mvm  = IWL_OP_MODE_GET_MVM(op_mode);
 	struct iwl_lq_sta *lq_sta = &sta_priv->lq_sta;
@@ -2683,14 +2687,11 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 	struct ieee80211_hw *hw = mvm->hw;
 	struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;
 	struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
-	struct iwl_mvm_sta *sta_priv;
-	struct iwl_lq_sta *lq_sta;
+	struct iwl_mvm_sta *sta_priv = iwl_mvm_sta_from_mac80211(sta);
+	struct iwl_lq_sta *lq_sta = &sta_priv->lq_sta;
 	struct ieee80211_supported_band *sband;
 	unsigned long supp; /* must be unsigned long for for_each_set_bit */
 
-	sta_priv = (struct iwl_mvm_sta *)sta->drv_priv;
-	lq_sta = &sta_priv->lq_sta;
-
 	/* clear all non-persistent lq data */
 	memset(lq_sta, 0, offsetof(typeof(*lq_sta), pers));
 
@@ -2712,7 +2713,7 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 	 * previous packets? Need to have IEEE 802.1X auth succeed immediately
 	 * after assoc.. */
 
-	lq_sta->missed_rate_counter = IWL_MISSED_RATE_MAX;
+	lq_sta->missed_rate_counter = IWL_MVM_RS_MISSED_RATE_MAX;
 	lq_sta->band = sband->band;
 	/*
 	 * active legacy rates as per supported rates bitmap
@@ -2745,7 +2746,7 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 			lq_sta->ldpc = true;
 
 		if (mvm->cfg->ht_params->stbc &&
-		    (num_of_ant(mvm->fw->valid_tx_ant) > 1) &&
+		    (num_of_ant(iwl_mvm_get_valid_tx_ant(mvm)) > 1) &&
 		    (ht_cap->cap & IEEE80211_HT_CAP_RX_STBC))
 			lq_sta->stbc = true;
 	} else {
@@ -2757,20 +2758,20 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 			lq_sta->ldpc = true;
 
 		if (mvm->cfg->ht_params->stbc &&
-		    (num_of_ant(mvm->fw->valid_tx_ant) > 1) &&
+		    (num_of_ant(iwl_mvm_get_valid_tx_ant(mvm)) > 1) &&
 		    (vht_cap->cap & IEEE80211_VHT_CAP_RXSTBC_MASK))
 			lq_sta->stbc = true;
 	}
 
-	if (IWL_MVM_RS_DISABLE_MIMO)
+	if (IWL_MVM_RS_DISABLE_P2P_MIMO && sta_priv->vif->p2p)
 		lq_sta->active_mimo2_rate = 0;
 
-	lq_sta->max_legacy_rate_idx = find_last_bit(&lq_sta->active_legacy_rate,
-						    BITS_PER_LONG);
-	lq_sta->max_siso_rate_idx = find_last_bit(&lq_sta->active_siso_rate,
-						  BITS_PER_LONG);
-	lq_sta->max_mimo2_rate_idx = find_last_bit(&lq_sta->active_mimo2_rate,
-						   BITS_PER_LONG);
+	lq_sta->max_legacy_rate_idx =
+		rs_get_max_rate_from_mask(lq_sta->active_legacy_rate);
+	lq_sta->max_siso_rate_idx =
+		rs_get_max_rate_from_mask(lq_sta->active_siso_rate);
+	lq_sta->max_mimo2_rate_idx =
+		rs_get_max_rate_from_mask(lq_sta->active_mimo2_rate);
 
 	IWL_DEBUG_RATE(mvm,
 		       "RATE MASK: LEGACY=%lX SISO=%lX MIMO2=%lX VHT=%d LDPC=%d STBC%d\n",
@@ -2785,7 +2786,7 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 
 	/* These values will be overridden later */
 	lq_sta->lq.single_stream_ant_msk =
-		first_antenna(mvm->fw->valid_tx_ant);
+		first_antenna(iwl_mvm_get_valid_tx_ant(mvm));
 	lq_sta->lq.dual_stream_ant_msk = ANT_AB;
 
 	/* as default allow aggregation for all tids */
@@ -2913,18 +2914,18 @@ static void rs_build_rates_table(struct iwl_mvm *mvm,
 
 	memcpy(&rate, initial_rate, sizeof(rate));
 
-	valid_tx_ant = mvm->fw->valid_tx_ant;
+	valid_tx_ant = iwl_mvm_get_valid_tx_ant(mvm);
 	rate.stbc = rs_stbc_allow(mvm, sta, lq_sta);
 
 	if (is_siso(&rate)) {
-		num_rates = RS_INITIAL_SISO_NUM_RATES;
-		num_retries = RS_HT_VHT_RETRIES_PER_RATE;
+		num_rates = IWL_MVM_RS_INITIAL_SISO_NUM_RATES;
+		num_retries = IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE;
 	} else if (is_mimo(&rate)) {
-		num_rates = RS_INITIAL_MIMO_NUM_RATES;
-		num_retries = RS_HT_VHT_RETRIES_PER_RATE;
+		num_rates = IWL_MVM_RS_INITIAL_MIMO_NUM_RATES;
+		num_retries = IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE;
 	} else {
-		num_rates = RS_INITIAL_LEGACY_NUM_RATES;
-		num_retries = RS_LEGACY_RETRIES_PER_RATE;
+		num_rates = IWL_MVM_RS_INITIAL_LEGACY_NUM_RATES;
+		num_retries = IWL_MVM_RS_LEGACY_RETRIES_PER_RATE;
 		toggle_ant = true;
 	}
 
@@ -2935,12 +2936,12 @@ static void rs_build_rates_table(struct iwl_mvm *mvm,
 	rs_get_lower_rate_down_column(lq_sta, &rate);
 
 	if (is_siso(&rate)) {
-		num_rates = RS_SECONDARY_SISO_NUM_RATES;
-		num_retries = RS_SECONDARY_SISO_RETRIES;
+		num_rates = IWL_MVM_RS_SECONDARY_SISO_NUM_RATES;
+		num_retries = IWL_MVM_RS_SECONDARY_SISO_RETRIES;
 		lq_cmd->mimo_delim = index;
 	} else if (is_legacy(&rate)) {
-		num_rates = RS_SECONDARY_LEGACY_NUM_RATES;
-		num_retries = RS_LEGACY_RETRIES_PER_RATE;
+		num_rates = IWL_MVM_RS_SECONDARY_LEGACY_NUM_RATES;
+		num_retries = IWL_MVM_RS_LEGACY_RETRIES_PER_RATE;
 	} else {
 		WARN_ON_ONCE(1);
 	}
@@ -2953,8 +2954,8 @@ static void rs_build_rates_table(struct iwl_mvm *mvm,
 
 	rs_get_lower_rate_down_column(lq_sta, &rate);
 
-	num_rates = RS_SECONDARY_LEGACY_NUM_RATES;
-	num_retries = RS_LEGACY_RETRIES_PER_RATE;
+	num_rates = IWL_MVM_RS_SECONDARY_LEGACY_NUM_RATES;
+	num_retries = IWL_MVM_RS_LEGACY_RETRIES_PER_RATE;
 
 	rs_fill_rates_for_column(mvm, lq_sta, &rate, lq_cmd->rs_table, &index,
 				 num_rates, num_retries, valid_tx_ant,
@@ -2971,9 +2972,9 @@ static void rs_fill_lq_cmd(struct iwl_mvm *mvm,
 	struct iwl_mvm_sta *mvmsta;
 	struct iwl_mvm_vif *mvmvif;
 
-	lq_cmd->agg_disable_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;
+	lq_cmd->agg_disable_start_th = IWL_MVM_RS_AGG_DISABLE_START;
 	lq_cmd->agg_time_limit =
-		cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);
+		cpu_to_le16(IWL_MVM_RS_AGG_TIME_LIMIT);
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	if (lq_sta->pers.dbg_fixed_rate) {
@@ -3167,9 +3168,9 @@ static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file,
 	desc += sprintf(buff+desc, "fixed rate 0x%X\n",
 			lq_sta->pers.dbg_fixed_rate);
 	desc += sprintf(buff+desc, "valid_tx_ant %s%s%s\n",
-	    (mvm->fw->valid_tx_ant & ANT_A) ? "ANT_A," : "",
-	    (mvm->fw->valid_tx_ant & ANT_B) ? "ANT_B," : "",
-	    (mvm->fw->valid_tx_ant & ANT_C) ? "ANT_C" : "");
+	    (iwl_mvm_get_valid_tx_ant(mvm) & ANT_A) ? "ANT_A," : "",
+	    (iwl_mvm_get_valid_tx_ant(mvm) & ANT_B) ? "ANT_B," : "",
+	    (iwl_mvm_get_valid_tx_ant(mvm) & ANT_C) ? "ANT_C" : "");
 	desc += sprintf(buff+desc, "lq type %s\n",
 			(is_legacy(rate)) ? "legacy" :
 			is_vht(rate) ? "VHT" : "HT");
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.h
index fdd0da5..892a094 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rs.h
@@ -137,42 +137,10 @@ enum {
 
 #define IWL_INVALID_VALUE    -1
 
-#define IWL_MIN_RSSI_VAL                 -100
-#define IWL_MAX_RSSI_VAL                    0
-
-/* These values specify how many Tx frame attempts before
- * searching for a new modulation mode */
-#define IWL_LEGACY_FAILURE_LIMIT	160
-#define IWL_LEGACY_SUCCESS_LIMIT	480
-#define IWL_LEGACY_TABLE_COUNT		160
-
-#define IWL_NONE_LEGACY_FAILURE_LIMIT	400
-#define IWL_NONE_LEGACY_SUCCESS_LIMIT	4500
-#define IWL_NONE_LEGACY_TABLE_COUNT	1500
-
-/* Success ratio (ACKed / attempted tx frames) values (perfect is 128 * 100) */
-#define IWL_RS_GOOD_RATIO		12800	/* 100% */
-#define IWL_RATE_SCALE_SWITCH		10880	/*  85% */
-#define IWL_RATE_HIGH_TH		10880	/*  85% */
-#define IWL_RATE_INCREASE_TH		6400	/*  50% */
-#define RS_SR_FORCE_DECREASE		1920	/*  15% */
-#define RS_SR_NO_DECREASE		10880	/*  85% */
-
-#define TPC_SR_FORCE_INCREASE		9600	/* 75% */
-#define TPC_SR_NO_INCREASE		10880	/* 85% */
-#define TPC_TX_POWER_STEP		3
 #define TPC_MAX_REDUCTION		15
 #define TPC_NO_REDUCTION		0
 #define TPC_INVALID			0xff
 
-#define LINK_QUAL_AGG_TIME_LIMIT_DEF	(4000) /* 4 milliseconds */
-#define LINK_QUAL_AGG_TIME_LIMIT_MAX	(8000)
-#define LINK_QUAL_AGG_TIME_LIMIT_MIN	(100)
-
-#define LINK_QUAL_AGG_DISABLE_START_DEF	(3)
-#define LINK_QUAL_AGG_DISABLE_START_MAX	(255)
-#define LINK_QUAL_AGG_DISABLE_START_MIN	(0)
-
 #define LINK_QUAL_AGG_FRAME_LIMIT_DEF	(63)
 #define LINK_QUAL_AGG_FRAME_LIMIT_MAX	(63)
 #define LINK_QUAL_AGG_FRAME_LIMIT_MIN	(0)
@@ -181,14 +149,7 @@ enum {
 
 /* load per tid defines for A-MPDU activation */
 #define IWL_AGG_TPT_THREHOLD	0
-#define IWL_AGG_LOAD_THRESHOLD	10
 #define IWL_AGG_ALL_TID		0xff
-#define TID_QUEUE_CELL_SPACING	50	/*mS */
-#define TID_QUEUE_MAX_SIZE	20
-#define TID_ROUND_VALUE		5	/* mS */
-
-#define TID_MAX_TIME_DIFF ((TID_QUEUE_MAX_SIZE - 1) * TID_QUEUE_CELL_SPACING)
-#define TIME_WRAP_AROUND(x, y) (((y) > (x)) ? (y) - (x) : (0-(x)) + (y))
 
 enum iwl_table_type {
 	LQ_NONE,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rx.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rx.c
index e7fe33f..d742867 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rx.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/rx.c
@@ -238,6 +238,73 @@ static u32 iwl_mvm_set_mac80211_rx_flag(struct iwl_mvm *mvm,
 	return 0;
 }
 
+#ifdef CPTCFG_IWLMVM_TCM
+static void iwl_mvm_rx_handle_tcm(struct iwl_mvm *mvm,
+				  struct ieee80211_sta *sta,
+				  struct ieee80211_hdr *hdr, u32 len,
+				  struct iwl_rx_phy_info *phy_info,
+				  u32 rate_n_flags)
+{
+	struct iwl_mvm_sta *mvmsta;
+	struct iwl_mvm_tcm_mac *mdata;
+	struct iwl_mvm_vif *mvmvif;
+	int mac;
+	int ac = IEEE80211_AC_BE; /* treat non-QoS as BE */
+	/* expected throughput in 500kbps, single stream, 20 MHz */
+	static const u16 thresh_tpt[] = {
+		3, 6, 10, 14, 20, 26, 30, 32, 40, 45,
+	};
+	u16 thr;
+
+	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		int tid = *ieee80211_get_qos_ctl(hdr) &
+				IEEE80211_QOS_CTL_TID_MASK;
+
+		ac = tid_to_mac80211_ac[tid];
+	}
+
+	mvmsta = iwl_mvm_sta_from_mac80211(sta);
+	mac = mvmsta->mac_id_n_color & FW_CTXT_ID_MSK;
+
+	if (time_after(jiffies, mvm->tcm.ts + MVM_TCM_PERIOD))
+		iwl_mvm_recalc_tcm(mvm);
+	mdata = &mvm->tcm.data[mac];
+	mdata->rx.pkts[ac]++;
+	mdata->rx.airtime[ac] +=
+		le16_to_cpu(phy_info->frame_time);
+	mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);
+
+	if (!(rate_n_flags & (RATE_MCS_HT_POS | RATE_MCS_VHT_POS)))
+		return;
+
+	if (mdata->opened_rx_ba_sessions ||
+	    mdata->uapsd_nonagg_detect.detected ||
+	    !(mvmsta->vif->driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD) ||
+	    mvmsta->sta_id != mvmvif->ap_sta_id)
+		return;
+
+	if (rate_n_flags & RATE_MCS_HT_POS) {
+		thr = thresh_tpt[rate_n_flags & RATE_HT_MCS_RATE_CODE_MSK];
+		thr *= 1 + ((rate_n_flags & RATE_HT_MCS_NSS_MSK) >>
+					RATE_HT_MCS_NSS_POS);
+	} else {
+		if (WARN_ON(rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK) >
+				ARRAY_SIZE(thresh_tpt))
+			return;
+		thr = thresh_tpt[rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK];
+		thr *= 1 + ((rate_n_flags & RATE_VHT_MCS_NSS_MSK) >>
+					RATE_VHT_MCS_NSS_POS);
+	}
+
+	thr *= 1 + ((rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK) >>
+				RATE_MCS_CHAN_WIDTH_POS);
+
+	mdata->uapsd_nonagg_detect.rx_bytes += len;
+	mdata->uapsd_nonagg_detect.rx_pkts++;
+	ewma_add(&mdata->uapsd_nonagg_detect.rate, thr);
+}
+#endif
+
 /*
  * iwl_mvm_rx_rx_mpdu - REPLY_RX_MPDU_CMD handler
  *
@@ -349,34 +416,11 @@ int iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
 	}
 
 #ifdef CPTCFG_IWLMVM_TCM
-	if (!mvm->tcm.paused && len >= sizeof(*hdr) &&
+	if (sta && !mvm->tcm.paused && len >= sizeof(*hdr) &&
 	    !is_multicast_ether_addr(hdr->addr1) &&
-	    ieee80211_is_data(hdr->frame_control)) {
-		int ac = IEEE80211_AC_BE; /* treat non-QoS as BE */
-
-		if (ieee80211_is_data_qos(hdr->frame_control)) {
-			int tid = *ieee80211_get_qos_ctl(hdr) &
-					IEEE80211_QOS_CTL_TID_MASK;
-
-			ac = tid_to_mac80211_ac[tid];
-		}
-
-		if (sta) {
-			struct iwl_mvm_sta *mvmsta;
-			struct iwl_mvm_tcm_mac *mdata;
-			int mac;
-
-			mvmsta = iwl_mvm_sta_from_mac80211(sta);
-			mac = mvmsta->mac_id_n_color & FW_CTXT_ID_MSK;
-
-			if (time_after(jiffies, mvm->tcm.ts + MVM_TCM_PERIOD))
-				iwl_mvm_recalc_tcm(mvm);
-			mdata = &mvm->tcm.data[mac];
-			mdata->rx.pkts[ac]++;
-			mdata->rx.airtime[ac] +=
-				le16_to_cpu(phy_info->frame_time);
-		}
-	}
+	    ieee80211_is_data(hdr->frame_control))
+		iwl_mvm_rx_handle_tcm(mvm, sta, hdr, len, phy_info,
+				      rate_n_flags);
 #endif
 	rcu_read_unlock();
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/scan.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/scan.c
index 65ef884..bc315ee 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/scan.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/scan.c
@@ -75,6 +75,8 @@
 
 #define IWL_PLCP_QUIET_THRESH 1
 #define IWL_ACTIVE_QUIET_TIME 10
+#define IWL_DENSE_EBS_SCAN_RATIO 5
+#define IWL_SPARSE_EBS_SCAN_RATIO 1
 
 struct iwl_mvm_scan_params {
 	u32 max_out_time;
@@ -100,7 +102,7 @@ static u8 iwl_mvm_scan_rx_ant(struct iwl_mvm *mvm)
 {
 	if (mvm->scan_rx_ant != ANT_NONE)
 		return mvm->scan_rx_ant;
-	return mvm->fw->valid_rx_ant;
+	return iwl_mvm_get_valid_rx_ant(mvm);
 }
 
 static inline __le16 iwl_mvm_scan_rx_chain(struct iwl_mvm *mvm)
@@ -131,7 +133,7 @@ iwl_mvm_scan_rate_n_flags(struct iwl_mvm *mvm, enum ieee80211_band band,
 	u32 tx_ant;
 
 	mvm->scan_last_antenna_idx =
-		iwl_mvm_next_antenna(mvm, mvm->fw->valid_tx_ant,
+		iwl_mvm_next_antenna(mvm, iwl_mvm_get_valid_tx_ant(mvm),
 				     mvm->scan_last_antenna_idx);
 	tx_ant = BIT(mvm->scan_last_antenna_idx) << RATE_MCS_ANT_POS;
 
@@ -285,11 +287,11 @@ static void iwl_mvm_scan_condition_iterator(void *data, u8 *mac,
 					    struct ieee80211_vif *vif)
 {
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
-	bool *global_bound = data;
+	int *global_cnt = data;
 
 	if (vif->type != NL80211_IFTYPE_P2P_DEVICE && mvmvif->phy_ctxt &&
 	    mvmvif->phy_ctxt->id < MAX_PHYS)
-		*global_bound = true;
+		*global_cnt += 1;
 }
 
 static void iwl_mvm_scan_calc_params(struct iwl_mvm *mvm,
@@ -297,16 +299,16 @@ static void iwl_mvm_scan_calc_params(struct iwl_mvm *mvm,
 				     int n_ssids, u32 flags,
 				     struct iwl_mvm_scan_params *params)
 {
-	bool global_bound = false;
+	int global_cnt = 0;
 	enum ieee80211_band band;
 	u8 frag_passive_dwell = 0;
 
 	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
 					    IEEE80211_IFACE_ITER_NORMAL,
 					    iwl_mvm_scan_condition_iterator,
-					    &global_bound);
+					    &global_cnt);
 
-	if (!global_bound)
+	if (!global_cnt)
 		goto not_bound;
 
 #ifdef CPTCFG_IWLMVM_TCM
@@ -332,16 +334,31 @@ static void iwl_mvm_scan_calc_params(struct iwl_mvm *mvm,
 			break;
 		}
 	case IWL_MVM_VENDOR_LOAD_MEDIUM:
-		params->suspend_time = 120;
-		params->max_out_time = 120;
+		if (CPTCFG_IWLMVM_SCAN_PRECEDENCE_LEVEL == 1) {
+			params->suspend_time = 250;
+			params->max_out_time = 250;
+		} else {
+			params->suspend_time = 120;
+			params->max_out_time = 120;
+		}
 		break;
 	default:
+		if (CPTCFG_IWLMVM_SCAN_PRECEDENCE_LEVEL == 1) {
+			params->suspend_time = 100;
+			params->max_out_time = 600;
+		} else {
+			params->suspend_time = 30;
+			params->max_out_time = 170;
+		}
+	}
+#else
+	if (CPTCFG_IWLMVM_SCAN_PRECEDENCE_LEVEL == 1) {
+		params->suspend_time = 100;
+		params->max_out_time = 600;
+	} else {
 		params->suspend_time = 30;
 		params->max_out_time = 170;
 	}
-#else
-	params->suspend_time = 30;
-	params->max_out_time = 170;
 #endif
 
 	if (iwl_mvm_low_latency(mvm)) {
@@ -356,7 +373,11 @@ static void iwl_mvm_scan_calc_params(struct iwl_mvm *mvm,
 			params->suspend_time = 105;
 #endif
 			params->max_out_time = 70;
-			frag_passive_dwell = 20;
+			/*
+			 * If there is more than one active interface make
+			 * passive scan more fragmented.
+			 */
+			frag_passive_dwell = (global_cnt < 2) ? 40 : 20;
 		} else {
 			params->suspend_time = 120;
 			params->max_out_time = 120;
@@ -1347,10 +1368,14 @@ iwl_mvm_build_generic_unified_scan_cmd(struct iwl_mvm *mvm,
 			cpu_to_le16(IWL_SCAN_CHANNEL_FLAG_EBS |
 				    IWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |
 				    IWL_SCAN_CHANNEL_FLAG_CACHE_ADD);
+		cmd->channel_opt[0].non_ebs_ratio =
+			cpu_to_le16(IWL_DENSE_EBS_SCAN_RATIO);
 		cmd->channel_opt[1].flags =
 			cpu_to_le16(IWL_SCAN_CHANNEL_FLAG_EBS |
 				    IWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |
 				    IWL_SCAN_CHANNEL_FLAG_CACHE_ADD);
+		cmd->channel_opt[1].non_ebs_ratio =
+			cpu_to_le16(IWL_SPARSE_EBS_SCAN_RATIO);
 	}
 
 	if (iwl_mvm_rrm_scan_needed(mvm))
@@ -1654,7 +1679,7 @@ int iwl_mvm_config_scan(struct iwl_mvm *mvm)
 					 SCAN_CONFIG_FLAG_SET_MAC_ADDR |
 					 SCAN_CONFIG_FLAG_SET_CHANNEL_FLAGS|
 					 SCAN_CONFIG_N_CHANNELS(num_channels));
-	scan_config->tx_chains = cpu_to_le32(mvm->fw->valid_tx_ant);
+	scan_config->tx_chains = cpu_to_le32(iwl_mvm_get_valid_tx_ant(mvm));
 	scan_config->rx_chains = cpu_to_le32(iwl_mvm_scan_rx_ant(mvm));
 	scan_config->legacy_rates = iwl_mvm_scan_config_rates(mvm);
 	scan_config->out_of_channel_time = cpu_to_le32(170);
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/sta.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/sta.c
index d86fe43..ad32798 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/sta.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/sta.c
@@ -99,7 +99,7 @@ static int iwl_mvm_find_free_sta_id(struct iwl_mvm *mvm,
 int iwl_mvm_sta_send_to_fw(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 			   bool update)
 {
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 	struct iwl_mvm_add_sta_cmd add_sta_cmd = {
 		.sta_id = mvm_sta->sta_id,
 		.mac_id_n_color = cpu_to_le32(mvm_sta->mac_id_n_color),
@@ -259,7 +259,7 @@ int iwl_mvm_add_sta(struct iwl_mvm *mvm,
 		    struct ieee80211_sta *sta)
 {
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 	int i, ret, sta_id;
 
 	lockdep_assert_held(&mvm->mutex);
@@ -481,7 +481,7 @@ int iwl_mvm_rm_sta(struct iwl_mvm *mvm,
 		   struct ieee80211_sta *sta)
 {
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 	int ret;
 
 	lockdep_assert_held(&mvm->mutex);
@@ -774,7 +774,7 @@ int iwl_mvm_rm_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 int iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 		       int tid, u16 ssn, bool start)
 {
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 	struct iwl_mvm_add_sta_cmd cmd = {};
 	int ret;
 	u32 status;
@@ -834,7 +834,7 @@ int iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 static int iwl_mvm_sta_tx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 			      int tid, u8 queue, bool start)
 {
-	struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 	struct iwl_mvm_add_sta_cmd cmd = {};
 	int ret;
 	u32 status;
@@ -1144,10 +1144,10 @@ static int iwl_mvm_set_fw_key_idx(struct iwl_mvm *mvm)
 static u8 iwl_mvm_get_key_sta_id(struct ieee80211_vif *vif,
 				 struct ieee80211_sta *sta)
 {
-	struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 
 	if (sta) {
-		struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+		struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 
 		return mvm_sta->sta_id;
 	}
@@ -1280,7 +1280,7 @@ static inline u8 *iwl_mvm_get_mac_addr(struct iwl_mvm *mvm,
 				       struct ieee80211_vif *vif,
 				       struct ieee80211_sta *sta)
 {
-	struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 
 	if (sta)
 		return sta->addr;
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tt.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tt.c
index 2b1e61f..ba615ad 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tt.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tt.c
@@ -69,6 +69,7 @@
 
 static void iwl_mvm_enter_ctkill(struct iwl_mvm *mvm)
 {
+	struct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;
 	u32 duration = mvm->thermal_throttle.params->ct_kill_duration;
 
 	if (test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))
@@ -77,12 +78,15 @@ static void iwl_mvm_enter_ctkill(struct iwl_mvm *mvm)
 	IWL_ERR(mvm, "Enter CT Kill\n");
 	iwl_mvm_set_hw_ctkill_state(mvm, true);
 
+	tt->throttle = false;
+	tt->dynamic_smps = false;
+
 	/* Don't schedule an exit work if we're in test mode, since
 	 * the temperature will not change unless we manually set it
 	 * again (or disable testing).
 	 */
 	if (!mvm->temperature_test)
-		schedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,
+		schedule_delayed_work(&tt->ct_kill_exit,
 				      round_jiffies_relative(duration * HZ));
 }
 
@@ -452,6 +456,7 @@ void iwl_mvm_tt_initialize(struct iwl_mvm *mvm, u32 min_backoff)
 		tt->params = &iwl7000_tt_params;
 
 	tt->throttle = false;
+	tt->dynamic_smps = false;
 	tt->min_backoff = min_backoff;
 	INIT_DELAYED_WORK(&tt->ct_kill_exit, check_exit_ctkill);
 }
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tx.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tx.c
index f9801a2..52c971e 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tx.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/tx.c
@@ -209,7 +209,7 @@ void iwl_mvm_set_tx_cmd_rate(struct iwl_mvm *mvm, struct iwl_tx_cmd *tx_cmd,
 	rate_plcp = iwl_mvm_mac80211_idx_to_hwrate(rate_idx);
 
 	mvm->mgmt_last_antenna_idx =
-		iwl_mvm_next_antenna(mvm, mvm->fw->valid_tx_ant,
+		iwl_mvm_next_antenna(mvm, iwl_mvm_get_valid_tx_ant(mvm),
 				     mvm->mgmt_last_antenna_idx);
 
 	if (info->band == IEEE80211_BAND_2GHZ &&
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/utils.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/utils.c
index ab3cd74..d900dde 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/utils.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/utils.c
@@ -623,7 +623,7 @@ void iwl_mvm_update_smps(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 	lockdep_assert_held(&mvm->mutex);
 
 	/* SMPS is irrelevant for NICs that don't have at least 2 RX antenna */
-	if (num_of_ant(mvm->fw->valid_rx_ant) == 1)
+	if (num_of_ant(iwl_mvm_get_valid_rx_ant(mvm)) == 1)
 		return;
 
 	if (vif->type == NL80211_IFTYPE_AP)
@@ -665,7 +665,7 @@ bool iwl_mvm_rx_diversity_allowed(struct iwl_mvm *mvm)
 
 	lockdep_assert_held(&mvm->mutex);
 
-	if (num_of_ant(mvm->fw->valid_rx_ant) == 1)
+	if (num_of_ant(iwl_mvm_get_valid_rx_ant(mvm)) == 1)
 		return false;
 
 	if (!mvm->cfg->rx_with_siso_diversity)
@@ -852,6 +852,75 @@ void iwl_mvm_tcm_work(struct work_struct *work)
 	mutex_unlock(&mvm->mutex);
 }
 
+static void iwl_mvm_tcm_uapsd_nonagg_detected_wk(struct work_struct *wk)
+{
+	struct iwl_mvm *mvm;
+	struct iwl_mvm_vif *mvmvif;
+	struct ieee80211_vif *vif;
+
+	mvmvif = container_of(wk, struct iwl_mvm_vif,
+			      uapsd_nonagg_detected_wk.work);
+	vif = container_of((void *)mvmvif, struct ieee80211_vif, drv_priv);
+	mvm = mvmvif->mvm;
+
+	if (mvm->tcm.data[mvmvif->id].opened_rx_ba_sessions)
+		return;
+
+	/* remember that this AP is broken */
+	memcpy(mvm->uapsd_noagg_bssids[mvm->uapsd_noagg_bssid_write_idx].addr,
+	       vif->bss_conf.bssid, ETH_ALEN);
+	mvm->uapsd_noagg_bssid_write_idx++;
+	if (mvm->uapsd_noagg_bssid_write_idx >= IWL_MVM_UAPSD_NOAGG_BSSIDS_NUM)
+		mvm->uapsd_noagg_bssid_write_idx = 0;
+
+	ieee80211_connection_loss(vif);
+}
+
+static void iwl_mvm_uapsd_agg_disconnect_iter(void *data, u8 *mac,
+					      struct ieee80211_vif *vif)
+{
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+	struct iwl_mvm *mvm = mvmvif->mvm;
+	int *mac_id = data;
+
+	if (vif->type != NL80211_IFTYPE_STATION)
+		return;
+
+	if (mvmvif->id != *mac_id)
+		return;
+
+	if (!vif->bss_conf.assoc)
+		return;
+
+	if (mvm->tcm.data[*mac_id].uapsd_nonagg_detect.detected)
+		return;
+
+	mvm->tcm.data[*mac_id].uapsd_nonagg_detect.detected = true;
+	schedule_delayed_work(&mvmvif->uapsd_nonagg_detected_wk, 5 * HZ);
+}
+
+static void iwl_mvm_check_uapsd_agg_expected_tpt(struct iwl_mvm *mvm,
+						 unsigned int elapsed,
+						 int mac)
+{
+	u64 bytes = mvm->tcm.data[mac].uapsd_nonagg_detect.rx_bytes;
+	u64 tpt;
+
+	if (mvm->tcm.data[mac].opened_rx_ba_sessions ||
+	    mvm->tcm.data[mac].uapsd_nonagg_detect.detected)
+		return;
+
+	tpt = 2 * 8 * bytes;
+	do_div(tpt, elapsed); /* 500kbps */
+
+	if (tpt < ewma_read(&mvm->tcm.data[mac].uapsd_nonagg_detect.rate))
+		return;
+
+	ieee80211_iterate_active_interfaces_atomic(
+		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+		iwl_mvm_uapsd_agg_disconnect_iter, &mac);
+}
+
 static unsigned long iwl_mvm_calc_tcm_stats(struct iwl_mvm *mvm,
 					    unsigned long ts)
 {
@@ -899,9 +968,16 @@ static unsigned long iwl_mvm_calc_tcm_stats(struct iwl_mvm *mvm,
 		}
 		low_latency |= mvm->tcm.result.low_latency[mac];
 
+		if (mvm->tcm.data[mac].uapsd_nonagg_detect.rx_pkts >
+				IWL_MVM_UAPSD_AGGDETECT_MIN_PKTS &&
+		    !low_latency)
+			iwl_mvm_check_uapsd_agg_expected_tpt(mvm, elapsed, mac);
+
 		/* clear old data */
 		memset(&mdata->rx.airtime, 0, sizeof(mdata->rx.airtime));
 		memset(&mdata->tx.airtime, 0, sizeof(mdata->tx.airtime));
+		memset(&mdata->uapsd_nonagg_detect, 0,
+		       sizeof(mdata->uapsd_nonagg_detect));
 	}
 
 	load = iwl_mvm_tcm_load(mvm, total_airtime, elapsed);
@@ -965,4 +1041,19 @@ void iwl_mvm_resume_tcm(struct iwl_mvm *mvm)
 	mvm->tcm.paused = false;
 	spin_unlock_bh(&mvm->tcm.lock);
 }
+
+void iwl_mvm_tcm_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+{
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+	INIT_DELAYED_WORK(&mvmvif->uapsd_nonagg_detected_wk,
+			  iwl_mvm_tcm_uapsd_nonagg_detected_wk);
+}
+
+void iwl_mvm_tcm_rm_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+{
+	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+	cancel_delayed_work_sync(&mvmvif->uapsd_nonagg_detected_wk);
+}
 #endif
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.c
index 97dc473..de404c6 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.c
@@ -70,6 +70,7 @@
 static const struct nla_policy
 iwl_mvm_vendor_attr_policy[NUM_IWL_MVM_VENDOR_ATTR] = {
 	[IWL_MVM_VENDOR_ATTR_LOW_LATENCY] = { .type = NLA_FLAG },
+	[IWL_MVM_VENDOR_ATTR_COUNTRY] = { .type = NLA_STRING, .len = 2 },
 };
 
 static int iwl_mvm_parse_vendor_data(struct nlattr **tb,
@@ -130,6 +131,46 @@ static int iwl_mvm_get_low_latency(struct wiphy *wiphy,
 	return cfg80211_vendor_cmd_reply(skb);
 }
 
+static int iwl_mvm_set_country(struct wiphy *wiphy,
+			       struct wireless_dev *wdev,
+			       const void *data, int data_len)
+{
+	struct ieee80211_regdomain *regd;
+	struct nlattr *tb[NUM_IWL_MVM_VENDOR_ATTR];
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+	int retval;
+
+	if (!iwl_mvm_is_lar_supported(mvm))
+		return -EOPNOTSUPP;
+
+	retval = iwl_mvm_parse_vendor_data(tb, data, data_len);
+	if (retval)
+		return retval;
+
+	if (!tb[IWL_MVM_VENDOR_ATTR_COUNTRY])
+		return -EINVAL;
+
+	mutex_lock(&mvm->mutex);
+
+	/* set regdomain information to FW */
+	regd = iwl_mvm_get_regdomain(wiphy,
+				     nla_data(tb[IWL_MVM_VENDOR_ATTR_COUNTRY]),
+				     iwl_mvm_is_wifi_mcc_supported(mvm) ?
+				     MCC_SOURCE_3G_LTE_HOST :
+				     MCC_SOURCE_OLD_FW);
+	if (IS_ERR_OR_NULL(regd)) {
+		retval = -EIO;
+		goto unlock;
+	}
+
+	retval = regulatory_set_wiphy_regd(wiphy, regd);
+	kfree(regd);
+unlock:
+	mutex_unlock(&mvm->mutex);
+	return retval;
+}
+
 static const struct wiphy_vendor_command iwl_mvm_vendor_commands[] = {
 	{
 		.info = {
@@ -149,6 +190,15 @@ static const struct wiphy_vendor_command iwl_mvm_vendor_commands[] = {
 			 WIPHY_VENDOR_CMD_NEED_RUNNING,
 		.doit = iwl_mvm_get_low_latency,
 	},
+	{
+		.info = {
+			.vendor_id = INTEL_OUI,
+			.subcmd = IWL_MVM_VENDOR_CMD_SET_COUNTRY,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = iwl_mvm_set_country,
+	},
 };
 
 #ifdef CPTCFG_IWLMVM_TCM
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.h
index 38bfbb0..49aaf14 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/mvm/vendor-cmd.h
@@ -78,6 +78,7 @@
  * @IWL_MVM_VENDOR_CMD_LTE_COEX_SPS_INFO: configure semi oersistent info
  * @IWL_MVM_VENDOR_CMD_LTE_COEX_WIFI_RPRTD_CHAN: Wifi reported channel as
  *	calculated by the coex-manager
+ * @IWL_MVM_VENDOR_CMD_SET_COUNTRY: set a new mcc regulatory information
  */
 
 enum iwl_mvm_vendor_cmd {
@@ -89,6 +90,7 @@ enum iwl_mvm_vendor_cmd {
 	IWL_MVM_VENDOR_CMD_LTE_COEX_DYNAMIC_INFO,
 	IWL_MVM_VENDOR_CMD_LTE_COEX_SPS_INFO,
 	IWL_MVM_VENDOR_CMD_LTE_COEX_WIFI_RPRTD_CHAN,
+	IWL_MVM_VENDOR_CMD_SET_COUNTRY,
 };
 
 /**
@@ -116,6 +118,7 @@ enum iwl_mvm_vendor_load {
  * @IWL_MVM_VENDOR_ATTR_LL: global low-latency (u8, 0/1)
  * @IWL_MVM_VENDOR_ATTR_VIF_LOAD: vif traffic load (u8, see load enum)
  * @IWL_MVM_VENDOR_ATTR_LOAD: global traffic load (u8, see load enum)
+ * @IWL_MVM_VENDOR_ATTR_COUNTRY: MCC to set, for regulatory information (u16)
  * @NUM_IWL_MVM_VENDOR_ATTR: number of vendor attributes
  * @MAX_IWL_MVM_VENDOR_ATTR: highest vendor attribute number
  */
@@ -127,6 +130,7 @@ enum iwl_mvm_vendor_attr {
 	IWL_MVM_VENDOR_ATTR_LL,
 	IWL_MVM_VENDOR_ATTR_VIF_LOAD,
 	IWL_MVM_VENDOR_ATTR_LOAD,
+	IWL_MVM_VENDOR_ATTR_COUNTRY,
 
 	NUM_IWL_MVM_VENDOR_ATTR,
 	MAX_IWL_MVM_VENDOR_ATTR = NUM_IWL_MVM_VENDOR_ATTR - 1,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/drv.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/drv.c
index 8cd1833..f91b67f 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/drv.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/drv.c
@@ -228,6 +228,8 @@ static const struct pci_device_id iwl_hw_card_ids[] = {
 	{IWL_PCI_DEVICE(0x24F3, 0x0010, iwl8260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x24F3, 0x0004, iwl8260_2n_cfg)},
 	{IWL_PCI_DEVICE(0x24F4, 0x0030, iwl8260_2ac_cfg)},
+	{IWL_PCI_DEVICE(0x24F5, 0x0010, iwl4165_2ac_cfg)},
+	{IWL_PCI_DEVICE(0x24F6, 0x0030, iwl4165_2ac_cfg)},
 #endif /* CPTCFG_IWLMVM */
 
 	{0}
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/internal.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/internal.h
index e6129af..5d27b4e 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/internal.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/internal.h
@@ -36,6 +36,9 @@
 #include <linux/wait.h>
 #include <linux/pci.h>
 #include <linux/timer.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
 
 #include "iwl-fh.h"
 #include "iwl-csr.h"
@@ -318,6 +321,15 @@ struct iwl_trans_pcie {
 	/*protect hw register */
 	spinlock_t reg_lock;
 	bool cmd_in_flight;
+	bool ref_cmd_in_flight;
+
+	/* protect ref counter */
+	spinlock_t ref_lock;
+	u32 ref_count;
+#ifdef CONFIG_HAS_WAKELOCK
+	struct wake_lock ref_wake_lock;
+	struct wake_lock timed_wake_lock;
+#endif
 
 	dma_addr_t fw_mon_phys;
 	struct page *fw_mon_page;
@@ -381,6 +393,9 @@ void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
 			    struct sk_buff_head *skbs);
 void iwl_trans_pcie_tx_reset(struct iwl_trans *trans);
 
+void iwl_trans_pcie_ref(struct iwl_trans *trans);
+void iwl_trans_pcie_unref(struct iwl_trans *trans);
+
 static inline u16 iwl_pcie_tfd_tb_get_len(struct iwl_tfd *tfd, u8 idx)
 {
 	struct iwl_tfd_tb *tb = &tfd->tbs[idx];
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/trans.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/trans.c
index 897f9f3..9143b67 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/trans.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/trans.c
@@ -77,6 +77,7 @@
 #include "iwl-prph.h"
 #include "iwl-agn-hw.h"
 #include "iwl-fw-error-dump.h"
+#include "iwl-constants.h"
 #include "internal.h"
 #include "iwl-fh.h"
 #ifdef CPTCFG_IWLWIFI_DEVICE_TESTMODE
@@ -446,10 +447,25 @@ static int iwl_pcie_apm_stop_master(struct iwl_trans *trans)
 	return ret;
 }
 
-static void iwl_pcie_apm_stop(struct iwl_trans *trans)
+static void iwl_pcie_apm_stop(struct iwl_trans *trans, bool op_mode_leave)
 {
 	IWL_DEBUG_INFO(trans, "Stop card, put in low power state\n");
 
+	if (op_mode_leave) {
+		if (!test_bit(STATUS_DEVICE_ENABLED, &trans->status))
+			iwl_pcie_apm_init(trans);
+
+		/* inform ME that we are leaving */
+		if (trans->cfg->device_family == IWL_DEVICE_FAMILY_7000)
+			iwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG,
+					  APMG_PCIDEV_STT_VAL_WAKE_ME);
+		else if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
+			iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,
+				    CSR_HW_IF_CONFIG_REG_PREPARE |
+				    CSR_HW_IF_CONFIG_REG_ENABLE_PME);
+		mdelay(5);
+	}
+
 	clear_bit(STATUS_DEVICE_ENABLED, &trans->status);
 
 	/* Stop device's DMA activity */
@@ -900,6 +916,9 @@ static int iwl_pcie_load_given_ucode_8000b(struct iwl_trans *trans,
 	if (ret)
 		return ret;
 
+	if (trans->dbg_dest_tlv)
+		iwl_pcie_apply_destination(trans);
+
 #ifdef CPTCFG_IWLWIFI_DEVICE_TESTMODE
 	iwl_dnt_configure(trans, image);
 #endif
@@ -927,6 +946,7 @@ static int iwl_pcie_load_given_ucode_8000b(struct iwl_trans *trans,
 static int iwl_trans_pcie_start_fw(struct iwl_trans *trans,
 				   const struct fw_img *fw, bool run_in_rfkill)
 {
+	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	int ret;
 	bool hw_rfkill;
 
@@ -956,6 +976,14 @@ static int iwl_trans_pcie_start_fw(struct iwl_trans *trans,
 		return ret;
 	}
 
+#ifdef CONFIG_HAS_WAKELOCK
+	/* The ref wakelock is locked on init */
+	if (trans->dbg_cfg.wakelock_mode != IWL_WAKELOCK_MODE_OFF)
+		wake_lock(&trans_pcie->ref_wake_lock);
+#endif
+	/* init ref_count to 1 (should be cleared when ucode is loaded) */
+	trans_pcie->ref_count = 1;
+
 	/* make sure rfkill handshake bits are cleared */
 	iwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);
 	iwl_write32(trans, CSR_UCODE_DRV_GP1_CLR,
@@ -1009,6 +1037,11 @@ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans)
 		IWL_DEBUG_INFO(trans, "DEVICE_ENABLED bit was set and is now cleared\n");
 		iwl_pcie_tx_stop(trans);
 		iwl_pcie_rx_stop(trans);
+#ifdef CONFIG_HAS_WAKELOCK
+		/* release wake_lock while device is stopped */
+		if (trans->dbg_cfg.wakelock_mode != IWL_WAKELOCK_MODE_OFF)
+			wake_unlock(&trans_pcie->ref_wake_lock);
+#endif
 
 		/* Power-down device's busmaster DMA clocks */
 		iwl_write_prph(trans, APMG_CLK_DIS_REG,
@@ -1021,18 +1054,23 @@ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans)
 		      CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
 
 	/* Stop the device, and put it in low power state */
-	iwl_pcie_apm_stop(trans);
+	iwl_pcie_apm_stop(trans, false);
+
+	/* stop and reset the on-board processor */
+	iwl_write32(trans, CSR_RESET, CSR_RESET_REG_FLAG_SW_RESET);
+	udelay(20);
 
-	/* Upon stop, the APM issues an interrupt if HW RF kill is set.
-	 * Clean again the interrupt here
+	/*
+	 * Upon stop, the APM issues an interrupt if HW RF kill is set.
+	 * This is a bug in certain verions of the hardware.
+	 * Certain devices also keep sending HW RF kill interrupt all
+	 * the time, unless the interrupt is ACKed even if the interrupt
+	 * should be masked. Re-ACK all the interrupts here.
 	 */
 	spin_lock(&trans_pcie->irq_lock);
 	iwl_disable_interrupts(trans);
 	spin_unlock(&trans_pcie->irq_lock);
 
-	/* stop and reset the on-board processor */
-	iwl_write32(trans, CSR_RESET, CSR_RESET_REG_FLAG_SW_RESET);
-	udelay(20);
 
 	/* clear all status bits */
 	clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
@@ -1198,7 +1236,7 @@ static void iwl_trans_pcie_op_mode_leave(struct iwl_trans *trans)
 	iwl_disable_interrupts(trans);
 	spin_unlock(&trans_pcie->irq_lock);
 
-	iwl_pcie_apm_stop(trans);
+	iwl_pcie_apm_stop(trans, true);
 
 	spin_lock(&trans_pcie->irq_lock);
 	iwl_disable_interrupts(trans);
@@ -1305,6 +1343,11 @@ void iwl_trans_pcie_free(struct iwl_trans *trans)
 	if (trans_pcie->napi.poll)
 		netif_napi_del(&trans_pcie->napi);
 
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_destroy(&trans_pcie->ref_wake_lock);
+	wake_lock_destroy(&trans_pcie->timed_wake_lock);
+#endif
+
 	iwl_pcie_free_fw_monitor(trans);
 
 	kfree(trans);
@@ -1546,6 +1589,58 @@ static void iwl_trans_pcie_set_bits_mask(struct iwl_trans *trans, u32 reg,
 	spin_unlock_irqrestore(&trans_pcie->reg_lock, flags);
 }
 
+void iwl_trans_pcie_ref(struct iwl_trans *trans)
+{
+	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+	unsigned long flags;
+
+	if (iwlwifi_mod_params.d0i3_disable)
+		return;
+
+	spin_lock_irqsave(&trans_pcie->ref_lock, flags);
+	IWL_DEBUG_RPM(trans, "ref_counter: %d\n", trans_pcie->ref_count);
+	trans_pcie->ref_count++;
+#ifdef CONFIG_HAS_WAKELOCK
+	/* take ref wakelock on first reference */
+	if (trans_pcie->ref_count == 1 &&
+	    trans->dbg_cfg.wakelock_mode == IWL_WAKELOCK_MODE_IDLE)
+		wake_lock(&trans_pcie->ref_wake_lock);
+#endif
+	spin_unlock_irqrestore(&trans_pcie->ref_lock, flags);
+}
+
+void iwl_trans_pcie_unref(struct iwl_trans *trans)
+{
+	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+	unsigned long flags;
+
+	if (iwlwifi_mod_params.d0i3_disable)
+		return;
+
+	spin_lock_irqsave(&trans_pcie->ref_lock, flags);
+	IWL_DEBUG_RPM(trans, "ref_counter: %d\n", trans_pcie->ref_count);
+	if (WARN_ON_ONCE(trans_pcie->ref_count == 0)) {
+		spin_unlock_irqrestore(&trans_pcie->ref_lock, flags);
+		return;
+	}
+	trans_pcie->ref_count--;
+
+#ifdef CONFIG_HAS_WAKELOCK
+	/*
+	 * release ref wake lock and take timed wake lock when
+	 * last reference is released.
+	 */
+	if (trans_pcie->ref_count == 0 &&
+	    trans->dbg_cfg.wakelock_mode == IWL_WAKELOCK_MODE_IDLE) {
+		wake_unlock(&trans_pcie->ref_wake_lock);
+		wake_lock_timeout(&trans_pcie->timed_wake_lock,
+				  msecs_to_jiffies(IWL_WAKELOCK_TIMEOUT_MS));
+	}
+#endif
+
+	spin_unlock_irqrestore(&trans_pcie->ref_lock, flags);
+}
+
 static const char *get_csr_string(int cmd)
 {
 #define IWL_CMD(x) case x: return #x
@@ -2270,6 +2365,9 @@ static const struct iwl_trans_ops trans_ops_pcie = {
 	.release_nic_access = iwl_trans_pcie_release_nic_access,
 	.set_bits_mask = iwl_trans_pcie_set_bits_mask,
 
+	.ref = iwl_trans_pcie_ref,
+	.unref = iwl_trans_pcie_unref,
+
 	.dump_data = iwl_trans_pcie_dump_data,
 };
 
@@ -2411,6 +2509,14 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
 
 	trans_pcie->inta_mask = CSR_INI_SET_MASK;
 
+	trans->d0i3_mode = IWL_D0I3_MODE_ON_SUSPEND;
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&trans_pcie->ref_wake_lock, WAKE_LOCK_SUSPEND,
+		       "iwlwifi_pcie_ref_wakelock");
+	wake_lock_init(&trans_pcie->timed_wake_lock, WAKE_LOCK_SUSPEND,
+		       "iwlwifi_pcie_timed_wakelock");
+#endif
+
 	return trans;
 
 out_free_ict:
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/tx.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/tx.c
index 53684d1..4c49551 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/tx.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/pcie/tx.c
@@ -985,17 +985,31 @@ void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
 
 	if (iwl_queue_space(&txq->q) > txq->q.low_mark)
 		iwl_wake_queue(trans, txq);
+
+	if (q->read_ptr == q->write_ptr) {
+		IWL_DEBUG_RPM(trans, "Q %d - last tx reclaimed\n", q->id);
+		iwl_trans_pcie_unref(trans);
+	}
+
 out:
 	spin_unlock_bh(&txq->lock);
 }
 
-static int iwl_pcie_set_cmd_in_flight(struct iwl_trans *trans)
+static int iwl_pcie_set_cmd_in_flight(struct iwl_trans *trans,
+				      const struct iwl_host_cmd *cmd)
 {
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	int ret;
 
 	lockdep_assert_held(&trans_pcie->reg_lock);
 
+	if (!(cmd->flags & CMD_SEND_IN_IDLE) &&
+	    !trans_pcie->ref_cmd_in_flight) {
+		trans_pcie->ref_cmd_in_flight = true;
+		IWL_DEBUG_RPM(trans, "set ref_cmd_in_flight - ref\n");
+		iwl_trans_pcie_ref(trans);
+	}
+
 	if (trans_pcie->cmd_in_flight)
 		return 0;
 
@@ -1036,6 +1050,12 @@ static int iwl_pcie_clear_cmd_in_flight(struct iwl_trans *trans)
 
 	lockdep_assert_held(&trans_pcie->reg_lock);
 
+	if (trans_pcie->ref_cmd_in_flight) {
+		trans_pcie->ref_cmd_in_flight = false;
+		IWL_DEBUG_RPM(trans, "clear ref_cmd_in_flight - unref\n");
+		iwl_trans_pcie_unref(trans);
+	}
+
 	if (WARN_ON(!trans_pcie->cmd_in_flight))
 		return 0;
 
@@ -1473,7 +1493,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
 		mod_timer(&txq->stuck_timer, jiffies + trans_pcie->wd_timeout);
 
 	spin_lock_irqsave(&trans_pcie->reg_lock, flags);
-	ret = iwl_pcie_set_cmd_in_flight(trans);
+	ret = iwl_pcie_set_cmd_in_flight(trans, cmd);
 	if (ret < 0) {
 		idx = ret;
 		spin_unlock_irqrestore(&trans_pcie->reg_lock, flags);
@@ -1819,9 +1839,13 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
 	wait_write_ptr = ieee80211_has_morefrags(fc);
 
 	/* start timer if queue currently empty */
-	if (txq->need_update && q->read_ptr == q->write_ptr &&
-	    trans_pcie->wd_timeout)
-		mod_timer(&txq->stuck_timer, jiffies + trans_pcie->wd_timeout);
+	if (q->read_ptr == q->write_ptr) {
+		if (txq->need_update && trans_pcie->wd_timeout)
+			mod_timer(&txq->stuck_timer,
+				  jiffies + trans_pcie->wd_timeout);
+		IWL_DEBUG_RPM(trans, "Q: %d first tx - take ref\n", q->id);
+		iwl_trans_pcie_ref(trans);
+	}
 
 	/* Tell device the write index *just past* this latest filled TFD */
 	q->write_ptr = iwl_queue_inc_wrap(q->write_ptr);
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/mini_rpm.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/mini_rpm.c
index fddfea3..2536b13 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/mini_rpm.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/mini_rpm.c
@@ -138,6 +138,7 @@ int mini_rpm_init(struct iwl_trans_slv *trans_slv,
 
 void mini_rpm_destroy(struct iwl_trans_slv *trans_slv)
 {
+	flush_delayed_work(&trans_slv->rpm_suspend_work);
 	flush_workqueue(trans_slv->rpm_wq);
 	destroy_workqueue(trans_slv->rpm_wq);
 	trans_slv->rpm_wq = NULL;
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_drv.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_drv.c
index b53bf6a..adf68d0 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_drv.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_drv.c
@@ -77,6 +77,7 @@
 #include "sdio_internal.h"
 #include "iwl-trans.h"
 #include "iwl-config.h"
+#include "iwl-constants.h"
 
 /*
  * Vendor ID and SDIO compatible devices
@@ -116,12 +117,16 @@ static int iwl_sdio_suspend(struct device *dev)
 	struct iwl_trans_slv *trans_slv = IWL_TRANS_GET_SLV_TRANS(trans);
 	int ret;
 
-	if (trans_slv->wowlan_enabled) {
-		ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
-		if (ret) {
-			IWL_WARN_DEV(dev, "Unable to set MMC_PM_KEEP_POWER\n");
-			return ret;
-		}
+	/*
+	 * There seems to be some platform issue that prevents the mmc
+	 * from resuming properly when MMC_PM_KEEP_POWER is not set.
+	 * Workaround it by always setting the flag, even when not needed.
+	 * Since it's a work around, abort suspend only if wowlan is enabled.
+	 */
+	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+	if (ret && trans_slv->wowlan_enabled) {
+		IWL_WARN_DEV(dev, "Unable to set MMC_PM_KEEP_POWER\n");
+		return ret;
 	}
 
 	_iwl_sdio_suspend(trans);
@@ -160,42 +165,47 @@ static int iwl_sdio_probe(struct sdio_func *func,
 {
 	const struct iwl_cfg *cfg = (struct iwl_cfg *)(id->driver_data);
 	struct iwl_trans_sdio *trans_sdio;
-	struct iwl_trans *iwl_trans;
+	struct iwl_trans *trans;
 	int ret;
 
 	/* Allocate generic transport layer */
-	iwl_trans = iwl_trans_sdio_alloc(func, id, cfg);
-	if (IS_ERR(iwl_trans))
-		return PTR_ERR(iwl_trans);
+	trans = iwl_trans_sdio_alloc(func, id, cfg);
+	if (IS_ERR(trans))
+		return PTR_ERR(trans);
 
-	trans_sdio = IWL_TRANS_GET_SDIO_TRANS(iwl_trans);
+	trans_sdio = IWL_TRANS_GET_SDIO_TRANS(trans);
 
 	/* Set the generic transport as the private data of the
 	 * the sdio function */
-	sdio_set_drvdata(func, iwl_trans);
+	sdio_set_drvdata(func, trans);
 
-	trans_sdio->drv = iwl_drv_start(iwl_trans, cfg);
+	/* Read CSR_HW_REV prior to fw request flow */
+	ret = iwl_sdio_read_hw_rev_nic_off(trans);
+	if (ret)
+		goto out_free_trans;
+
+	trans_sdio->drv = iwl_drv_start(trans, cfg);
 	if (IS_ERR(trans_sdio->drv)) {
 		ret = PTR_ERR(trans_sdio->drv);
 		goto out_free_trans;
 	}
 
 	/* register transport layer debugfs here */
-	ret = iwl_trans_slv_dbgfs_register(iwl_trans, iwl_trans->dbgfs_dir);
+	ret = iwl_trans_slv_dbgfs_register(trans, trans->dbgfs_dir);
 	if (ret)
 		goto out_free_drv;
 
 	/* enable sdio runtime pm */
-	if (!(d0i3_debug & IWL_D0I3_DBG_DISABLE))
-		pm_runtime_put_noidle(iwl_trans->dev);
+	if (!iwlwifi_mod_params.d0i3_disable)
+		pm_runtime_put_noidle(trans->dev);
 
-	IWL_INFO(iwl_trans, "SDIO probing completed successfully\n");
+	IWL_INFO(trans, "SDIO probing completed successfully\n");
 	return 0;
 
 out_free_drv:
 	iwl_drv_stop(trans_sdio->drv);
 out_free_trans:
-	iwl_trans_sdio_free(iwl_trans);
+	iwl_trans_sdio_free(trans);
 	sdio_set_drvdata(func, NULL);
 
 	__iwl_err(&func->dev, 0, 0, "Failed to complete SDIO probe\n");
@@ -223,7 +233,7 @@ static void iwl_sdio_remove(struct sdio_func *func)
 	sdio_set_drvdata(func, NULL);
 
 	/* disable sdio runtime pm */
-	if (!(d0i3_debug & IWL_D0I3_DBG_DISABLE))
+	if (!iwlwifi_mod_params.d0i3_disable)
 		pm_runtime_get_noresume(trans->dev);
 
 	/* Release all BUS allocated memroy */
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_internal.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_internal.h
index 4121d5a..c10efdf 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_internal.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_internal.h
@@ -153,6 +153,8 @@ struct iwl_sdio_plat_data {
  * @scd_base_addr:	the base address of scheduler region
  * @cfg_pool_size:	the size of dtu_cfg_pool buffers
  * @send_buf:		the buffer for copying DTU to be sent
+ * @sdio_adma_addr: the default address to set for the ADMA in SDIO mode until
+ *	we get the ALIVE from the uCode
  */
 struct iwl_trans_sdio {
 	struct iwl_drv *drv;
@@ -207,6 +209,8 @@ struct iwl_trans_sdio {
 	struct net_device napi_dev;
 	struct napi_struct napi;
 	struct iwl_sdio_sf_mem_addresses mem_addresses;
+
+	u32 sdio_adma_addr;
 };
 
 /*
@@ -260,6 +264,7 @@ int iwl_sdio_tx_init(struct iwl_trans *trans);
 ******************************************************/
 void iwl_sdio_handle_ta_read_ready(struct iwl_trans *trans,
 				   struct iwl_sdio_cmd_buffer *ta_buff);
+int iwl_sdio_read_hw_rev_nic_off(struct iwl_trans *trans);
 
 #ifdef CONFIG_PM_SLEEP
 void _iwl_sdio_suspend(struct iwl_trans *trans);
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_rx.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_rx.c
index f848c51..8a53ba3 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_rx.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_rx.c
@@ -469,18 +469,15 @@ void iwl_sdio_isr(struct sdio_func *func)
 
 		/*
 		 * SDTM CSR register to enable read optimization on 8000 family
-		 * B-step and onwards. In this optimization there is no need to
-		 * clear the IWL_SDIO_INTR_CAUSE_REG
+		 * B-step and onwards is currently disabled due to some HW/FW
+		 * issue. In this optimization there is no need to clear the
+		 * IWL_SDIO_INTR_CAUSE_REG
 		 */
-		if ((trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) ||
-		    ((trans->hw_rev & 0xc) == 0x0)) {
-			ret = iwl_sdio_write8(trans, IWL_SDIO_INTR_CAUSE_REG,
-					      val);
-			if (ret)
-				IWL_ERR(trans,
-					"Failed to clear the int val %d, reason %d\n",
-					val, ret);
-		}
+		ret = iwl_sdio_write8(trans, IWL_SDIO_INTR_CAUSE_REG, val);
+		if (ret)
+			IWL_ERR(trans,
+				"Failed to clear the int val %d, reason %d\n",
+				val, ret);
 
 
 		if (val & IWL_SDIO_INTR_READ_ERROR) {
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_trans.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_trans.c
index dff27d1..6e92be3 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_trans.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/sdio_trans.c
@@ -71,6 +71,7 @@
 #include <linux/mmc/sdhci.h>
 #include <linux/gpio.h>
 #include <linux/platform_device.h>
+#include <linux/vmalloc.h>
 
 #include "sdio_internal.h"
 #include "sdio_tx.h"
@@ -83,6 +84,7 @@
 #include "iwl-debug.h"
 #include "iwl-fw-error-dump.h"
 #include "iwl-prph.h"
+#include "iwl-constants.h"
 #ifdef CPTCFG_IWLWIFI_DEVICE_TESTMODE
 #include "iwl-dnt-cfg.h"
 #endif
@@ -929,30 +931,6 @@ static int iwl_sdio_config_sdtm_register(struct iwl_trans *trans)
 	return ret;
 }
 
-/*
- * Configure the SDTM in the SDIO AL.
- *
- *@func - The SDIO HW function bus driver.
- */
-static int iwl_sdio_config_sdtm(struct iwl_trans *trans)
-{
-	struct iwl_trans_sdio *trans_sdio = IWL_TRANS_GET_SDIO_TRANS(trans);
-	int ret;
-
-	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000) {
-		if (CSR_HW_REV_STEP(trans->hw_rev) == SILICON_A_STEP)
-			trans_sdio->sf_mem_addresses = &iwl8000_sf_addresses;
-		else
-			trans_sdio->sf_mem_addresses = &iwl8000b_sf_addresses;
-	} else {
-		trans_sdio->sf_mem_addresses = &iwl7000_sf_addresses;
-	}
-
-	ret = iwl_sdio_config_sdtm_register(trans);
-
-	return ret;
-}
-
 static int iwl_sdio_update_sdtm(struct iwl_trans *trans,
 				struct iwl_sf_region *st_fwrd_space)
 {
@@ -979,6 +957,41 @@ static int iwl_sdio_update_sdtm(struct iwl_trans *trans,
 }
 
 /*
+ * Configure the SDTM in the SDIO AL.
+ *
+ *@func - The SDIO HW function bus driver.
+ */
+static int iwl_sdio_config_sdtm(struct iwl_trans *trans)
+{
+	struct iwl_trans_sdio *trans_sdio = IWL_TRANS_GET_SDIO_TRANS(trans);
+	int ret;
+
+	/* If a default ADMA addr has been given in the FW - use it */
+	if (trans_sdio->sdio_adma_addr) {
+		struct iwl_sf_region st_fwrd_space = {
+			.addr = trans_sdio->sdio_adma_addr,
+			.size = 0, /* Unused in the initial configuration */
+		};
+
+		return iwl_sdio_update_sdtm(trans, &st_fwrd_space);
+	}
+
+	/* No default ADMA addr has been given in FW - use driver defaults */
+	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000) {
+		if (CSR_HW_REV_STEP(trans->hw_rev) == SILICON_A_STEP)
+			trans_sdio->sf_mem_addresses = &iwl8000_sf_addresses;
+		else
+			trans_sdio->sf_mem_addresses = &iwl8000b_sf_addresses;
+	} else {
+		trans_sdio->sf_mem_addresses = &iwl7000_sf_addresses;
+	}
+
+	ret = iwl_sdio_config_sdtm_register(trans);
+
+	return ret;
+}
+
+/*
  * Init ADMA descriptors memory (due to ADMA-bug) :
  * By writing a non-zero value to S/F memory ADMA descriptors memory
  * base (0x82A00), 88 bytes (use pattern 0x47554232414D4441).
@@ -1167,6 +1180,79 @@ static inline int iwl_sdio_exit_retention_flow(struct iwl_trans *trans)
 }
 
 /*
+ * Read the HW_REV register in SDIO while the NIC is off.
+ *
+ * Mainly used in init flow to understand which FW to load.
+ * Does the minimum procedures in order to be able to read
+ * the register via target access.
+ *
+ * @trans - the generic transport layer.
+ */
+int iwl_sdio_read_hw_rev_nic_off(struct iwl_trans *trans)
+{
+	struct iwl_trans_sdio *trans_sdio = IWL_TRANS_GET_SDIO_TRANS(trans);
+	struct sdio_func *func = IWL_TRANS_SDIO_GET_FUNC(trans);
+	int ret;
+
+	iwl_sdio_set_power(trans, true);
+	mutex_lock(&trans_sdio->target_access_mtx);
+
+	/* Enable SDIO function for access */
+	sdio_claim_host(func);
+	func->enable_timeout = IWL_SDIO_ENABLE_TIMEOUT;
+	ret = sdio_enable_func(func);
+	if (ret) {
+		IWL_ERR(trans, "Failed to enable the sdio function\n");
+		goto clear_locks;
+	}
+
+	/* Exit retention flow for TA interrupts */
+	ret = iwl_sdio_exit_retention_flow(trans);
+	if (ret)
+		goto disable_hw;
+
+	/* Enable interrupts which are required for TA */
+	ret = iwl_sdio_enable_interrupts(trans);
+	if (ret)
+		goto disable_hw;
+
+	/* Read HW rev from HW */
+	ret = iwl_sdio_ta_read(trans, CSR_HW_REV, sizeof(u32), &trans->hw_rev,
+			       IWL_SDIO_TA_AC_DIRECT);
+	if (ret)
+		goto disable_int;
+
+	/* Parse the HW revision according to the new HW_REV format */
+	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
+		trans->hw_rev = (trans->hw_rev & 0xfff0) |
+				((trans->hw_rev << 2) & 0xc);
+
+	IWL_INFO(trans, "Device HW revision 0x%x\n", trans->hw_rev);
+
+disable_int:
+	/* Disable and Release the interrupts registration */
+	iwl_sdio_disable_interrupts(trans);
+	sdio_release_irq(func);
+
+disable_hw:
+	/* Power down back to original state */
+	IWL_DEBUG_INFO(trans, "Powering down the NIC after reading REV\n");
+	ret = sdio_disable_func(IWL_TRANS_SDIO_GET_FUNC(trans));
+	if (ret)
+		IWL_ERR(trans, "Failed to disable the SDIO bus\n");
+
+	/* Wait for 10ms for IOR to become 0 */
+	msleep(IWL_SDIO_DISABLE_SLEEP);
+
+clear_locks:
+	sdio_release_host(func);
+	mutex_unlock(&trans_sdio->target_access_mtx);
+	iwl_sdio_set_power(trans, false);
+
+	return ret;
+}
+
+/*
  * SDIO transport start HW.
  * This will enable the SDIO HW function and configure the SDIO AL.
  *
@@ -1177,7 +1263,6 @@ static int iwl_trans_sdio_start_hw(struct iwl_trans *trans)
 	int ret;
 	struct iwl_trans_sdio *trans_sdio = IWL_TRANS_GET_SDIO_TRANS(trans);
 	struct sdio_func *func = IWL_TRANS_SDIO_GET_FUNC(trans);
-	u32 hw_rev = trans->hw_rev;
 
 	iwl_sdio_set_power(trans, true);
 	mutex_lock(&trans_sdio->target_access_mtx);
@@ -1235,11 +1320,11 @@ static int iwl_trans_sdio_start_hw(struct iwl_trans *trans)
 				((trans->hw_rev << 2) & 0xc);
 
 		/*
-		 * Set SDTM CSR register to enable read optimization on 8000
-		 * family B-step
+		 * Set SDTM CSR register to disabled read optimization on 8000
+		 * family B-step, as the optimization currently causes issues
 		 */
 		if (CSR_HW_REV_STEP(trans->hw_rev) != SILICON_A_STEP) {
-			u32 val = 0x1;
+			u32 val = 0x0;
 
 			ret = iwl_sdio_ta_write(trans, CSR_SDTM_REG,
 						sizeof(u32), &val,
@@ -1249,19 +1334,6 @@ static int iwl_trans_sdio_start_hw(struct iwl_trans *trans)
 					"Failed to set SDIO to optimized reading\n");
 				goto release_hw;
 			}
-		} else {
-			/*
-			 * If we didn't have the HW rev when we entered the
-			 * function - fail now, so we can restart with the right
-			 * FW file, since if we're here and hw_rev==0 - the
-			 * A-step FW should be requested
-			 *
-			 * TODO:
-			 * Once there is only one supported step for 8000
-			 * family - delete this whole "else" part!
-			 */
-			if (!hw_rev)
-				goto release_hw;
 		}
 	}
 
@@ -1322,6 +1394,8 @@ static void iwl_trans_sdio_configure(struct iwl_trans *trans,
 	trans_sdio->rx_buf_size_8k = trans_cfg->rx_buf_size_8k;
 	trans_sdio->bc_table_dword = trans_cfg->bc_table_dword;
 
+	trans_sdio->sdio_adma_addr = trans_cfg->sdio_adma_addr;
+
 	trans_slv->cmd_queue = trans_cfg->cmd_queue;
 	trans_slv->cmd_fifo = trans_cfg->cmd_fifo;
 	trans_slv->command_names = trans_cfg->command_names;
@@ -2079,7 +2153,7 @@ static int iwl_sdio_register_plat_driver(struct iwl_trans *trans)
 	int ret;
 
 	/* we currently need the platform driver just for d0i3 */
-	if (d0i3_debug & IWL_D0I3_DBG_DISABLE)
+	if (iwlwifi_mod_params.d0i3_disable)
 		return 0;
 
 	/* verify we have only a single trans */
@@ -2100,9 +2174,9 @@ static int iwl_sdio_register_plat_driver(struct iwl_trans *trans)
 	return ret;
 }
 
-static void iwl_sdio_unregister_plat_driver(void)
+static void iwl_sdio_unregister_plat_driver(struct iwl_trans *trans)
 {
-	if (d0i3_debug & IWL_D0I3_DBG_DISABLE)
+	if (iwlwifi_mod_params.d0i3_disable)
 		return;
 
 	platform_driver_unregister(&iwlwifi_plat_driver);
@@ -2190,7 +2264,7 @@ free_tx:
 	mutex_unlock(&trans_sdio->target_access_mtx);
 	iwl_sdio_tx_free(trans);
 free_plat:
-	iwl_sdio_unregister_plat_driver();
+	iwl_sdio_unregister_plat_driver(trans);
 free_slv:
 	iwl_slv_free(trans);
 
@@ -2319,7 +2393,7 @@ static void iwl_trans_sdio_stop_device(struct iwl_trans *trans)
 		iwl_slv_tx_stop(trans);
 		iwl_sdio_tx_stop(trans);
 
-		iwl_sdio_unregister_plat_driver();
+		iwl_sdio_unregister_plat_driver(trans);
 		iwl_slv_free(trans);
 		iwl_sdio_tx_free(trans);
 	}
@@ -2387,6 +2461,45 @@ static int iwl_trans_sdio_test_mode_cmd(struct iwl_trans *trans, bool enable)
 	return ret;
 }
 
+static u32 iwl_trans_sdio_fh_regs_dump(struct iwl_trans *trans,
+				       struct iwl_fw_error_dump_data **data)
+{
+	struct sdio_func *func = IWL_TRANS_SDIO_GET_FUNC(trans);
+	u32 fh_regs_len = FH_MEM_UPPER_BOUND - FH_MEM_LOWER_BOUND;
+	unsigned long flags;
+	u32 offset, copy_size;
+	int ret;
+
+	if (!iwl_trans_grab_nic_access(trans, false, &flags))
+		return 0;
+	sdio_claim_host(func);
+
+	for (offset = 0; offset < fh_regs_len;
+	     offset += IWL_SDIO_MAX_PAYLOAD_SIZE) {
+		copy_size = min_t(u32,
+				  IWL_SDIO_MAX_PAYLOAD_SIZE,
+				  fh_regs_len - offset);
+		ret = iwl_sdio_ta_read(trans, FH_MEM_LOWER_BOUND + offset,
+				       copy_size,
+				       (void *)(*data)->data + offset,
+				       IWL_SDIO_TA_AC_DIRECT);
+		if (ret)
+			break;
+	}
+
+	sdio_release_host(func);
+	iwl_trans_release_nic_access(trans, &flags);
+
+	if (ret)
+		return 0;
+
+	(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_FH_REGS);
+	(*data)->len = cpu_to_le32(fh_regs_len);
+	*data = iwl_fw_error_next_data(*data);
+
+	return sizeof(**data) + fh_regs_len;
+}
+
 #define IWL_CSR_TO_DUMP (0x250)
 
 static u32 iwl_trans_sdio_dump_csr(struct iwl_trans *trans,
@@ -2427,6 +2540,9 @@ struct iwl_trans_dump_data *iwl_trans_sdio_dump_data(struct iwl_trans *trans)
 	/* CSR registers */
 	len += sizeof(*data) + IWL_CSR_TO_DUMP;
 
+	/* FH registers */
+	len += sizeof(*data) + (FH_MEM_UPPER_BOUND - FH_MEM_LOWER_BOUND);
+
 	/* host commands */
 	spin_lock_bh(&trans_slv->txq_lock);
 	if (!list_empty(&txq->waiting))
@@ -2504,6 +2620,7 @@ struct iwl_trans_dump_data *iwl_trans_sdio_dump_data(struct iwl_trans *trans)
 	spin_unlock_bh(&trans_slv->txq_lock);
 
 	len += iwl_trans_sdio_dump_csr(trans, &data);
+	len += iwl_trans_sdio_fh_regs_dump(trans, &data);
 	/* data is already pointing to the next section */
 
 	if (trans->dbg_dest_tlv && monitor_len) {
@@ -2666,10 +2783,12 @@ struct iwl_trans *iwl_trans_sdio_alloc(struct sdio_func *func,
 		goto free_rx_desc;
 	}
 
+	trans->d0i3_mode = IWL_D0I3_MODE_ON_IDLE;
+
 	IWL_DEBUG_INFO(trans,
 		 "Allocated SDIO trans: Device %s\n"
-		 "iwlwifi-SDIO: HW_REV 0x%x HW ID 0x%x\n",
-		 trans->hw_id_str, trans->hw_rev, trans->hw_id);
+		 "iwlwifi-SDIO: HW ID 0x%x\n",
+		 trans->hw_id_str, trans->hw_id);
 	return trans;
 
 free_rx_desc:
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.c
index 8bbfe5c..b4a8e9d 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.c
@@ -68,13 +68,10 @@
 #include "iwl-devtrace.h"
 #include "shared.h"
 #include "iwl-op-mode.h"
+#include "iwl-constants.h"
 /* FIXME: need to abstract out TX command (once we know what it looks like) */
 #include "mvm/fw-api.h"
 
-unsigned int d0i3_debug = IWL_D0I3_DBG_DISABLE;
-module_param(d0i3_debug, uint, S_IRUGO);
-MODULE_PARM_DESC(d0i3_debug, "D0i3 debug flags");
-
 /* FIXME: change values to be unique for each bus? */
 #define IWL_SLV_TX_Q_HIGH_THLD 320
 #define IWL_SLV_TX_Q_LOW_THLD 256
@@ -477,7 +474,7 @@ static int iwl_slv_fw_enter_d0i3(struct iwl_trans *trans)
 	struct iwl_trans_slv *trans_slv = IWL_TRANS_GET_SLV_TRANS(trans);
 	int ret;
 
-	if (d0i3_debug & IWL_D0I3_DBG_DISABLE)
+	if (test_bit(STATUS_FW_ERROR, &trans->status))
 		return 0;
 
 	set_bit(STATUS_TRANS_GOING_IDLE, &trans->status);
@@ -488,8 +485,11 @@ static int iwl_slv_fw_enter_d0i3(struct iwl_trans *trans)
 		IWL_DEBUG_RPM(trans, "aborting d0i3 entrance\n");
 		clear_bit(STATUS_TRANS_GOING_IDLE, &trans->status);
 		/* trigger policy to handle commands that could be skipped while
-		 * waiting d0i3 exit */
-		queue_work(trans_slv->policy_wq, &trans_slv->policy_trigger);
+		 * waiting d0i3 exit in case policy exists (meaning we got here
+		 * not from flush of rpm_suspend_work) */
+		if (trans_slv->policy_wq)
+			queue_work(trans_slv->policy_wq,
+				   &trans_slv->policy_trigger);
 		return 0;
 	}
 	if (ret)
@@ -505,18 +505,13 @@ static int iwl_slv_fw_enter_d0i3(struct iwl_trans *trans)
 	}
 
 	clear_bit(STATUS_TRANS_GOING_IDLE, &trans->status);
-	if (!(d0i3_debug & IWL_D0I3_DBG_KEEP_BUS) &&
+	if (!(IWL_D0I3_DEBUG & IWL_D0I3_DBG_KEEP_BUS) &&
 	    trans_slv->config.release_bus) {
 		ret = trans_slv->config.release_bus(trans);
 		if (ret)
 			goto err;
 	}
 
-#ifdef CONFIG_HAS_WAKELOCK
-	if (!(d0i3_debug & IWL_D0I3_DBG_KEEP_WAKE_LOCK))
-		wake_unlock(&IWL_TRANS_GET_SLV_TRANS(trans)->slv_wake_lock);
-#endif
-
 	return 0;
 err:
 	clear_bit(STATUS_TRANS_GOING_IDLE, &trans->status);
@@ -529,19 +524,11 @@ static int iwl_slv_fw_exit_d0i3(struct iwl_trans *trans)
 	struct iwl_trans_slv *trans_slv = IWL_TRANS_GET_SLV_TRANS(trans);
 	int ret;
 
-	if (d0i3_debug & IWL_D0I3_DBG_DISABLE)
-		return 0;
-
 	/* sometimes a D0i3 entry is not followed through */
 	if (!test_bit(STATUS_TRANS_IDLE, &trans->status))
 		return 0;
 
-#ifdef CONFIG_HAS_WAKELOCK
-	if (!(d0i3_debug & IWL_D0I3_DBG_KEEP_WAKE_LOCK))
-		wake_lock(&IWL_TRANS_GET_SLV_TRANS(trans)->slv_wake_lock);
-#endif
-
-	if (!(d0i3_debug & IWL_D0I3_DBG_KEEP_BUS) &&
+	if (!(IWL_D0I3_DEBUG & IWL_D0I3_DBG_KEEP_BUS) &&
 	    trans_slv->config.grab_bus) {
 		ret = trans_slv->config.grab_bus(trans);
 		if (ret)
@@ -572,6 +559,48 @@ err:
 	return ret;
 }
 
+static int iwl_slv_runtime_suspend(struct iwl_trans *trans)
+{
+	int ret;
+
+	if (iwlwifi_mod_params.d0i3_disable)
+		return 0;
+
+	if (trans->d0i3_mode == IWL_D0I3_MODE_ON_IDLE) {
+		ret = iwl_slv_fw_enter_d0i3(trans);
+		if (ret)
+			return ret;
+	}
+
+#ifdef CONFIG_HAS_WAKELOCK
+	if (trans->dbg_cfg.wakelock_mode == IWL_WAKELOCK_MODE_IDLE)
+		wake_unlock(&IWL_TRANS_GET_SLV_TRANS(trans)->slv_wake_lock);
+#endif
+
+	return 0;
+}
+
+static int iwl_slv_runtime_resume(struct iwl_trans *trans)
+{
+	int ret;
+
+	if (iwlwifi_mod_params.d0i3_disable)
+		return 0;
+
+	if (trans->d0i3_mode == IWL_D0I3_MODE_ON_IDLE) {
+		ret = iwl_slv_fw_exit_d0i3(trans);
+		if (ret)
+			return ret;
+	}
+
+#ifdef CONFIG_HAS_WAKELOCK
+	if (trans->dbg_cfg.wakelock_mode == IWL_WAKELOCK_MODE_IDLE)
+		wake_lock(&IWL_TRANS_GET_SLV_TRANS(trans)->slv_wake_lock);
+#endif
+
+	return 0;
+}
+
 struct iwl_slv_rpm_device {
 	struct iwl_trans *trans;
 	struct device dev;
@@ -593,7 +622,7 @@ static int iwl_slv_rpm_runtime_suspend(struct device *dev)
 	struct iwl_trans *trans = rpm_dev->trans;
 
 	IWL_DEBUG_RPM(trans, "entering d0i3\n");
-	iwl_slv_fw_enter_d0i3(trans);
+	iwl_slv_runtime_suspend(trans);
 	return 0;
 }
 
@@ -604,7 +633,7 @@ static int iwl_slv_rpm_runtime_resume(struct device *dev)
 	struct iwl_trans *trans = rpm_dev->trans;
 
 	IWL_DEBUG_RPM(trans, "exiting d0i3\n");
-	iwl_slv_fw_exit_d0i3(trans);
+	iwl_slv_runtime_resume(trans);
 	return 0;
 }
 
@@ -808,8 +837,8 @@ static int iwl_slv_mini_rpm_init(struct iwl_trans *trans)
 	struct slv_mini_rpm_config rpm_config;
 	struct iwl_trans_slv *trans_slv = IWL_TRANS_GET_SLV_TRANS(trans);
 
-	rpm_config.runtime_suspend = iwl_slv_fw_enter_d0i3;
-	rpm_config.runtime_resume = iwl_slv_fw_exit_d0i3;
+	rpm_config.runtime_suspend = iwl_slv_runtime_suspend;
+	rpm_config.runtime_resume = iwl_slv_runtime_resume;
 	rpm_config.autosuspend_delay = d0i3_entry_timeout_ms;
 
 	return mini_rpm_init(trans_slv, &rpm_config);
@@ -864,10 +893,11 @@ int iwl_slv_init(struct iwl_trans *trans)
 		       "iwlwifi_trans_slv_wakelock");
 	wake_lock_init(&trans_slv->data_wake_lock, WAKE_LOCK_SUSPEND,
 		       "iwlwifi_trans_data_wakelock");
-	wake_lock(&trans_slv->slv_wake_lock);
+	if (trans->dbg_cfg.wakelock_mode != IWL_WAKELOCK_MODE_OFF)
+		wake_lock(&trans_slv->slv_wake_lock);
 #endif
 
-	if (d0i3_debug & IWL_D0I3_DBG_DISABLE)
+	if (iwlwifi_mod_params.d0i3_disable)
 		IWL_DEBUG_RPM(trans, "D0i3 transition disabled\n");
 
 	return 0;
@@ -1498,8 +1528,9 @@ int iwl_trans_slv_tx_data_send(struct iwl_trans *trans, struct sk_buff *skb,
 
 	/* allow a burst of Tx to go through */
 #ifdef CONFIG_HAS_WAKELOCK
-	wake_lock_timeout(&trans_slv->data_wake_lock,
-			  msecs_to_jiffies(TRANS_DATA_WAKE_TIMEOUT_MS));
+	if (trans->dbg_cfg.wakelock_mode == IWL_WAKELOCK_MODE_IDLE)
+		wake_lock_timeout(&trans_slv->data_wake_lock,
+				msecs_to_jiffies(TRANS_DATA_WAKE_TIMEOUT_MS));
 #endif
 
 	queue_work(trans_slv->policy_wq, &trans_slv->policy_trigger);
@@ -1689,7 +1720,7 @@ int iwl_slv_rx_handle_dispatch(struct iwl_trans *trans,
 		if (ret || cmd_entry == NULL)
 			return ret;
 
-		if (!(d0i3_debug & IWL_D0I3_DBG_KEEP_BUS) &&
+		if (!(IWL_D0I3_DEBUG & IWL_D0I3_DBG_KEEP_BUS) &&
 		    (cmd_entry->hcmd_meta.flags & CMD_MAKE_TRANS_IDLE) &&
 		    trans_slv->config.rx_dma_idle)
 			trans_slv->config.rx_dma_idle(trans);
@@ -1720,12 +1751,13 @@ int iwl_slv_rx_handle_dispatch(struct iwl_trans *trans,
 			take_ref = false;
 		}
 
-		if (d0i3_debug & IWL_D0I3_DBG_IGNORE_RX)
+		if (IWL_D0I3_DEBUG & IWL_D0I3_DBG_IGNORE_RX)
 			take_ref = false;
 
 #ifdef CONFIG_HAS_WAKELOCK
 		/* let the packet propagate up the stack before suspend */
-		if (take_ref)
+		if (take_ref &&
+		    trans->dbg_cfg.wakelock_mode == IWL_WAKELOCK_MODE_IDLE)
 			wake_lock_timeout(&trans_slv->data_wake_lock,
 				  msecs_to_jiffies(TRANS_DATA_WAKE_TIMEOUT_MS));
 #endif
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.h
index 336b050..c48bda8 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/trans_slave/shared.h
@@ -348,14 +348,6 @@ struct iwl_slv_tx_queue {
 	atomic_t sent_count;
 };
 
-enum {
-	IWL_D0I3_DBG_DISABLE		= BIT(0),
-	IWL_D0I3_DBG_KEEP_BUS		= BIT(1),
-	IWL_D0I3_DBG_KEEP_WAKE_LOCK	= BIT(2),
-	IWL_D0I3_DBG_IGNORE_RX		= BIT(3),
-};
-extern unsigned int d0i3_debug;
-
 int iwl_slv_al_mem_pool_init(struct iwl_slv_al_mem_pool *pm, u16 num_elems);
 void iwl_slv_al_mem_pool_deinit(struct iwl_slv_al_mem_pool *pm);
 int iwl_slv_al_mem_pool_alloc(struct iwl_trans_slv_tx *slv_tx,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/utils.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/utils.c
index 01c79b5..4eb539b 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/utils.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/utils.c
@@ -126,66 +126,13 @@ static const char *desc_lookup(u32 num)
 	return advanced_lookup[i].name;
 }
 
-/*
- * Note: This structure is read from the device with IO accesses,
- * and the reading already does the endian conversion. As it is
- * read with u32-sized accesses, any members with a different size
- * need to be ordered correctly though!
- */
-struct iwl_error_event_table {
-	u32 valid;		/* (nonzero) valid, (0) log is empty */
-	u32 error_id;		/* type of error */
-	u32 pc;			/* program counter */
-	u32 blink1;		/* branch link */
-	u32 blink2;		/* branch link */
-	u32 ilink1;		/* interrupt link */
-	u32 ilink2;		/* interrupt link */
-	u32 data1;		/* error-specific data */
-	u32 data2;		/* error-specific data */
-	u32 data3;		/* error-specific data */
-	u32 bcon_time;		/* beacon timer */
-	u32 tsf_low;		/* network timestamp function timer */
-	u32 tsf_hi;		/* network timestamp function timer */
-	u32 gp1;		/* GP1 timer register */
-	u32 gp2;		/* GP2 timer register */
-	u32 gp3;		/* GP3 timer register */
-	u32 ucode_ver;		/* uCode version */
-	u32 hw_ver;		/* HW Silicon version */
-	u32 brd_ver;		/* HW board version */
-	u32 log_pc;		/* log program counter */
-	u32 frame_ptr;		/* frame pointer */
-	u32 stack_ptr;		/* stack pointer */
-	u32 hcmd;		/* last host command header */
-	u32 isr0;		/* isr status register LMPM_NIC_ISR0:
-				 * rxtx_flag */
-	u32 isr1;		/* isr status register LMPM_NIC_ISR1:
-				 * host_flag */
-	u32 isr2;		/* isr status register LMPM_NIC_ISR2:
-				 * enc_flag */
-	u32 isr3;		/* isr status register LMPM_NIC_ISR3:
-				 * time_flag */
-	u32 isr4;		/* isr status register LMPM_NIC_ISR4:
-				 * wico interrupt */
-	u32 isr_pref;		/* isr status register LMPM_NIC_PREF_STAT */
-	u32 wait_event;		/* wait event() caller address */
-	u32 l2p_control;	/* L2pControlField */
-	u32 l2p_duration;	/* L2pDurationField */
-	u32 l2p_mhvalid;	/* L2pMhValidBits */
-	u32 l2p_addr_match;	/* L2pAddrMatchStat */
-	u32 lmpm_pmg_sel;	/* indicate which clocks are turned on
-				 * (LMPM_PMG_SEL) */
-	u32 u_timestamp;	/* indicate when the date and time of the
-				 * compilation */
-	u32 flow_handler;	/* FH read/write pointers, RX credit */
-} __packed;
-
 #define ERROR_START_OFFSET  (1 * sizeof(u32))
 #define ERROR_ELEM_SIZE     (7 * sizeof(u32))
 
-void iwl_xvt_dump_nic_error_log(struct iwl_xvt *xvt)
+void iwl_xvt_get_nic_error_log(struct iwl_xvt *xvt,
+			       struct iwl_error_event_table *table)
 {
 	struct iwl_trans *trans = xvt->trans;
-	struct iwl_error_event_table table;
 	u32 base;
 
 	base = xvt->error_event_table;
@@ -197,41 +144,45 @@ void iwl_xvt_dump_nic_error_log(struct iwl_xvt *xvt)
 			base = xvt->fw->inst_errlog_ptr;
 	}
 
-	iwl_trans_read_mem_bytes(trans, base, &table, sizeof(table));
+	iwl_trans_read_mem_bytes(trans, base, table, sizeof(*table));
+}
 
-	IWL_ERR(xvt, "0x%08X | %-28s\n", table.error_id,
-		desc_lookup(table.error_id));
-	IWL_ERR(xvt, "0x%08X | uPc\n", table.pc);
-	IWL_ERR(xvt, "0x%08X | branchlink1\n", table.blink1);
-	IWL_ERR(xvt, "0x%08X | branchlink2\n", table.blink2);
-	IWL_ERR(xvt, "0x%08X | interruptlink1\n", table.ilink1);
-	IWL_ERR(xvt, "0x%08X | interruptlink2\n", table.ilink2);
-	IWL_ERR(xvt, "0x%08X | data1\n", table.data1);
-	IWL_ERR(xvt, "0x%08X | data2\n", table.data2);
-	IWL_ERR(xvt, "0x%08X | data3\n", table.data3);
-	IWL_ERR(xvt, "0x%08X | beacon time\n", table.bcon_time);
-	IWL_ERR(xvt, "0x%08X | tsf low\n", table.tsf_low);
-	IWL_ERR(xvt, "0x%08X | tsf hi\n", table.tsf_hi);
-	IWL_ERR(xvt, "0x%08X | time gp1\n", table.gp1);
-	IWL_ERR(xvt, "0x%08X | time gp2\n", table.gp2);
-	IWL_ERR(xvt, "0x%08X | time gp3\n", table.gp3);
-	IWL_ERR(xvt, "0x%08X | uCode version\n", table.ucode_ver);
-	IWL_ERR(xvt, "0x%08X | hw version\n", table.hw_ver);
-	IWL_ERR(xvt, "0x%08X | board version\n", table.brd_ver);
-	IWL_ERR(xvt, "0x%08X | hcmd\n", table.hcmd);
-	IWL_ERR(xvt, "0x%08X | isr0\n", table.isr0);
-	IWL_ERR(xvt, "0x%08X | isr1\n", table.isr1);
-	IWL_ERR(xvt, "0x%08X | isr2\n", table.isr2);
-	IWL_ERR(xvt, "0x%08X | isr3\n", table.isr3);
-	IWL_ERR(xvt, "0x%08X | isr4\n", table.isr4);
-	IWL_ERR(xvt, "0x%08X | isr_pref\n", table.isr_pref);
-	IWL_ERR(xvt, "0x%08X | wait_event\n", table.wait_event);
-	IWL_ERR(xvt, "0x%08X | l2p_control\n", table.l2p_control);
-	IWL_ERR(xvt, "0x%08X | l2p_duration\n", table.l2p_duration);
-	IWL_ERR(xvt, "0x%08X | l2p_mhvalid\n", table.l2p_mhvalid);
-	IWL_ERR(xvt, "0x%08X | l2p_addr_match\n", table.l2p_addr_match);
-	IWL_ERR(xvt, "0x%08X | lmpm_pmg_sel\n", table.lmpm_pmg_sel);
-	IWL_ERR(xvt, "0x%08X | timestamp\n", table.u_timestamp);
-	IWL_ERR(xvt, "0x%08X | flow_handler\n", table.flow_handler);
+void iwl_xvt_dump_nic_error_log(struct iwl_xvt *xvt,
+				struct iwl_error_event_table *table)
+{
+	IWL_ERR(xvt, "0x%08X | %-28s\n", table->error_id,
+		desc_lookup(table->error_id));
+	IWL_ERR(xvt, "0x%08X | uPc\n", table->pc);
+	IWL_ERR(xvt, "0x%08X | branchlink1\n", table->blink1);
+	IWL_ERR(xvt, "0x%08X | branchlink2\n", table->blink2);
+	IWL_ERR(xvt, "0x%08X | interruptlink1\n", table->ilink1);
+	IWL_ERR(xvt, "0x%08X | interruptlink2\n", table->ilink2);
+	IWL_ERR(xvt, "0x%08X | data1\n", table->data1);
+	IWL_ERR(xvt, "0x%08X | data2\n", table->data2);
+	IWL_ERR(xvt, "0x%08X | data3\n", table->data3);
+	IWL_ERR(xvt, "0x%08X | beacon time\n", table->bcon_time);
+	IWL_ERR(xvt, "0x%08X | tsf low\n", table->tsf_low);
+	IWL_ERR(xvt, "0x%08X | tsf hi\n", table->tsf_hi);
+	IWL_ERR(xvt, "0x%08X | time gp1\n", table->gp1);
+	IWL_ERR(xvt, "0x%08X | time gp2\n", table->gp2);
+	IWL_ERR(xvt, "0x%08X | time gp3\n", table->gp3);
+	IWL_ERR(xvt, "0x%08X | uCode version\n", table->ucode_ver);
+	IWL_ERR(xvt, "0x%08X | hw version\n", table->hw_ver);
+	IWL_ERR(xvt, "0x%08X | board version\n", table->brd_ver);
+	IWL_ERR(xvt, "0x%08X | hcmd\n", table->hcmd);
+	IWL_ERR(xvt, "0x%08X | isr0\n", table->isr0);
+	IWL_ERR(xvt, "0x%08X | isr1\n", table->isr1);
+	IWL_ERR(xvt, "0x%08X | isr2\n", table->isr2);
+	IWL_ERR(xvt, "0x%08X | isr3\n", table->isr3);
+	IWL_ERR(xvt, "0x%08X | isr4\n", table->isr4);
+	IWL_ERR(xvt, "0x%08X | isr_pref\n", table->isr_pref);
+	IWL_ERR(xvt, "0x%08X | wait_event\n", table->wait_event);
+	IWL_ERR(xvt, "0x%08X | l2p_control\n", table->l2p_control);
+	IWL_ERR(xvt, "0x%08X | l2p_duration\n", table->l2p_duration);
+	IWL_ERR(xvt, "0x%08X | l2p_mhvalid\n", table->l2p_mhvalid);
+	IWL_ERR(xvt, "0x%08X | l2p_addr_match\n", table->l2p_addr_match);
+	IWL_ERR(xvt, "0x%08X | lmpm_pmg_sel\n", table->lmpm_pmg_sel);
+	IWL_ERR(xvt, "0x%08X | timestamp\n", table->u_timestamp);
+	IWL_ERR(xvt, "0x%08X | flow_handler\n", table->flow_handler);
 }
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.c
index f248c02..d9c522d 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.c
@@ -261,17 +261,26 @@ static void iwl_xvt_nic_config(struct iwl_op_mode *op_mode)
 static void iwl_xvt_nic_error(struct iwl_op_mode *op_mode)
 {
 	struct iwl_xvt *xvt = IWL_OP_MODE_GET_XVT(op_mode);
+	struct iwl_error_event_table *p_table, table;
 	int err;
 
 	xvt->fw_error = true;
 	wake_up_interruptible(&xvt->mod_tx_wq);
 
-	iwl_xvt_dump_nic_error_log(xvt);
+	iwl_xvt_get_nic_error_log(xvt, &table);
 
-	err = iwl_xvt_user_send_notif(xvt, IWL_XVT_CMD_SEND_NIC_ERROR,
-				      NULL, 0, GFP_ATOMIC);
-	if (err)
-		IWL_WARN(xvt, "Error %d sending NIC error notification\n", err);
+	iwl_xvt_dump_nic_error_log(xvt, &table);
+
+	p_table = kmemdup(&table, sizeof(table), GFP_ATOMIC);
+	if (p_table) {
+		err = iwl_xvt_user_send_notif(xvt, IWL_XVT_CMD_SEND_NIC_ERROR,
+					      (void *)p_table, sizeof(*p_table),
+					      GFP_ATOMIC);
+		if (err)
+			IWL_WARN(xvt,
+				 "Error %d sending NIC error notification\n",
+				 err);
+	}
 }
 
 static bool iwl_xvt_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.h kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.h
index df7f895..6f61398 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/iwlwifi/xvt/xvt.h
@@ -93,6 +93,65 @@ struct iwl_sw_stack_config {
 	struct iwl_phy_cfg_cmd fw_calib_cmd_cfg[IWL_UCODE_TYPE_MAX];
 };
 
+/* Note: This structure is read from the device with IO accesses,
+ * and the reading already does the endian conversion. As it is
+ * read with u32-sized accesses, any members with a different size
+ * need to be ordered correctly though!
+ */
+struct iwl_error_event_table {
+	u32 valid;		/* (nonzero) valid, (0) log is empty */
+	u32 error_id;		/* type of error */
+	u32 pc;			/* program counter */
+	u32 blink1;		/* branch link */
+	u32 blink2;		/* branch link */
+	u32 ilink1;		/* interrupt link */
+	u32 ilink2;		/* interrupt link */
+	u32 data1;		/* error-specific data */
+	u32 data2;		/* error-specific data */
+	u32 data3;		/* error-specific data */
+	u32 bcon_time;		/* beacon timer */
+	u32 tsf_low;		/* network timestamp function timer */
+	u32 tsf_hi;		/* network timestamp function timer */
+	u32 gp1;		/* GP1 timer register */
+	u32 gp2;		/* GP2 timer register */
+	u32 gp3;		/* GP3 timer register */
+	u32 ucode_ver;		/* uCode version */
+	u32 hw_ver;		/* HW Silicon version */
+	u32 brd_ver;		/* HW board version */
+	u32 log_pc;		/* log program counter */
+	u32 frame_ptr;		/* frame pointer */
+	u32 stack_ptr;		/* stack pointer */
+	u32 hcmd;		/* last host command header */
+	u32 isr0;		/* isr status register LMPM_NIC_ISR0:
+				 * rxtx_flag
+				 */
+	u32 isr1;		/* isr status register LMPM_NIC_ISR1:
+				 * host_flag
+				 */
+	u32 isr2;		/* isr status register LMPM_NIC_ISR2:
+				 * enc_flag
+				 */
+	u32 isr3;		/* isr status register LMPM_NIC_ISR3:
+				 * time_flag
+				 */
+	u32 isr4;		/* isr status register LMPM_NIC_ISR4:
+				 * wico interrupt
+				 */
+	u32 isr_pref;		/* isr status register LMPM_NIC_PREF_STAT */
+	u32 wait_event;		/* wait event() caller address */
+	u32 l2p_control;	/* L2pControlField */
+	u32 l2p_duration;	/* L2pDurationField */
+	u32 l2p_mhvalid;	/* L2pMhValidBits */
+	u32 l2p_addr_match;	/* L2pAddrMatchStat */
+	u32 lmpm_pmg_sel;	/* indicate which clocks are turned on
+				 * (LMPM_PMG_SEL)
+				 */
+	u32 u_timestamp;	/* indicate when the date and time of the
+				 * compilation
+				 */
+	u32 flow_handler;	/* FH read/write pointers, RX credit */
+} __packed;
+
 /**
  * struct iwl_xvt - the xvt op_mode
  *
@@ -149,7 +208,10 @@ int __must_check iwl_xvt_send_cmd_pdu(struct iwl_xvt *xvt, u8 id,
 				      u32 flags, u16 len, const void *data);
 
 /* Utils */
-void iwl_xvt_dump_nic_error_log(struct iwl_xvt *xvt);
+void iwl_xvt_get_nic_error_log(struct iwl_xvt *xvt,
+			       struct iwl_error_event_table *table);
+void iwl_xvt_dump_nic_error_log(struct iwl_xvt *xvt,
+				struct iwl_error_event_table *table);
 
 /* User interface */
 int iwl_xvt_user_cmd_execute(struct iwl_op_mode *op_mode, u32 cmd,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/mac80211_hwsim.c kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/mac80211_hwsim.c
index 0f66952..32f61e7 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/mac80211_hwsim.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/drivers/net/wireless/mac80211_hwsim.c
@@ -2388,7 +2388,6 @@ static int mac80211_hwsim_new_radio(struct genl_info *info,
 		sband->vht_cap.cap =
 			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |
 			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |
-			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ |
 			IEEE80211_VHT_CAP_RXLDPC |
 			IEEE80211_VHT_CAP_SHORT_GI_80 |
 			IEEE80211_VHT_CAP_SHORT_GI_160 |
@@ -2543,7 +2542,9 @@ static int mac80211_hwsim_get_radio(struct sk_buff *skb,
 	if (cb)
 		genl_dump_check_consistent(cb, hdr, &hwsim_genl_family);
 
-	param.reg_alpha2 = data->alpha2;
+	if (data->alpha2[0] && data->alpha2[1])
+		param.reg_alpha2 = data->alpha2;
+
 	param.reg_strict = !!(data->hw->wiphy->regulatory_flags &
 					REGULATORY_STRICT_REG);
 	param.p2p_device = !!(data->hw->wiphy->interface_modes &
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/cfg80211.h kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/cfg80211.h
index f624b8a..a209976 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/cfg80211.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/cfg80211.h
@@ -1516,6 +1516,10 @@ struct cfg80211_match_set {
  * @mac_addr_mask: MAC address mask used with randomisation, bits that
  *	are 0 in the mask should be randomised, bits that are 1 should
  *	be taken from the @mac_addr
+ * @delay: delay in seconds to use before starting the first scan
+ *	cycle.  The driver may ignore this parameter and start
+ *	immediately (or at any other time), if this feature is not
+ *	supported.
  */
 struct cfg80211_sched_scan_request {
 	struct cfg80211_ssid *ssids;
@@ -1529,6 +1533,7 @@ struct cfg80211_sched_scan_request {
 	struct cfg80211_match_set *match_sets;
 	int n_match_sets;
 	s32 min_rssi_thold;
+	u32 delay;
 
 	u8 mac_addr[ETH_ALEN] __aligned(2);
 	u8 mac_addr_mask[ETH_ALEN] __aligned(2);
@@ -3182,23 +3187,6 @@ struct wiphy {
 	void (*reg_notifier)(struct wiphy *wiphy,
 			     struct regulatory_request *request);
 
-	/*
-	 * Indicates this wiphy can provide regulatory information.
-	 * Must be set before the wiphy is registered. Only the first
-	 * wiphy with this callback will be called to provide a regdomain
-	 * on country-code changes. The alpha2 in the returned regdomain
-	 * information can be different from the one given via argument,
-	 * if the argument contains the "99" alpha2, meaning unknown.
-	 * If an ERR_PTR is returned the regulatory core will consult other
-	 * sources for the regdomain info (internal regdb and CRDA).
-	 * Returning NULL will cause the regdomain to remain the same.
-	 * The callee will return a struct allocated with kmalloc(). After
-	 * the struct is returned, the regulatory core is responsible
-	 * for freeing it.
-	 */
-	struct ieee80211_regdomain * (*get_regd)(struct wiphy *wiphy,
-						 const char *alpha2);
-
 	/* fields below are read-only, assigned by cfg80211 */
 
 	const struct ieee80211_regdomain __rcu *regd;
@@ -3805,19 +3793,13 @@ const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
  */
 
 /**
- * regulatory_hint_force_policy - driver hint - force regdom update policy
- *
- * Driver hint to the wireless core a regulatory domain, and force
- * intersection/override of the regulation domain.
- *
+ * regulatory_hint - driver hint to the wireless core a regulatory domain
  * @wiphy: the wireless device giving the hint (used only for reporting
  *	conflicts)
  * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
- *	should be in. If @rd is set this should be NULL. Note that if you
- *	set this to NULL you should still set rd->alpha2 to some accepted
- *	alpha2.
- * @intersect_policy: driver hint's intersect policy, do/don't force
- *	intersect/override  of the regulation domain.
+ * 	should be in. If @rd is set this should be NULL. Note that if you
+ * 	set this to NULL you should still set rd->alpha2 to some accepted
+ * 	alpha2.
  *
  * Wireless drivers can use this function to hint to the wireless core
  * what it believes should be the current regulatory domain by
@@ -3830,47 +3812,26 @@ const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
  * For cfg80211 drivers this means you must first use wiphy_register(),
  * for mac80211 drivers you must first use ieee80211_register_hw().
  *
- * The driver can force to cause intersection with the existing regulation
- * domain, or force to overried it.
- *
  * Drivers should check the return value, its possible you can get
  * an -ENOMEM.
  *
  * Return: 0 on success. -ENOMEM.
  */
-int regulatory_hint_force_policy(struct wiphy *wiphy, const char *alpha2,
-				 enum driver_reg_hint_type intersect_policy);
+int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
 
 /**
- * regulatory_hint - driver hint to the wireless core a regulatory domain
- * @wiphy: the wireless device giving the hint (used only for reporting
- *	conflicts)
- * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
- * 	should be in. If @rd is set this should be NULL. Note that if you
- * 	set this to NULL you should still set rd->alpha2 to some accepted
- * 	alpha2.
- *
- * Wireless drivers can use this function to hint to the wireless core
- * what it believes should be the current regulatory domain by
- * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
- * domain should be in or by providing a completely build regulatory domain.
- * If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
- * for a regulatory domain structure for the respective country.
- *
- * The wiphy must have been registered to cfg80211 prior to this call.
- * For cfg80211 drivers this means you must first use wiphy_register(),
- * for mac80211 drivers you must first use ieee80211_register_hw().
+ * regulatory_set_wiphy_regd - set regdom info for self managed drivers
+ * @wiphy: the wireless device we want to process the regulatory domain on
+ * @rd: the regulatory domain informatoin to use for this wiphy
  *
- * Drivers should check the return value, its possible you can get
- * an -ENOMEM.
+ * Set the regulatory domain information for self-managed wiphys, only they
+ * may use this function. See %REGULATORY_WIPHY_SELF_MANAGED for more
+ * information.
  *
- * Return: 0 on success. -ENOMEM.
+ * Return: 0 on success. -EINVAL, -EPERM
  */
-static inline int regulatory_hint(struct wiphy *wiphy, const char *alpha2)
-{
-	return regulatory_hint_force_policy(wiphy, alpha2,
-					    DRIVER_REG_HINT_REGULAR);
-}
+int regulatory_set_wiphy_regd(struct wiphy *wiphy,
+			      struct ieee80211_regdomain *rd);
 
 /**
  * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain
@@ -4708,33 +4669,6 @@ void cfg80211_cqm_rssi_notify(struct net_device *dev,
 			      gfp_t gfp);
 
 /**
- * cfg80211_radar_event - radar detection event
- * @wiphy: the wiphy
- * @chandef: chandef for the current channel
- * @gfp: context flags
- *
- * This function is called when a radar is detected on the current chanenl.
- */
-void cfg80211_radar_event(struct wiphy *wiphy,
-			  struct cfg80211_chan_def *chandef, gfp_t gfp);
-
-/**
- * cfg80211_cac_event - Channel availability check (CAC) event
- * @netdev: network device
- * @chandef: chandef for the current channel
- * @event: type of event
- * @gfp: context flags
- *
- * This function is called when a Channel availability check (CAC) is finished
- * or aborted. This must be called to notify the completion of a CAC process,
- * also by full-MAC drivers.
- */
-void cfg80211_cac_event(struct net_device *netdev,
-			const struct cfg80211_chan_def *chandef,
-			enum nl80211_radar_event event, gfp_t gfp);
-
-
-/**
  * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer
  * @dev: network device
  * @peer: peer's MAC address
@@ -4762,6 +4696,42 @@ void cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,
 			     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);
 
 /**
+ * cfg80211_cqm_beacon_loss_notify - beacon loss event
+ * @dev: network device
+ * @gfp: context flags
+ *
+ * Notify userspace about beacon loss from the connected AP.
+ */
+void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);
+
+/**
+ * cfg80211_radar_event - radar detection event
+ * @wiphy: the wiphy
+ * @chandef: chandef for the current channel
+ * @gfp: context flags
+ *
+ * This function is called when a radar is detected on the current chanenl.
+ */
+void cfg80211_radar_event(struct wiphy *wiphy,
+			  struct cfg80211_chan_def *chandef, gfp_t gfp);
+
+/**
+ * cfg80211_cac_event - Channel availability check (CAC) event
+ * @netdev: network device
+ * @chandef: chandef for the current channel
+ * @event: type of event
+ * @gfp: context flags
+ *
+ * This function is called when a Channel availability check (CAC) is finished
+ * or aborted. This must be called to notify the completion of a CAC process,
+ * also by full-MAC drivers.
+ */
+void cfg80211_cac_event(struct net_device *netdev,
+			const struct cfg80211_chan_def *chandef,
+			enum nl80211_radar_event event, gfp_t gfp);
+
+
+/**
  * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
  * @dev: network device
  * @bssid: BSSID of AP (to avoid races)
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/mac80211.h kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/mac80211.h
index 86b4adb..abc35e8 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/mac80211.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/mac80211.h
@@ -3640,6 +3640,26 @@ void ieee80211_tx_status(struct ieee80211_hw *hw,
 			 struct sk_buff *skb);
 
 /**
+ * ieee80211_tx_status_noskb - transmit status callback without skb
+ *
+ * This function can be used as a replacement for ieee80211_tx_status
+ * in drivers that cannot reliably map tx status information back to
+ * specific skbs.
+ *
+ * Calls to this function for a single hardware must be synchronized
+ * against each other. Calls to this function, ieee80211_tx_status_ni()
+ * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.
+ *
+ * @hw: the hardware the frame was transmitted by
+ * @sta: the receiver station to which this packet is sent
+ *	(NULL for multicast packets)
+ * @info: tx status information
+ */
+void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
+			       struct ieee80211_sta *sta,
+			       struct ieee80211_tx_info *info);
+
+/**
  * ieee80211_tx_status_ni - transmit status callback (in process context)
  *
  * Like ieee80211_tx_status() but can be called in process context.
@@ -4693,6 +4713,14 @@ void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
 			       gfp_t gfp);
 
 /**
+ * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @gfp: context flags
+ */
+void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);
+
+/**
  * ieee80211_radar_detected - inform that a radar was detected
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
@@ -4850,6 +4878,10 @@ struct rate_control_ops {
 	void (*free_sta)(void *priv, struct ieee80211_sta *sta,
 			 void *priv_sta);
 
+	void (*tx_status_noskb)(void *priv,
+				struct ieee80211_supported_band *sband,
+				struct ieee80211_sta *sta, void *priv_sta,
+				struct ieee80211_tx_info *info);
 	void (*tx_status)(void *priv, struct ieee80211_supported_band *sband,
 			  struct ieee80211_sta *sta, void *priv_sta,
 			  struct sk_buff *skb);
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/regulatory.h kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/regulatory.h
index 7bb72ed..88f93aa 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/regulatory.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/include/net/regulatory.h
@@ -34,22 +34,6 @@ enum environment_cap {
 };
 
 /**
- * enum driver_reg_driver_type - type of driver regulatory hint
- *
- * classifies if the regdomain should be overrided or intersected upon new
- * reg updates.
- *
- * @DRIVER_REG_HINT_REGULAR: intersect/overwrite in the usual way.
- * @DRIVER_REG_HINT_OVERRIDE: always override regdomain.
- * @DRIVER_REG_HINT_INTERSECT: always intersect regdomain.
- */
-enum driver_reg_hint_type {
-	DRIVER_REG_HINT_REGULAR,
-	DRIVER_REG_HINT_OVERRIDE,
-	DRIVER_REG_HINT_INTERSECT,
-};
-
-/**
  * struct regulatory_request - used to keep track of regulatory requests
  *
  * @rcu_head: RCU head struct used to free the request
@@ -74,9 +58,6 @@ enum driver_reg_hint_type {
  *	%NL80211_REGDOM_SET_BY_USER, this classifies the type
  *	of hint passed. This could be any of the %NL80211_USER_REG_HINT_*
  *	types.
- * @driver_reg_hint_type: if the @initiator was driver, this classifies
- *	if the regdomain should be overrided or intersected upon new reg
- *	updates.
  * @intersect: indicates whether the wireless core should intersect
  *	the requested regulatory domain with the presently set regulatory
  *	domain.
@@ -99,7 +80,6 @@ struct regulatory_request {
 	int wiphy_idx;
 	enum nl80211_reg_initiator initiator;
 	enum nl80211_user_reg_hint_type user_reg_hint_type;
-	enum driver_reg_hint_type driver_reg_hint_type;
 	char alpha2[2];
 	enum nl80211_dfs_regions dfs_region;
 	bool intersect;
@@ -159,6 +139,35 @@ struct regulatory_request {
  *      otherwise initiating radiation is not allowed. This will enable the
  *      relaxations enabled under the CFG80211_REG_RELAX_NO_IR configuration
  *      option
+ * @REGULATORY_IGNORE_STALE_KICKOFF: the regulatory core will _not_ make sure
+ *	all interfaces on this wiphy reside on allowed channels. If this flag
+ *	is not set, upon a regdomain change, the interfaces are given a grace
+ *	period (currently 60 seconds) to disconnect or move to an allowed
+ *	channel. Interfaces on forbidden channels are forcibly disconnected.
+ *	Currently these types of interfaces are supported for enforcement:
+ *	NL80211_IFTYPE_ADHOC, NL80211_IFTYPE_STATION, NL80211_IFTYPE_AP,
+ *	NL80211_IFTYPE_AP_VLAN, NL80211_IFTYPE_MONITOR,
+ *	NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_P2P_GO,
+ *	NL80211_IFTYPE_P2P_DEVICE. The flag will be set by default if a device
+ *	includes any modes unsupported for enforcement checking.
+ * @REGULATORY_WIPHY_SELF_MANAGED: for devices that employ wiphy-specific
+ *	regdom management. These devices will ignore all regdom changes not
+ *	originating from their own wiphy.
+ *	A self-managed wiphys only employs regulatory information obtained from
+ *	the FW and driver and does not use other cfg80211 sources like
+ *	beacon-hints, country-code IEs and hints from other devices on the same
+ *	system. Conversely, a self-managed wiphy does not share its regulatory
+ *	hints with other devices in the system. If a system contains several
+ *	devices, one or more of which are self-managed, there might be
+ *	contradictory regulatory settings between them. Usage of flag is
+ *	generally discouraged. Only use it if the FW/driver is incompatible
+ *	with non-locally originated hints.
+ *	This flag is incompatible with the flags: %REGULATORY_CUSTOM_REG,
+ *	%REGULATORY_STRICT_REG, %REGULATORY_COUNTRY_IE_FOLLOW_POWER,
+ *	%REGULATORY_COUNTRY_IE_IGNORE and %REGULATORY_DISABLE_BEACON_HINTS.
+ *	Mixing any of the above flags with this flag will result in a failure
+ *	to register the wiphy. This flag implies
+ *	%REGULATORY_DISABLE_BEACON_HINTS and %REGULATORY_COUNTRY_IE_IGNORE.
  */
 enum ieee80211_regulatory_flags {
 	REGULATORY_CUSTOM_REG			= BIT(0),
@@ -167,6 +176,8 @@ enum ieee80211_regulatory_flags {
 	REGULATORY_COUNTRY_IE_FOLLOW_POWER	= BIT(3),
 	REGULATORY_COUNTRY_IE_IGNORE		= BIT(4),
 	REGULATORY_ENABLE_RELAX_NO_IR           = BIT(5),
+	REGULATORY_IGNORE_STALE_KICKOFF         = BIT(6),
+	REGULATORY_WIPHY_SELF_MANAGED		= BIT(7),
 };
 
 struct ieee80211_freq_range {
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/include/uapi/linux/nl80211.h kernel/gmin/uefi/modules/wlan/iwlwifi/include/uapi/linux/nl80211.h
index 3aa3aac..8d0566c 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/include/uapi/linux/nl80211.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/include/uapi/linux/nl80211.h
@@ -252,7 +252,16 @@
  *	%NL80211_ATTR_IFINDEX.
  *
  * @NL80211_CMD_GET_REG: ask the wireless core to send us its currently set
- * 	regulatory domain.
+ *	regulatory domain. If %NL80211_ATTR_WIPHY is specified and the device
+ *	has a private regulatory domain, it will be returned. Otherwise, the
+ *	global regdomain will be returned.
+ *	A device will have a private regulatory domain if it uses the
+ *	regulatory_hint() API. Even when a private regdomain is used the channel
+ *	information will still be mended according to further hints from
+ *	the regulatory core to help with compliance.
+ *	If a wiphy is self-managed (%NL80211_ATTR_WIPHY_SELF_MANAGED_REG), then
+ *	its private regdomain is the only valid one for it. The regulatory
+ *	core is not used to help with compliance in this case.
  * @NL80211_CMD_SET_REG: Set current regulatory domain. CRDA sends this command
  *	after being queried by the kernel. CRDA replies by sending a regulatory
  *	domain structure which consists of %NL80211_ATTR_REG_ALPHA set to our
@@ -306,7 +315,9 @@
  *	if passed, define which channels should be scanned; if not
  *	passed, all channels allowed for the current regulatory domain
  *	are used.  Extra IEs can also be passed from the userspace by
- *	using the %NL80211_ATTR_IE attribute.
+ *	using the %NL80211_ATTR_IE attribute.  The first cycle of the
+ *	scheduled scan can be delayed by %NL80211_ATTR_SCHED_SCAN_DELAY
+ *	is supplied.
  * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan. Returns -ENOENT if
  *	scheduled scan is not running. The caller may assume that as soon
  *	as the call returns, it is safe to start a new scheduled scan again.
@@ -774,6 +785,10 @@
  *	peer given by %NL80211_ATTR_MAC. Both peers must be on the base channel
  *	when this command completes.
  *
+ * @NL80211_CMD_WIPHY_REG_CHANGE: Similar to %NL80211_CMD_REG_CHANGE, but used
+ *	as an event to indicate changes for devices with wiphy-specific regdom
+ *	management.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -958,6 +973,8 @@ enum nl80211_commands {
 	NL80211_CMD_TDLS_CHANNEL_SWITCH,
 	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,
 
+	NL80211_CMD_WIPHY_REG_CHANGE,
+
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -1690,6 +1707,14 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_MAC_MASK: MAC address mask
  *
+ * @NL80211_ATTR_WIPHY_SELF_MANAGED_REG: flag attribute indicating this device
+ *	is self-managing its regulatory information and any regulatory domain
+ *	obtained from it is coming from the device's wiphy and not the global
+ *	cfg80211 regdomain.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_DELAY: delay before a scheduled scan (or a
+ *	WoWLAN net-detect scan) is started, u32 in seconds.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -2047,7 +2072,12 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_MAC_MASK,
 
+	NL80211_ATTR_WIPHY_SELF_MANAGED_REG,
+
 	NL80211_ATTR_REG_INDOOR,
+
+	NL80211_ATTR_SCHED_SCAN_DELAY,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -3454,6 +3484,8 @@ enum nl80211_ps_state {
  *	interval in which %NL80211_ATTR_CQM_TXE_PKTS and
  *	%NL80211_ATTR_CQM_TXE_RATE must be satisfied before generating an
  *	%NL80211_CMD_NOTIFY_CQM. Set to 0 to turn off TX error reporting.
+ * @NL80211_ATTR_CQM_BEACON_LOSS_EVENT: flag attribute that's set in a beacon
+ *	loss event
  * @__NL80211_ATTR_CQM_AFTER_LAST: internal
  * @NL80211_ATTR_CQM_MAX: highest key attribute
  */
@@ -3466,6 +3498,7 @@ enum nl80211_attr_cqm {
 	NL80211_ATTR_CQM_TXE_RATE,
 	NL80211_ATTR_CQM_TXE_PKTS,
 	NL80211_ATTR_CQM_TXE_INTVL,
+	NL80211_ATTR_CQM_BEACON_LOSS_EVENT,
 
 	/* keep last */
 	__NL80211_ATTR_CQM_AFTER_LAST,
@@ -3478,9 +3511,7 @@ enum nl80211_attr_cqm {
  *      configured threshold
  * @NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH: The RSSI is higher than the
  *      configured threshold
- * @NL80211_CQM_RSSI_BEACON_LOSS_EVENT: The device experienced beacon loss.
- *	(Note that deauth/disassoc will still follow if the AP is not
- *	available. This event might get used as roaming event, etc.)
+ * @NL80211_CQM_RSSI_BEACON_LOSS_EVENT: (reserved, never sent)
  */
 enum nl80211_cqm_rssi_threshold_event {
 	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
@@ -3567,6 +3598,8 @@ struct nl80211_pattern_support {
  * @NL80211_WOWLAN_TRIG_ANY: wake up on any activity, do not really put
  *	the chip into a special state -- works best with chips that have
  *	support for low-power operation already (flag)
+ *	Note that this mode is incompatible with all of the others, if
+ *	any others are even supported by the device.
  * @NL80211_WOWLAN_TRIG_DISCONNECT: wake up on disconnect, the way disconnect
  *	is detected is implementation-specific (flag)
  * @NL80211_WOWLAN_TRIG_MAGIC_PKT: wake up on magic packet (6x 0xff, followed
@@ -3623,9 +3656,12 @@ struct nl80211_pattern_support {
  * @NL80211_WOWLAN_TRIG_NET_DETECT: wake up when a configured network
  *	is detected.  This is a nested attribute that contains the
  *	same attributes used with @NL80211_CMD_START_SCHED_SCAN.  It
- *	specifies how the scan is performed (e.g. the interval and the
- *	channels to scan) as well as the scan results that will
- *	trigger a wake (i.e. the matchsets).
+ *	specifies how the scan is performed (e.g. the interval, the
+ *	channels to scan and the initial delay) as well as the scan
+ *	results that will trigger a wake (i.e. the matchsets).  This
+ *	attribute is also sent in a response to
+ *	@NL80211_CMD_GET_WIPHY, indicating the number of match sets
+ *	supported by the driver (u32).
  * @NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS: nested attribute
  *	containing an array with information about what triggered the
  *	wake up.  If no elements are present in the array, it means
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/ieee80211_i.h kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/ieee80211_i.h
index aabeadb..3d10314 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/ieee80211_i.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/ieee80211_i.h
@@ -1749,6 +1749,7 @@ ieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,
 				    struct ieee80211_supported_band *sband,
 				    const struct ieee80211_vht_cap *vht_cap_ie,
 				    struct sta_info *sta);
+enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta);
 enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta);
 void ieee80211_sta_set_rx_nss(struct sta_info *sta);
 u32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/key.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/key.c
index 434a91a..0bb7038 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/key.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/key.c
@@ -656,7 +656,7 @@ void ieee80211_free_sta_keys(struct ieee80211_local *local,
 	int i;
 
 	mutex_lock(&local->key_mtx);
-	for (i = 0; i < NUM_DEFAULT_KEYS; i++) {
+	for (i = 0; i < ARRAY_SIZE(sta->gtk); i++) {
 		key = key_mtx_dereference(local, sta->gtk[i]);
 		if (!key)
 			continue;
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/mlme.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/mlme.c
index 23d2d26..6449ed3 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/mlme.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/mlme.c
@@ -157,14 +157,18 @@ ieee80211_determine_chantype(struct ieee80211_sub_if_data *sdata,
 {
 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 	struct cfg80211_chan_def vht_chandef;
+	struct ieee80211_sta_ht_cap sta_ht_cap;
 	u32 ht_cfreq, ret;
 
+	memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
+	ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
+
 	chandef->chan = channel;
 	chandef->width = NL80211_CHAN_WIDTH_20_NOHT;
 	chandef->center_freq1 = channel->center_freq;
 	chandef->center_freq2 = 0;
 
-	if (!ht_cap || !ht_oper || !sband->ht_cap.ht_supported) {
+	if (!ht_cap || !ht_oper || !sta_ht_cap.ht_supported) {
 		ret = IEEE80211_STA_DISABLE_HT | IEEE80211_STA_DISABLE_VHT;
 		goto out;
 	}
@@ -174,6 +178,7 @@ ieee80211_determine_chantype(struct ieee80211_sub_if_data *sdata,
 	if (!(ht_cap->cap_info &
 	      cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH_20_40))) {
 		ret = IEEE80211_STA_DISABLE_40MHZ;
+		vht_chandef = *chandef;
 		goto out;
 	}
 
@@ -197,7 +202,7 @@ ieee80211_determine_chantype(struct ieee80211_sub_if_data *sdata,
 	}
 
 	/* check 40 MHz support, if we have it */
-	if (sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) {
+	if (sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) {
 		switch (ht_oper->ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {
 		case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
 			chandef->width = NL80211_CHAN_WIDTH_40;
@@ -552,13 +557,17 @@ static void ieee80211_add_vht_ie(struct ieee80211_sub_if_data *sdata,
 	cap = vht_cap.cap;
 
 	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_80P80MHZ) {
-		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
-		cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
+		u32 bw = cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
+
+		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
+		if (bw == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ ||
+		    bw == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)
+			cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
 	}
 
 	if (sdata->u.mgd.flags & IEEE80211_STA_DISABLE_160MHZ) {
 		cap &= ~IEEE80211_VHT_CAP_SHORT_GI_160;
-		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
+		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
 	}
 
 	/*
@@ -1049,8 +1058,6 @@ static void ieee80211_chswitch_post_beacon(struct ieee80211_sub_if_data *sdata)
 		sdata->csa_block_tx = false;
 	}
 
-	cfg80211_ch_switch_notify(sdata->dev, &sdata->reserved_chandef);
-
 	sdata->vif.csa_active = false;
 	ifmgd->csa_waiting_bcn = false;
 
@@ -2274,9 +2281,7 @@ static void ieee80211_mgd_probe_ap(struct ieee80211_sub_if_data *sdata,
 				     "detected beacon loss from AP (missed %d beacons) - probing\n",
 				     beacon_loss_count);
 
-		ieee80211_cqm_rssi_notify(&sdata->vif,
-					  NL80211_CQM_RSSI_BEACON_LOSS_EVENT,
-					  GFP_KERNEL);
+		ieee80211_cqm_beacon_loss_notify(&sdata->vif, GFP_KERNEL);
 	}
 
 	/*
@@ -4205,9 +4210,13 @@ static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 	struct ieee80211_bss *bss = (void *)cbss->priv;
 	struct sta_info *new_sta = NULL;
-	bool have_sta = false;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_sta_ht_cap sta_ht_cap;
+	bool have_sta = false, is_override = false;
 	int err;
 
+	sband = local->hw.wiphy->bands[cbss->channel->band];
+
 	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data))
 		return -EINVAL;
 
@@ -4222,25 +4231,32 @@ static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
 		if (!new_sta)
 			return -ENOMEM;
 	}
+
+	memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
+	ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
+
+	is_override = (sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) !=
+		      (sband->ht_cap.cap &
+		       IEEE80211_HT_CAP_SUP_WIDTH_20_40);
+
+	if (new_sta || is_override) {
+		err = ieee80211_prep_channel(sdata, cbss);
+		if (err) {
+			if (new_sta)
+				sta_info_free(local, new_sta);
+			return -EINVAL;
+		}
+	}
+
 	if (new_sta) {
 		u32 rates = 0, basic_rates = 0;
 		bool have_higher_than_11mbit;
 		int min_rate = INT_MAX, min_rate_index = -1;
 		struct ieee80211_chanctx_conf *chanctx_conf;
-		struct ieee80211_supported_band *sband;
 		const struct cfg80211_bss_ies *ies;
-		int shift;
+		int shift = ieee80211_vif_get_shift(&sdata->vif);
 		u32 rate_flags;
 
-		sband = local->hw.wiphy->bands[cbss->channel->band];
-
-		err = ieee80211_prep_channel(sdata, cbss);
-		if (err) {
-			sta_info_free(local, new_sta);
-			return -EINVAL;
-		}
-		shift = ieee80211_vif_get_shift(&sdata->vif);
-
 		rcu_read_lock();
 		chanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);
 		if (WARN_ON(!chanctx_conf)) {
@@ -4914,3 +4930,13 @@ void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
 	cfg80211_cqm_rssi_notify(sdata->dev, rssi_event, gfp);
 }
 EXPORT_SYMBOL(ieee80211_cqm_rssi_notify);
+
+void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	trace_api_cqm_beacon_loss_notify(sdata->local, sdata);
+
+	cfg80211_cqm_beacon_loss_notify(sdata->dev, gfp);
+}
+EXPORT_SYMBOL(ieee80211_cqm_beacon_loss_notify);
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.c
index 0574458..bc5270e 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.c
@@ -446,7 +446,8 @@ static void rate_fixup_ratelist(struct ieee80211_vif *vif,
 	 *
 	 * XXX: Should this check all retry rates?
 	 */
-	if (!(rates[0].flags & IEEE80211_TX_RC_MCS)) {
+	if (!(rates[0].flags &
+	      (IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS))) {
 		u32 basic_rates = vif->bss_conf.basic_rates;
 		s8 baserate = basic_rates ? ffs(basic_rates) - 1 : 0;
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.h kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.h
index d75147c..a7d5439 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rate.h
@@ -37,13 +37,35 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
 	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
 		return;
 
-	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
+	if (ref->ops->tx_status)
+		ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
+	else
+		ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
 }
 
+static inline void
+rate_control_tx_status_noskb(struct ieee80211_local *local,
+			     struct ieee80211_supported_band *sband,
+			     struct sta_info *sta,
+			     struct ieee80211_tx_info *info)
+{
+	struct rate_control_ref *ref = local->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+
+	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
+		return;
+
+	if (WARN_ON_ONCE(!ref->ops->tx_status_noskb))
+		return;
+
+	ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
+}
 
 static inline void rate_control_rate_init(struct sta_info *sta)
 {
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel.c
index f553f35..217e379 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel.c
@@ -223,11 +223,10 @@ minstrel_update_stats(struct minstrel_priv *mp, struct minstrel_sta_info *mi)
 static void
 minstrel_tx_status(void *priv, struct ieee80211_supported_band *sband,
 		   struct ieee80211_sta *sta, void *priv_sta,
-		   struct sk_buff *skb)
+		   struct ieee80211_tx_info *info)
 {
 	struct minstrel_priv *mp = priv;
 	struct minstrel_sta_info *mi = priv_sta;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_tx_rate *ar = info->status.rates;
 	int i, ndx;
 	int success;
@@ -674,7 +673,7 @@ static u32 minstrel_get_expected_throughput(void *priv_sta)
 
 const struct rate_control_ops mac80211_minstrel = {
 	.name = "minstrel",
-	.tx_status = minstrel_tx_status,
+	.tx_status_noskb = minstrel_tx_status,
 	.get_rate = minstrel_get_rate,
 	.rate_init = minstrel_rate_init,
 	.alloc = minstrel_alloc,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel_ht.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel_ht.c
index 6e4622b..e8d8bec 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel_ht.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rc80211_minstrel_ht.c
@@ -706,11 +706,10 @@ minstrel_aggr_check(struct ieee80211_sta *pubsta, struct sk_buff *skb)
 static void
 minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
                       struct ieee80211_sta *sta, void *priv_sta,
-                      struct sk_buff *skb)
+                      struct ieee80211_tx_info *info)
 {
 	struct minstrel_ht_sta_priv *msp = priv_sta;
 	struct minstrel_ht_sta *mi = &msp->ht;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_tx_rate *ar = info->status.rates;
 	struct minstrel_rate_stats *rate, *rate2;
 	struct minstrel_priv *mp = priv;
@@ -718,7 +717,8 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 	int i;
 
 	if (!msp->is_ht)
-		return mac80211_minstrel.tx_status(priv, sband, sta, &msp->legacy, skb);
+		return mac80211_minstrel.tx_status_noskb(priv, sband, sta,
+							 &msp->legacy, info);
 
 	/* This packet was aggregated but doesn't carry status info */
 	if ((info->flags & IEEE80211_TX_CTL_AMPDU) &&
@@ -779,9 +779,6 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 	if (time_after(jiffies, mi->stats_update + (mp->update_interval / 2 * HZ) / 1000)) {
 		update = true;
 		minstrel_ht_update_stats(mp, mi);
-		if (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&
-		    mi->max_prob_rate / MCS_GROUP_RATES != MINSTREL_CCK_GROUP)
-			minstrel_aggr_check(sta, skb);
 	}
 
 	if (update)
@@ -1023,6 +1020,10 @@ minstrel_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,
 	if (!msp->is_ht)
 		return mac80211_minstrel.get_rate(priv, sta, &msp->legacy, txrc);
 
+	if (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&
+	    mi->max_prob_rate / MCS_GROUP_RATES != MINSTREL_CCK_GROUP)
+		minstrel_aggr_check(sta, txrc->skb);
+
 	info->flags |= mi->tx_flags;
 	minstrel_ht_check_cck_shortpreamble(mp, mi, txrc->short_preamble);
 
@@ -1339,7 +1340,7 @@ static u32 minstrel_ht_get_expected_throughput(void *priv_sta)
 
 static const struct rate_control_ops mac80211_minstrel_ht = {
 	.name = "minstrel_ht",
-	.tx_status = minstrel_ht_tx_status,
+	.tx_status_noskb = minstrel_ht_tx_status,
 	.get_rate = minstrel_ht_get_rate,
 	.rate_init = minstrel_ht_rate_init,
 	.rate_update = minstrel_ht_rate_update,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rx.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rx.c
index 0948414..0e15099 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rx.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/rx.c
@@ -2597,7 +2597,7 @@ ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
 		case WLAN_HT_ACTION_NOTIFY_CHANWIDTH: {
 			struct ieee80211_supported_band *sband;
 			u8 chanwidth = mgmt->u.action.u.ht_notify_cw.chanwidth;
-			enum ieee80211_sta_rx_bandwidth new_bw;
+			enum ieee80211_sta_rx_bandwidth max_bw, new_bw;
 
 			/* If it doesn't support 40 MHz it can't change ... */
 			if (!(rx->sta->sta.ht_cap.cap &
@@ -2605,13 +2605,18 @@ ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
 				goto handled;
 
 			if (chanwidth == IEEE80211_HT_CHANWIDTH_20MHZ)
-				new_bw = IEEE80211_STA_RX_BW_20;
+				max_bw = IEEE80211_STA_RX_BW_20;
 			else
-				new_bw = ieee80211_sta_cur_vht_bw(rx->sta);
+				max_bw = ieee80211_sta_cap_rx_bw(rx->sta);
+
+			/* set cur_max_bandwidth and recalc sta bw */
+			rx->sta->cur_max_bandwidth = max_bw;
+			new_bw = ieee80211_sta_cur_vht_bw(rx->sta);
 
 			if (rx->sta->sta.bandwidth == new_bw)
 				goto handled;
 
+			rx->sta->sta.bandwidth = new_bw;
 			sband = rx->local->hw.wiphy->bands[status->band];
 
 			rate_control_rate_update(local, sband, rx->sta,
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/spectmgmt.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/spectmgmt.c
index efeba56..06e6ac8 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/spectmgmt.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/spectmgmt.c
@@ -34,19 +34,15 @@ int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,
 	struct cfg80211_chan_def new_vht_chandef = {};
 	const struct ieee80211_sec_chan_offs_ie *sec_chan_offs;
 	const struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;
-	const struct ieee80211_ht_operation *ht_oper;
 	int secondary_channel_offset = -1;
 
 	sec_chan_offs = elems->sec_chan_offs;
 	wide_bw_chansw_ie = elems->wide_bw_chansw_ie;
-	ht_oper = elems->ht_operation;
 
 	if (sta_flags & (IEEE80211_STA_DISABLE_HT |
 			 IEEE80211_STA_DISABLE_40MHZ)) {
 		sec_chan_offs = NULL;
 		wide_bw_chansw_ie = NULL;
-		/* only used for bandwidth here */
-		ht_oper = NULL;
 	}
 
 	if (sta_flags & IEEE80211_STA_DISABLE_VHT)
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/status.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/status.c
index 9687859..1ed95d8 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/status.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/status.c
@@ -650,7 +650,9 @@ tx_latency_threshold(struct ieee80211_local *local, struct sk_buff *skb,
 		md.tid = tid;
 		md.seq = (le16_to_cpu(hdr->seq_ctrl) &
 			  IEEE80211_SCTL_SEQ) >> 4;
+#ifdef CPTCFG_NL80211_TESTMODE
 		drv_retrieve_monitor_logs(local, &md);
+#endif
 	}
 }
 
@@ -729,10 +731,9 @@ static void ieee80211_collect_tx_timing_stats(struct ieee80211_local *local,
 #define STA_LOST_TDLS_PKT_THRESHOLD	10
 #define STA_LOST_TDLS_PKT_TIME		(10*HZ) /* 10secs since last ACK */
 
-static void ieee80211_lost_packet(struct sta_info *sta, struct sk_buff *skb)
+static void ieee80211_lost_packet(struct sta_info *sta,
+				  struct ieee80211_tx_info *info)
 {
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-
 	/* This packet was aggregated but doesn't carry status info */
 	if ((info->flags & IEEE80211_TX_CTL_AMPDU) &&
 	    !(info->flags & IEEE80211_TX_STAT_AMPDU))
@@ -759,26 +760,13 @@ static void ieee80211_lost_packet(struct sta_info *sta, struct sk_buff *skb)
 	sta->lost_packets = 0;
 }
 
-void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
+static int ieee80211_tx_get_rates(struct ieee80211_hw *hw,
+				  struct ieee80211_tx_info *info,
+				  int *retry_count)
 {
-	struct sk_buff *skb2;
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
-	struct ieee80211_local *local = hw_to_local(hw);
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	__le16 fc;
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_sub_if_data *sdata;
-	struct net_device *prev_dev = NULL;
-	struct sta_info *sta, *tmp;
-	int retry_count = -1, i;
 	int rates_idx = -1;
-	bool send_to_cooked;
-	bool acked;
-	struct ieee80211_bar *bar;
-	int rtap_len;
-	int prev_loss_pkt;
-	bool send_fail = true;
-	int shift = 0;
+	int count = -1;
+	int i;
 
 	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
 		if ((info->flags & IEEE80211_TX_CTL_AMPDU) &&
@@ -796,12 +784,93 @@ void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
 			break;
 		}
 
-		retry_count += info->status.rates[i].count;
+		count += info->status.rates[i].count;
 	}
 	rates_idx = i - 1;
 
-	if (retry_count < 0)
-		retry_count = 0;
+	if (count < 0)
+		count = 0;
+
+	*retry_count = count;
+	return rates_idx;
+}
+
+void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
+			       struct ieee80211_sta *pubsta,
+			       struct ieee80211_tx_info *info)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_supported_band *sband;
+	int retry_count;
+	int rates_idx;
+	bool acked;
+
+	rates_idx = ieee80211_tx_get_rates(hw, info, &retry_count);
+
+	sband = hw->wiphy->bands[info->band];
+
+	acked = !!(info->flags & IEEE80211_TX_STAT_ACK);
+	if (pubsta) {
+		struct sta_info *sta;
+
+		sta = container_of(pubsta, struct sta_info, sta);
+
+		if (!acked)
+			sta->tx_retry_failed++;
+		sta->tx_retry_count += retry_count;
+
+		if (acked) {
+			sta->last_rx = jiffies;
+
+			if (sta->lost_packets)
+				sta->lost_packets = 0;
+
+			/* Track when last TDLS packet was ACKed */
+			if (test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH))
+				sta->last_tdls_pkt_time = jiffies;
+		} else {
+			ieee80211_lost_packet(sta, info);
+		}
+
+		rate_control_tx_status_noskb(local, sband, sta, info);
+	}
+
+	if (acked) {
+		    local->dot11TransmittedFrameCount++;
+		    if (!pubsta)
+			    local->dot11MulticastTransmittedFrameCount++;
+		    if (retry_count > 0)
+			    local->dot11RetryCount++;
+		    if (retry_count > 1)
+			    local->dot11MultipleRetryCount++;
+	} else {
+		local->dot11FailedCount++;
+	}
+}
+EXPORT_SYMBOL(ieee80211_tx_status_noskb);
+
+void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	struct sk_buff *skb2;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	__le16 fc;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_sub_if_data *sdata;
+	struct net_device *prev_dev = NULL;
+	struct sta_info *sta, *tmp;
+	int retry_count;
+	int rates_idx;
+	bool send_to_cooked;
+	bool acked;
+	struct ieee80211_bar *bar;
+	int rtap_len;
+	int shift = 0;
+	int prev_loss_pkt;
+	bool send_fail = true;
+
+	rates_idx = ieee80211_tx_get_rates(hw, info, &retry_count);
 
 	rcu_read_lock();
 
@@ -915,7 +984,7 @@ void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
 				if (test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH))
 					sta->last_tdls_pkt_time = jiffies;
 			} else {
-				ieee80211_lost_packet(sta, skb);
+				ieee80211_lost_packet(sta, info);
 			}
 		}
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/trace.h kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/trace.h
index 704c058..4a2ca61 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/trace.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/trace.h
@@ -1829,6 +1829,12 @@ TRACE_EVENT(api_cqm_rssi_notify,
 	)
 );
 
+DEFINE_EVENT(local_sdata_evt, api_cqm_beacon_loss_notify,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
 TRACE_EVENT(api_scan_completed,
 	TP_PROTO(struct ieee80211_local *local, bool aborted),
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/tx.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/tx.c
index d108bc6..b6b709d 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/tx.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/tx.c
@@ -60,7 +60,7 @@ static __le16 ieee80211_duration(struct ieee80211_tx_data *tx,
 	rcu_read_unlock();
 
 	/* assume HW handles this */
-	if (tx->rate.flags & IEEE80211_TX_RC_MCS)
+	if (tx->rate.flags & (IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS))
 		return 0;
 
 	/* uh huh? */
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/util.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/util.c
index 974ebe7..0f9bf47 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/util.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/util.c
@@ -1735,6 +1735,10 @@ int ieee80211_reconfig(struct ieee80211_local *local)
 	struct cfg80211_sched_scan_request *sched_scan_req;
 	bool sched_scan_stopped = false;
 
+	/* nothing to do if HW shouldn't run */
+	if (!local->open_count)
+		goto wake_up;
+
 #ifdef CONFIG_PM
 	if (local->suspended)
 		local->resuming = true;
@@ -1756,9 +1760,6 @@ int ieee80211_reconfig(struct ieee80211_local *local)
 		reconfig_due_to_wowlan = true;
 	}
 #endif
-	/* everything else happens only if HW was up & running */
-	if (!local->open_count)
-		goto wake_up;
 
 	/*
 	 * Upon resume hardware can sometimes be goofy due to
@@ -2042,7 +2043,7 @@ int ieee80211_reconfig(struct ieee80211_local *local)
 	 * If this is for hw restart things are still running.
 	 * We may want to change that later, however.
 	 */
-	if (!local->suspended || reconfig_due_to_wowlan)
+	if (local->open_count && (!local->suspended || reconfig_due_to_wowlan))
 		drv_reconfig_complete(local, IEEE80211_RECONFIG_TYPE_RESTART);
 
 	if (!local->suspended)
@@ -2054,7 +2055,7 @@ int ieee80211_reconfig(struct ieee80211_local *local)
 	mb();
 	local->resuming = false;
 
-	if (!reconfig_due_to_wowlan)
+	if (local->open_count && !reconfig_due_to_wowlan)
 		drv_reconfig_complete(local, IEEE80211_RECONFIG_TYPE_SUSPEND);
 
 	list_for_each_entry(sdata, &local->interfaces, list) {
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/vht.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/vht.c
index bc9e8fc..85f9596 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/vht.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/mac80211/vht.c
@@ -269,51 +269,54 @@ ieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,
 	sta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);
 }
 
-enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta)
+enum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta)
 {
-	struct ieee80211_sub_if_data *sdata = sta->sdata;
-	u32 cap = sta->sta.vht_cap.cap;
-	enum ieee80211_sta_rx_bandwidth bw;
+	struct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;
+	u32 cap_width;
 
-	if (!sta->sta.vht_cap.vht_supported) {
-		bw = sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
-				IEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;
-		goto check_max;
-	}
+	if (!vht_cap->vht_supported)
+		return sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
+				IEEE80211_STA_RX_BW_40 :
+				IEEE80211_STA_RX_BW_20;
 
-	switch (sdata->vif.bss_conf.chandef.width) {
-	default:
-		WARN_ON_ONCE(1);
-		/* fall through */
+	cap_width = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
+
+	if (cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ ||
+	    cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)
+		return IEEE80211_STA_RX_BW_160;
+
+	return IEEE80211_STA_RX_BW_80;
+}
+
+static enum ieee80211_sta_rx_bandwidth
+ieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width)
+{
+	switch (width) {
 	case NL80211_CHAN_WIDTH_20_NOHT:
 	case NL80211_CHAN_WIDTH_20:
-		bw = IEEE80211_STA_RX_BW_20;
-		break;
+		return IEEE80211_STA_RX_BW_20;
 	case NL80211_CHAN_WIDTH_40:
-		bw = sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
-				IEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;
-		break;
+		return IEEE80211_STA_RX_BW_40;
+	case NL80211_CHAN_WIDTH_80:
+		return IEEE80211_STA_RX_BW_80;
 	case NL80211_CHAN_WIDTH_160:
-		if ((cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) ==
-				IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ) {
-			bw = IEEE80211_STA_RX_BW_160;
-			break;
-		}
-		/* fall through */
 	case NL80211_CHAN_WIDTH_80P80:
-		if ((cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) ==
-				IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ) {
-			bw = IEEE80211_STA_RX_BW_160;
-			break;
-		}
-		/* fall through */
-	case NL80211_CHAN_WIDTH_80:
-		bw = IEEE80211_STA_RX_BW_80;
+		return IEEE80211_STA_RX_BW_160;
+	default:
+		WARN_ON_ONCE(1);
+		return IEEE80211_STA_RX_BW_20;
 	}
+}
+
+enum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	enum ieee80211_sta_rx_bandwidth bw;
+
+	bw = ieee80211_chan_width_to_rx_bw(sdata->vif.bss_conf.chandef.width);
+	bw = min(bw, ieee80211_sta_cap_rx_bw(sta));
+	bw = min(bw, sta->cur_max_bandwidth);
 
- check_max:
-	if (bw > sta->cur_max_bandwidth)
-		bw = sta->cur_max_bandwidth;
 	return bw;
 }
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/Kconfig kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/Kconfig
index cd3bc30..0ba1fb3 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/Kconfig
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/Kconfig
@@ -158,7 +158,7 @@ config CFG80211_INTERNAL_REGDB
 	  Most distributions have a CRDA package.  So if unsure, say N.
 
 config CFG80211_WEXT
-	bool "cfg80211 wireless extensions compatibility"
+	bool
 	depends on CFG80211
 	depends on WEXT_CORE
 	help
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.c
index af47093..e2159d9 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.c
@@ -559,6 +559,28 @@ int wiphy_register(struct wiphy *wiphy)
 		     !rdev->ops->tdls_cancel_channel_switch)))
 		return -EINVAL;
 
+	/*
+	 * if a wiphy has unsupported modes for regulatory channel enforcement,
+	 * opt-out of enforcement checking
+	 */
+	if (wiphy->interface_modes & ~(BIT(NL80211_IFTYPE_STATION) |
+				       BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				       BIT(NL80211_IFTYPE_AP) |
+				       BIT(NL80211_IFTYPE_P2P_GO) |
+				       BIT(NL80211_IFTYPE_ADHOC) |
+				       BIT(NL80211_IFTYPE_P2P_DEVICE) |
+				       BIT(NL80211_IFTYPE_AP_VLAN) |
+				       BIT(NL80211_IFTYPE_MONITOR)))
+		wiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;
+
+	if (WARN_ON((wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) &&
+		    (wiphy->regulatory_flags &
+					(REGULATORY_CUSTOM_REG |
+					 REGULATORY_STRICT_REG |
+					 REGULATORY_COUNTRY_IE_FOLLOW_POWER |
+					 REGULATORY_COUNTRY_IE_IGNORE))))
+		return -EINVAL;
+
 	if (WARN_ON(wiphy->coalesce &&
 		    (!wiphy->coalesce->n_rules ||
 		     !wiphy->coalesce->n_patterns) &&
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.h kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.h
index 254cbd1..6c54964 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/core.h
@@ -36,6 +36,13 @@ struct cfg80211_registered_device {
 	 * the country on the country IE changed. */
 	char country_ie_alpha2[2];
 
+	/*
+	 * the driver requests the regulatory core to set this regulatory
+	 * domain as the wiphy's. Only used for %REGULATORY_WIPHY_SELF_MANAGED
+	 * devices using the regulatory_set_wiphy_regd() API
+	 */
+	const struct ieee80211_regdomain *requested_regd;
+
 	/* If a Country IE has been received this tells us the environment
 	 * which its telling us its in. This defaults to ENVIRON_ANY */
 	enum environment_cap env;
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.c
index fe50598..a02ae8d 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.c
@@ -396,6 +396,7 @@ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 	[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },
 	[NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },
 	[NL80211_ATTR_SOCKET_OWNER] = { .type = NLA_FLAG },
+	[NL80211_ATTR_WIPHY_SELF_MANAGED_REG] = { .type = NLA_FLAG },
 	[NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },
 	[NL80211_ATTR_USE_RRM] = { .type = NLA_FLAG },
 	[NL80211_ATTR_TSID] = { .type = NLA_U8 },
@@ -1095,6 +1096,11 @@ static int nl80211_send_wowlan(struct sk_buff *msg,
 			return -ENOBUFS;
 	}
 
+	if ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_NET_DETECT) &&
+	    nla_put_u32(msg, NL80211_WOWLAN_TRIG_NET_DETECT,
+			rdev->wiphy.wowlan->max_nd_match_sets))
+		return -ENOBUFS;
+
 	if (large && nl80211_send_wowlan_tcp_caps(rdev, msg))
 		return -ENOBUFS;
 
@@ -1709,6 +1715,10 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 			       rdev->wiphy.max_num_csa_counters))
 			goto nla_put_failure;
 
+		if (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&
+		    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))
+			goto nla_put_failure;
+
 		/* done */
 		state->split_start = 0;
 		break;
@@ -5359,43 +5369,20 @@ static int nl80211_update_mesh_config(struct sk_buff *skb,
 	return err;
 }
 
-static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
+static int nl80211_put_regdom(const struct ieee80211_regdomain *regdom,
+			      struct sk_buff *msg)
 {
-	const struct ieee80211_regdomain *regdom;
-	struct sk_buff *msg;
-	void *hdr = NULL;
 	struct nlattr *nl_reg_rules;
 	unsigned int i;
 
-	if (!cfg80211_regdomain)
-		return -EINVAL;
-
-	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
-	if (!msg)
-		return -ENOBUFS;
-
-	hdr = nl80211hdr_put(msg, genl_info_snd_portid(info), info->snd_seq,
-			     0,
-			     NL80211_CMD_GET_REG);
-	if (!hdr)
-		goto put_failure;
-
-	if (reg_last_request_cell_base() &&
-	    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,
-			NL80211_USER_REG_HINT_CELL_BASE))
-		goto nla_put_failure;
-
-	rcu_read_lock();
-	regdom = rcu_dereference(cfg80211_regdomain);
-
 	if (nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, regdom->alpha2) ||
 	    (regdom->dfs_region &&
 	     nla_put_u8(msg, NL80211_ATTR_DFS_REGION, regdom->dfs_region)))
-		goto nla_put_failure_rcu;
+		goto nla_put_failure;
 
 	nl_reg_rules = nla_nest_start(msg, NL80211_ATTR_REG_RULES);
 	if (!nl_reg_rules)
-		goto nla_put_failure_rcu;
+		goto nla_put_failure;
 
 	for (i = 0; i < regdom->n_reg_rules; i++) {
 		struct nlattr *nl_reg_rule;
@@ -5410,7 +5397,7 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
 
 		nl_reg_rule = nla_nest_start(msg, i);
 		if (!nl_reg_rule)
-			goto nla_put_failure_rcu;
+			goto nla_put_failure;
 
 		max_bandwidth_khz = freq_range->max_bandwidth_khz;
 		if (!max_bandwidth_khz)
@@ -5431,13 +5418,79 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
 				power_rule->max_eirp) ||
 		    nla_put_u32(msg, NL80211_ATTR_DFS_CAC_TIME,
 				reg_rule->dfs_cac_ms))
-			goto nla_put_failure_rcu;
+			goto nla_put_failure;
 
 		nla_nest_end(msg, nl_reg_rule);
 	}
-	rcu_read_unlock();
 
 	nla_nest_end(msg, nl_reg_rules);
+	return 0;
+
+nla_put_failure:
+	return -EMSGSIZE;
+}
+
+static int nl80211_get_reg_do(struct sk_buff *skb, struct genl_info *info)
+{
+	const struct ieee80211_regdomain *regdom = NULL;
+	struct cfg80211_registered_device *rdev;
+	struct wiphy *wiphy = NULL;
+	struct sk_buff *msg;
+	void *hdr;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOBUFS;
+
+	hdr = nl80211hdr_put(msg, genl_info_snd_portid(info), info->snd_seq, 0,
+			     NL80211_CMD_GET_REG);
+	if (!hdr)
+		goto put_failure;
+
+	if (info->attrs[NL80211_ATTR_WIPHY]) {
+		bool self_managed;
+
+		rdev = cfg80211_get_dev_from_info(genl_info_net(info), info);
+		if (IS_ERR(rdev)) {
+			nlmsg_free(msg);
+			return PTR_ERR(rdev);
+		}
+
+		wiphy = &rdev->wiphy;
+		self_managed = wiphy->regulatory_flags &
+			       REGULATORY_WIPHY_SELF_MANAGED;
+		regdom = get_wiphy_regdom(wiphy);
+
+		/* a self-managed-reg device must have a private regdom */
+		if (WARN_ON(!regdom && self_managed)) {
+			nlmsg_free(msg);
+			return -EINVAL;
+		}
+
+		if (regdom &&
+		    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))
+			goto nla_put_failure;
+	}
+
+	if (!regdom && !cfg80211_regdomain) {
+		nlmsg_free(msg);
+		return -EINVAL;
+	}
+
+	if (!wiphy && reg_last_request_cell_base() &&
+	    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,
+			NL80211_USER_REG_HINT_CELL_BASE))
+		goto nla_put_failure;
+
+	rcu_read_lock();
+
+	if (!regdom)
+		regdom = rcu_dereference(cfg80211_regdomain);
+
+	if (nl80211_put_regdom(regdom, msg))
+		goto nla_put_failure_rcu;
+
+	rcu_read_unlock();
 
 	genlmsg_end(msg, hdr);
 	return genlmsg_reply(msg, info);
@@ -5451,15 +5504,92 @@ put_failure:
 	return -EMSGSIZE;
 }
 
+static int nl80211_send_regdom(struct sk_buff *msg, struct netlink_callback *cb,
+			       u32 seq, int flags, struct wiphy *wiphy,
+			       const struct ieee80211_regdomain *regdom)
+{
+	void *hdr = nl80211hdr_put(msg, NETLINK_CB_PORTID(cb->skb), seq, flags,
+				   NL80211_CMD_GET_REG);
+
+	if (!hdr)
+		return -1;
+
+	genl_dump_check_consistent(cb, hdr, &nl80211_fam);
+
+	if (nl80211_put_regdom(regdom, msg))
+		goto nla_put_failure;
+
+	if (!wiphy && reg_last_request_cell_base() &&
+	    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,
+			NL80211_USER_REG_HINT_CELL_BASE))
+		goto nla_put_failure;
+
+	if (wiphy &&
+	    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))
+		goto nla_put_failure;
+
+	if (wiphy && wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&
+	    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))
+		goto nla_put_failure;
+
+	return genlmsg_end(msg, hdr);
+
+nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	return -EMSGSIZE;
+}
+
+static int nl80211_get_reg_dump(struct sk_buff *skb,
+				struct netlink_callback *cb)
+{
+	const struct ieee80211_regdomain *regdom = NULL;
+	struct cfg80211_registered_device *rdev;
+	int err, reg_idx, start = cb->args[2];
+
+	rtnl_lock();
+
+	if (cfg80211_regdomain && start == 0) {
+		err = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,
+					  NLM_F_MULTI, NULL,
+					  rtnl_dereference(cfg80211_regdomain));
+		if (err < 0)
+			goto out_err;
+	}
+
+	/* the global regdom is idx 0 */
+	reg_idx = 1;
+	list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
+		regdom = get_wiphy_regdom(&rdev->wiphy);
+		if (!regdom)
+			continue;
+
+		if (++reg_idx <= start)
+			continue;
+
+		err = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,
+					  NLM_F_MULTI, &rdev->wiphy, regdom);
+		if (err < 0) {
+			reg_idx--;
+			break;
+		}
+	}
+
+	cb->args[2] = reg_idx;
+	err = skb->len;
+out_err:
+	rtnl_unlock();
+	return err;
+}
+
 static int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];
 	struct nlattr *nl_reg_rule;
-	char *alpha2 = NULL;
-	int rem_reg_rules = 0, r = 0;
+	char *alpha2;
+	int rem_reg_rules, r;
 	u32 num_rules = 0, rule_idx = 0, size_of_regd;
 	enum nl80211_dfs_regions dfs_region = NL80211_DFS_UNSET;
-	struct ieee80211_regdomain *rd = NULL;
+	struct ieee80211_regdomain *rd;
 
 	if (!info->attrs[NL80211_ATTR_REG_ALPHA2])
 		return -EINVAL;
@@ -6086,6 +6216,10 @@ nl80211_parse_sched_scan(struct wiphy *wiphy, struct wireless_dev *wdev,
 		}
 	}
 
+	if (attrs[NL80211_ATTR_SCHED_SCAN_DELAY])
+		request->delay =
+			nla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_DELAY]);
+
 	request->interval = interval;
 	request->scan_start = jiffies;
 
@@ -8643,6 +8777,48 @@ static int nl80211_send_wowlan_tcp(struct sk_buff *msg,
 	return 0;
 }
 
+static int nl80211_send_wowlan_nd(struct sk_buff *msg,
+				  struct cfg80211_sched_scan_request *req)
+{
+	struct nlattr *nd, *freqs, *matches, *match;
+	int i;
+
+	if (!req)
+		return 0;
+
+	nd = nla_nest_start(msg, NL80211_WOWLAN_TRIG_NET_DETECT);
+	if (!nd)
+		return -ENOBUFS;
+
+	if (nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL, req->interval))
+		return -ENOBUFS;
+
+	freqs = nla_nest_start(msg, NL80211_ATTR_SCAN_FREQUENCIES);
+	if (!freqs)
+		return -ENOBUFS;
+
+	for (i = 0; i < req->n_channels; i++)
+		nla_put_u32(msg, i, req->channels[i]->center_freq);
+
+	nla_nest_end(msg, freqs);
+
+	if (req->n_match_sets) {
+		matches = nla_nest_start(msg, NL80211_ATTR_SCHED_SCAN_MATCH);
+		for (i = 0; i < req->n_match_sets; i++) {
+			match = nla_nest_start(msg, i);
+			nla_put(msg, NL80211_SCHED_SCAN_MATCH_ATTR_SSID,
+				req->match_sets[i].ssid.ssid_len,
+				req->match_sets[i].ssid.ssid);
+			nla_nest_end(msg, match);
+		}
+		nla_nest_end(msg, matches);
+	}
+
+	nla_nest_end(msg, nd);
+
+	return 0;
+}
+
 static int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)
 {
 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
@@ -8701,6 +8877,11 @@ static int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)
 					    rdev->wiphy.wowlan_config->tcp))
 			goto nla_put_failure;
 
+		if (nl80211_send_wowlan_nd(
+			    msg,
+			    rdev->wiphy.wowlan_config->nd_config))
+			goto nla_put_failure;
+
 		nla_nest_end(msg, nl_wowlan);
 	}
 
@@ -8899,6 +9080,7 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 	const struct wiphy_wowlan_support *wowlan = rdev->wiphy.wowlan;
 	int err, i;
 	bool prev_enabled = rdev->wiphy.wowlan_config;
+	bool regular = false;
 
 	if (!wowlan)
 		return -EOPNOTSUPP;
@@ -8926,12 +9108,14 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 		if (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))
 			return -EINVAL;
 		new_triggers.disconnect = true;
+		regular = true;
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {
 		if (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))
 			return -EINVAL;
 		new_triggers.magic_pkt = true;
+		regular = true;
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED])
@@ -8941,24 +9125,28 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 		if (!(wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE))
 			return -EINVAL;
 		new_triggers.gtk_rekey_failure = true;
+		regular = true;
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST]) {
 		if (!(wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ))
 			return -EINVAL;
 		new_triggers.eap_identity_req = true;
+		regular = true;
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE]) {
 		if (!(wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE))
 			return -EINVAL;
 		new_triggers.four_way_handshake = true;
+		regular = true;
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_RFKILL_RELEASE]) {
 		if (!(wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE))
 			return -EINVAL;
 		new_triggers.rfkill_release = true;
+		regular = true;
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {
@@ -8967,6 +9155,8 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 		int rem, pat_len, mask_len, pkt_offset;
 		struct nlattr *pat_tb[NUM_NL80211_PKTPAT];
 
+		regular = true;
+
 		nla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],
 				    rem)
 			n_patterns++;
@@ -9028,6 +9218,7 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION]) {
+		regular = true;
 		err = nl80211_parse_wowlan_tcp(
 			rdev, tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION],
 			&new_triggers);
@@ -9036,6 +9227,7 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 	}
 
 	if (tb[NL80211_WOWLAN_TRIG_NET_DETECT]) {
+		regular = true;
 		err = nl80211_parse_wowlan_nd(
 			rdev, wowlan, tb[NL80211_WOWLAN_TRIG_NET_DETECT],
 			&new_triggers);
@@ -9043,6 +9235,17 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 			goto error;
 	}
 
+	/* The 'any' trigger means the device continues operating more or less
+	 * as in its normal operation mode and wakes up the host on most of the
+	 * normal interrupts (like packet RX, ...)
+	 * It therefore makes little sense to combine with the more constrained
+	 * wakeup trigger modes.
+	 */
+	if (new_triggers.any && regular) {
+		err = -EINVAL;
+		goto error;
+	}
+
 	ntrig = kmemdup(&new_triggers, sizeof(new_triggers), GFP_KERNEL);
 	if (!ntrig) {
 		err = -ENOMEM;
@@ -10288,7 +10491,8 @@ static __genl_const struct genl_ops nl80211_ops[] = {
 	},
 	{
 		.cmd = NL80211_CMD_GET_REG,
-		.doit = nl80211_get_reg,
+		.doit = nl80211_get_reg_do,
+		.dumpit = nl80211_get_reg_dump,
 		.policy = nl80211_policy,
 		.internal_flags = NL80211_FLAG_NEED_RTNL,
 		/* can be retrieved by unprivileged users */
@@ -11008,25 +11212,9 @@ void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,
 				NL80211_MCGRP_SCAN, GFP_KERNEL);
 }
 
-/*
- * This can happen on global regulatory changes or device specific settings
- * based on custom world regulatory domains.
- */
-void nl80211_send_reg_change_event(struct regulatory_request *request)
+static bool nl80211_reg_change_event_fill(struct sk_buff *msg,
+					  struct regulatory_request *request)
 {
-	struct sk_buff *msg;
-	void *hdr;
-
-	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
-	if (!msg)
-		return;
-
-	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_CHANGE);
-	if (!hdr) {
-		nlmsg_free(msg);
-		return;
-	}
-
 	/* Userspace can always count this one always being set */
 	if (nla_put_u8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator))
 		goto nla_put_failure;
@@ -11052,8 +11240,46 @@ void nl80211_send_reg_change_event(struct regulatory_request *request)
 			goto nla_put_failure;
 	}
 
-	if (request->wiphy_idx != WIPHY_IDX_INVALID &&
-	    nla_put_u32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx))
+	if (request->wiphy_idx != WIPHY_IDX_INVALID) {
+		struct wiphy *wiphy = wiphy_idx_to_wiphy(request->wiphy_idx);
+
+		if (wiphy &&
+		    nla_put_u32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx))
+			goto nla_put_failure;
+
+		if (wiphy &&
+		    wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&
+		    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))
+			goto nla_put_failure;
+	}
+
+	return true;
+
+nla_put_failure:
+	return false;
+}
+
+/*
+ * This can happen on global regulatory changes or device specific settings
+ * based on custom regulatory domains.
+ */
+static void nl80211_common_reg_change_event(enum nl80211_commands cmd_id,
+					    struct regulatory_request *request)
+{
+	struct sk_buff *msg;
+	void *hdr;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	if (!msg)
+		return;
+
+	hdr = nl80211hdr_put(msg, 0, 0, 0, cmd_id);
+	if (!hdr) {
+		nlmsg_free(msg);
+		return;
+	}
+
+	if (nl80211_reg_change_event_fill(msg, request) == false)
 		goto nla_put_failure;
 
 	genlmsg_end(msg, hdr);
@@ -11070,6 +11296,16 @@ nla_put_failure:
 	nlmsg_free(msg);
 }
 
+void nl80211_send_reg_change_event(struct regulatory_request *request)
+{
+	nl80211_common_reg_change_event(NL80211_CMD_REG_CHANGE, request);
+}
+
+void nl80211_send_wiphy_reg_change_event(struct regulatory_request *request)
+{
+	nl80211_common_reg_change_event(NL80211_CMD_WIPHY_REG_CHANGE, request);
+}
+
 static void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,
 				    struct net_device *netdev,
 				    const u8 *buf, size_t len,
@@ -11854,55 +12090,155 @@ void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
 }
 EXPORT_SYMBOL(cfg80211_mgmt_tx_status);
 
-void cfg80211_cqm_rssi_notify(struct net_device *dev,
-			      enum nl80211_cqm_rssi_threshold_event rssi_event,
-			      gfp_t gfp)
+static struct sk_buff *cfg80211_prepare_cqm(struct net_device *dev,
+					    const char *mac, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
-	struct wiphy *wiphy = wdev->wiphy;
-	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
-	struct sk_buff *msg;
-	struct nlattr *pinfoattr;
-	void *hdr;
-
-	trace_cfg80211_cqm_rssi_notify(dev, rssi_event);
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+	struct sk_buff *msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
+	void **cb;
 
-	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
 	if (!msg)
-		return;
+		return NULL;
 
-	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);
-	if (!hdr) {
+	cb = (void **)msg->cb;
+
+	cb[0] = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);
+	if (!cb[0]) {
 		nlmsg_free(msg);
-		return;
+		return NULL;
 	}
 
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
 	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))
 		goto nla_put_failure;
 
-	pinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);
-	if (!pinfoattr)
+	if (mac && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))
 		goto nla_put_failure;
 
-	if (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,
-			rssi_event))
+	cb[1] = nla_nest_start(msg, NL80211_ATTR_CQM);
+	if (!cb[1])
 		goto nla_put_failure;
 
-	nla_nest_end(msg, pinfoattr);
+	cb[2] = rdev;
 
-	genlmsg_end(msg, hdr);
+	return msg;
+ nla_put_failure:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+static void cfg80211_send_cqm(struct sk_buff *msg, gfp_t gfp)
+{
+	void **cb = (void **)msg->cb;
+	struct cfg80211_registered_device *rdev = cb[2];
+
+	nla_nest_end(msg, cb[1]);
+	genlmsg_end(msg, cb[0]);
+
+	memset(msg->cb, 0, sizeof(msg->cb));
 
 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
 				NL80211_MCGRP_MLME, gfp);
+}
+
+void cfg80211_cqm_rssi_notify(struct net_device *dev,
+			      enum nl80211_cqm_rssi_threshold_event rssi_event,
+			      gfp_t gfp)
+{
+	struct sk_buff *msg;
+
+	trace_cfg80211_cqm_rssi_notify(dev, rssi_event);
+
+	if (WARN_ON(rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW &&
+		    rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH))
+		return;
+
+	msg = cfg80211_prepare_cqm(dev, NULL, gfp);
+	if (!msg)
+		return;
+
+	if (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,
+			rssi_event))
+		goto nla_put_failure;
+
+	cfg80211_send_cqm(msg, gfp);
+
 	return;
 
  nla_put_failure:
-	genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
 EXPORT_SYMBOL(cfg80211_cqm_rssi_notify);
 
+void cfg80211_cqm_txe_notify(struct net_device *dev,
+			     const u8 *peer, u32 num_packets,
+			     u32 rate, u32 intvl, gfp_t gfp)
+{
+	struct sk_buff *msg;
+
+	msg = cfg80211_prepare_cqm(dev, peer, gfp);
+	if (!msg)
+		return;
+
+	if (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_PKTS, num_packets))
+		goto nla_put_failure;
+
+	if (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_RATE, rate))
+		goto nla_put_failure;
+
+	if (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_INTVL, intvl))
+		goto nla_put_failure;
+
+	cfg80211_send_cqm(msg, gfp);
+	return;
+
+ nla_put_failure:
+	nlmsg_free(msg);
+}
+EXPORT_SYMBOL(cfg80211_cqm_txe_notify);
+
+void cfg80211_cqm_pktloss_notify(struct net_device *dev,
+				 const u8 *peer, u32 num_packets, gfp_t gfp)
+{
+	struct sk_buff *msg;
+
+	trace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);
+
+	msg = cfg80211_prepare_cqm(dev, peer, gfp);
+	if (!msg)
+		return;
+
+	if (nla_put_u32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets))
+		goto nla_put_failure;
+
+	cfg80211_send_cqm(msg, gfp);
+	return;
+
+ nla_put_failure:
+	nlmsg_free(msg);
+}
+EXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);
+
+void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp)
+{
+	struct sk_buff *msg;
+
+	msg = cfg80211_prepare_cqm(dev, NULL, gfp);
+	if (!msg)
+		return;
+
+	if (nla_put_flag(msg, NL80211_ATTR_CQM_BEACON_LOSS_EVENT))
+		goto nla_put_failure;
+
+	cfg80211_send_cqm(msg, gfp);
+	return;
+
+ nla_put_failure:
+	nlmsg_free(msg);
+}
+EXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify);
+
 static void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,
 				     struct net_device *netdev, const u8 *bssid,
 				     const u8 *replay_ctr, gfp_t gfp)
@@ -12091,59 +12427,6 @@ void cfg80211_ch_switch_started_notify(struct net_device *dev,
 }
 EXPORT_SYMBOL(cfg80211_ch_switch_started_notify);
 
-void cfg80211_cqm_txe_notify(struct net_device *dev,
-			     const u8 *peer, u32 num_packets,
-			     u32 rate, u32 intvl, gfp_t gfp)
-{
-	struct wireless_dev *wdev = dev->ieee80211_ptr;
-	struct wiphy *wiphy = wdev->wiphy;
-	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
-	struct sk_buff *msg;
-	struct nlattr *pinfoattr;
-	void *hdr;
-
-	msg = nlmsg_new(NLMSG_GOODSIZE, gfp);
-	if (!msg)
-		return;
-
-	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);
-	if (!hdr) {
-		nlmsg_free(msg);
-		return;
-	}
-
-	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
-	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||
-	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, peer))
-		goto nla_put_failure;
-
-	pinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);
-	if (!pinfoattr)
-		goto nla_put_failure;
-
-	if (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_PKTS, num_packets))
-		goto nla_put_failure;
-
-	if (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_RATE, rate))
-		goto nla_put_failure;
-
-	if (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_INTVL, intvl))
-		goto nla_put_failure;
-
-	nla_nest_end(msg, pinfoattr);
-
-	genlmsg_end(msg, hdr);
-
-	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
-				NL80211_MCGRP_MLME, gfp);
-	return;
-
- nla_put_failure:
-	genlmsg_cancel(msg, hdr);
-	nlmsg_free(msg);
-}
-EXPORT_SYMBOL(cfg80211_cqm_txe_notify);
-
 void
 nl80211_radar_notify(struct cfg80211_registered_device *rdev,
 		     const struct cfg80211_chan_def *chandef,
@@ -12192,54 +12475,6 @@ nl80211_radar_notify(struct cfg80211_registered_device *rdev,
 	nlmsg_free(msg);
 }
 
-void cfg80211_cqm_pktloss_notify(struct net_device *dev,
-				 const u8 *peer, u32 num_packets, gfp_t gfp)
-{
-	struct wireless_dev *wdev = dev->ieee80211_ptr;
-	struct wiphy *wiphy = wdev->wiphy;
-	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
-	struct sk_buff *msg;
-	struct nlattr *pinfoattr;
-	void *hdr;
-
-	trace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);
-
-	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
-	if (!msg)
-		return;
-
-	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);
-	if (!hdr) {
-		nlmsg_free(msg);
-		return;
-	}
-
-	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
-	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||
-	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, peer))
-		goto nla_put_failure;
-
-	pinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);
-	if (!pinfoattr)
-		goto nla_put_failure;
-
-	if (nla_put_u32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets))
-		goto nla_put_failure;
-
-	nla_nest_end(msg, pinfoattr);
-
-	genlmsg_end(msg, hdr);
-
-	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
-				NL80211_MCGRP_MLME, gfp);
-	return;
-
- nla_put_failure:
-	genlmsg_cancel(msg, hdr);
-	nlmsg_free(msg);
-}
-EXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);
-
 void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
 			   u64 cookie, bool acked, gfp_t gfp)
 {
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.h kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.h
index 7ad70d6..b91b9c5 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/nl80211.h
@@ -18,6 +18,7 @@ void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,
 void nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,
 				     struct net_device *netdev);
 void nl80211_send_reg_change_event(struct regulatory_request *request);
+void nl80211_send_wiphy_reg_change_event(struct regulatory_request *request);
 void nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,
 			  struct net_device *netdev,
 			  const u8 *buf, size_t len, gfp_t gfp);
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.c kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.c
index 3e69554..d99034c 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.c
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.c
@@ -67,6 +67,12 @@
 #define REG_DBG_PRINT(args...)
 #endif
 
+/*
+ * Grace period we give before making sure all current interfaces reside on
+ * channels allowed by the current regulatory domain.
+ */
+#define REG_ENFORCE_GRACE_MS 60000
+
 /**
  * enum reg_request_treatment - regulatory request treatment
  *
@@ -80,8 +86,6 @@
  *	further processing is required, i.e., not need to update last_request
  *	etc. This should be used for user hints that do not provide an alpha2
  *	but some other type of regulatory hint, i.e., indoor operation.
- * @REG_REQ_HANDLED: a request was handled synchronously. No need to set
- *	timeouts and potentially revert to the default settings.
  */
 enum reg_request_treatment {
 	REG_REQ_OK,
@@ -89,7 +93,6 @@ enum reg_request_treatment {
 	REG_REQ_INTERSECT,
 	REG_REQ_ALREADY_SET,
 	REG_REQ_USER_HINT_HANDLED,
-	REG_REQ_HANDLED,
 };
 
 static struct regulatory_request core_request_world = {
@@ -140,21 +143,12 @@ static int reg_num_devs_support_basehint;
  */
 static bool reg_is_indoor;
 
-/*
- * Wiphy with a get_regd() callback that can provide regulatory information
- * when the country code changes. Only the first wiphy registered with the
- * get_regd callback will be called to provide a regdomain on country-code
- * changes.
- * (protected by RTNL)
- */
-static struct wiphy *regd_info_wiphy;
-
 static const struct ieee80211_regdomain *get_cfg80211_regdom(void)
 {
 	return rtnl_dereference(cfg80211_regdomain);
 }
 
-static const struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy)
+const struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy)
 {
 	return rtnl_dereference(wiphy->regd);
 }
@@ -429,8 +423,7 @@ static bool is_user_regdom_saved(void)
 		return false;
 
 	/* This would indicate a mistake on the design */
-	if (WARN(!is_world_regdom(user_alpha2) && !is_an_alpha2(user_alpha2) &&
-		 !is_unknown_alpha2(user_alpha2),
+	if (WARN(!is_world_regdom(user_alpha2) && !is_an_alpha2(user_alpha2),
 		 "Unexpected user alpha2: %c%c\n",
 		 user_alpha2[0], user_alpha2[1]))
 		return false;
@@ -562,39 +555,9 @@ static int call_crda(const char *alpha2)
 	return kobject_uevent_env(&reg_pdev->dev.kobj, KOBJ_CHANGE, env);
 }
 
-static int call_wiphy_regd_info(const char *alpha2)
-{
-	struct ieee80211_regdomain *regd;
-
-	if (!regd_info_wiphy)
-		return -ENOENT;
-
-	/* can happen if the driver removes the callback at runtime */
-	if (WARN_ON(!regd_info_wiphy->get_regd))
-		return -EINVAL;
-
-	regd = regd_info_wiphy->get_regd(regd_info_wiphy, alpha2);
-	if (IS_ERR(regd))
-		return -EIO;
-
-	if (regd)
-		set_regdom(regd);
-
-	return 0;
-}
-
 static enum reg_request_treatment
-reg_get_regdom_data(struct regulatory_request *request)
+reg_call_crda(struct regulatory_request *request)
 {
-	ASSERT_RTNL();
-
-	/*
-	 * A wiphy wishing to set the regdomain takes precedence. Note the
-	 * regdomain setting happens synchronously inside.
-	 */
-	if (!call_wiphy_regd_info(request->alpha2))
-		return REG_REQ_HANDLED;
-
 	if (call_crda(request->alpha2))
 		return REG_REQ_IGNORE;
 	return REG_REQ_OK;
@@ -607,8 +570,7 @@ bool reg_is_valid_request(const char *alpha2)
 	if (!lr || lr->processed)
 		return false;
 
-	return alpha2_equal(lr->alpha2, alpha2) ||
-	       is_unknown_alpha2(lr->alpha2);
+	return alpha2_equal(lr->alpha2, alpha2);
 }
 
 static const struct ieee80211_regdomain *reg_get_regdomain(struct wiphy *wiphy)
@@ -1351,6 +1313,9 @@ static bool ignore_reg_update(struct wiphy *wiphy,
 {
 	struct regulatory_request *lr = get_last_request();
 
+	if (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED)
+		return true;
+
 	if (!lr) {
 		REG_DBG_PRINT("Ignoring regulatory request set by %s "
 			      "since last_request is not set\n",
@@ -1592,25 +1557,13 @@ static bool reg_wdev_chan_valid(struct wiphy *wiphy, struct wireless_dev *wdev)
 
 		ret = cfg80211_reg_can_beacon(wiphy,
 					      &wdev->chandef, wdev->iftype);
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		if (!wdev->ssid_len)
+			goto out;
 
-		if (ret || wdev->iftype == NL80211_IFTYPE_AP)
-			break;
-
-		/* if the NO_IR relaxation is enabled and supported by the
-		 * device driver, allow a P2P GO to continue operating on its
-		 * current operating channel as long as the indoor operation is
-		 * asserted. This is done under the assumption that although
-		 * there is no station interface connected, since the device is
-		 * operating in an indoor environment the regulatory
-		 * restrictions are the same.
-		 */
-		ch = wdev->chandef.chan;
-		if (config_enabled(CPTCFG_CFG80211_REG_RELAX_NO_IR) &&
-		    (wiphy->regulatory_flags & REGULATORY_ENABLE_RELAX_NO_IR) &&
-		    (ch->flags & IEEE80211_CHAN_GO_CONCURRENT) &&
-		    regulatory_indoor_allowed())
-			ret = true;
-
+		ret = cfg80211_reg_can_beacon(wiphy,
+					      &wdev->chandef, wdev->iftype);
 		break;
 	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_P2P_CLIENT:
@@ -1626,8 +1579,14 @@ static bool reg_wdev_chan_valid(struct wiphy *wiphy, struct wireless_dev *wdev)
 		else
 			ret = !(ch->flags & IEEE80211_CHAN_DISABLED);
 		break;
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_P2P_DEVICE:
+		/* no enforcement required */
+		break;
 	default:
 		/* others not implemented for now */
+		WARN_ON(1);
 		break;
 	}
 
@@ -1656,7 +1615,9 @@ static void reg_check_chans_work(struct work_struct *work)
 	rtnl_lock();
 
 	list_for_each_entry(rdev, &cfg80211_rdev_list, list)
-		reg_leave_invalid_chans(&rdev->wiphy);
+		if (!(rdev->wiphy.regulatory_flags &
+		      REGULATORY_IGNORE_STALE_KICKOFF))
+			reg_leave_invalid_chans(&rdev->wiphy);
 
 	rtnl_unlock();
 }
@@ -1668,7 +1629,8 @@ static void reg_check_channels(void)
 	 * channel, orderly disconnection), before forcing a disconnection.
 	 */
 	mod_delayed_work(system_power_efficient_wq,
-			 &reg_check_chans, msecs_to_jiffies(60000));
+			 &reg_check_chans,
+			 msecs_to_jiffies(REG_ENFORCE_GRACE_MS));
 }
 
 static void wiphy_update_regulatory(struct wiphy *wiphy,
@@ -1730,8 +1692,7 @@ static void handle_channel_custom(struct wiphy *wiphy,
 	if (IS_ERR(reg_rule)) {
 		REG_DBG_PRINT("Disabling freq %d MHz as custom regd has no rule that fits it\n",
 			      chan->center_freq);
-		chan->orig_flags |= IEEE80211_CHAN_DISABLED;
-		chan->flags = chan->orig_flags;
+		chan->flags |= IEEE80211_CHAN_DISABLED;
 		return;
 	}
 
@@ -1756,7 +1717,11 @@ static void handle_channel_custom(struct wiphy *wiphy,
 	chan->dfs_state = NL80211_DFS_USABLE;
 
 	chan->beacon_found = false;
-	chan->flags |= map_regdom_flags(reg_rule->flags) | bw_flags;
+	chan->dfs_state_entered = jiffies;
+	chan->dfs_state = NL80211_DFS_USABLE;
+
+	chan->beacon_found = false;
+	chan->flags = map_regdom_flags(reg_rule->flags) | bw_flags;
 	chan->max_antenna_gain = (int) MBI_TO_DBI(power_rule->max_antenna_gain);
 	chan->max_reg_power = chan->max_power =
 		(int) MBM_TO_DBM(power_rule->max_eirp);
@@ -1769,6 +1734,15 @@ static void handle_channel_custom(struct wiphy *wiphy,
 	}
 
 	chan->max_power = chan->max_reg_power;
+
+	if (chan->flags & IEEE80211_CHAN_RADAR) {
+		if (reg_rule->dfs_cac_ms)
+			chan->dfs_cac_ms = reg_rule->dfs_cac_ms;
+		else
+			chan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;
+	}
+
+	chan->max_power = chan->max_reg_power;
 }
 
 static void handle_band_custom(struct wiphy *wiphy,
@@ -1847,7 +1821,7 @@ reg_process_hint_core(struct regulatory_request *core_request)
 
 	reg_update_last_request(core_request);
 
-	return reg_get_regdom_data(core_request);
+	return reg_call_crda(core_request);
 }
 
 static enum reg_request_treatment
@@ -1858,9 +1832,6 @@ __reg_process_hint_user(struct regulatory_request *user_request)
 	if (reg_request_indoor(user_request)) {
 		reg_is_indoor = user_request->is_indoor;
 
-		if (!reg_is_indoor)
-			reg_check_channels();
-
 		return REG_REQ_USER_HINT_HANDLED;
 	}
 
@@ -1925,7 +1896,7 @@ reg_process_hint_user(struct regulatory_request *user_request)
 	user_alpha2[0] = user_request->alpha2[0];
 	user_alpha2[1] = user_request->alpha2[1];
 
-	return reg_get_regdom_data(user_request);
+	return reg_call_crda(user_request);
 }
 
 static enum reg_request_treatment
@@ -1948,9 +1919,6 @@ __reg_process_hint_driver(struct regulatory_request *driver_request)
 	    !regdom_changes(driver_request->alpha2))
 		return REG_REQ_ALREADY_SET;
 
-	if (driver_request->driver_reg_hint_type == DRIVER_REG_HINT_OVERRIDE)
-		return REG_REQ_OK;
-
 	return REG_REQ_INTERSECT;
 }
 
@@ -1967,7 +1935,7 @@ static enum reg_request_treatment
 reg_process_hint_driver(struct wiphy *wiphy,
 			struct regulatory_request *driver_request)
 {
-	const struct ieee80211_regdomain *regd;
+	const struct ieee80211_regdomain *regd, *tmp;
 	enum reg_request_treatment treatment;
 
 	treatment = __reg_process_hint_driver(driver_request);
@@ -1977,7 +1945,6 @@ reg_process_hint_driver(struct wiphy *wiphy,
 		break;
 	case REG_REQ_IGNORE:
 	case REG_REQ_USER_HINT_HANDLED:
-	case REG_REQ_HANDLED:
 		reg_free_request(driver_request);
 		return treatment;
 	case REG_REQ_INTERSECT:
@@ -1988,7 +1955,10 @@ reg_process_hint_driver(struct wiphy *wiphy,
 			reg_free_request(driver_request);
 			return REG_REQ_IGNORE;
 		}
+
+		tmp = get_wiphy_regdom(wiphy);
 		rcu_assign_pointer(wiphy->regd, regd);
+		rcu_free_regdom(tmp);
 	}
 
 
@@ -2008,7 +1978,7 @@ reg_process_hint_driver(struct wiphy *wiphy,
 		return treatment;
 	}
 
-	return reg_get_regdom_data(driver_request);
+	return reg_call_crda(driver_request);
 }
 
 static enum reg_request_treatment
@@ -2075,7 +2045,6 @@ reg_process_hint_country_ie(struct wiphy *wiphy,
 		break;
 	case REG_REQ_IGNORE:
 	case REG_REQ_USER_HINT_HANDLED:
-	case REG_REQ_HANDLED:
 		/* fall through */
 	case REG_REQ_ALREADY_SET:
 		reg_free_request(country_ie_request);
@@ -2095,7 +2064,7 @@ reg_process_hint_country_ie(struct wiphy *wiphy,
 
 	reg_update_last_request(country_ie_request);
 
-	return reg_get_regdom_data(country_ie_request);
+	return reg_call_crda(country_ie_request);
 }
 
 /* This processes *all* regulatory hints */
@@ -2115,8 +2084,7 @@ static void reg_process_hint(struct regulatory_request *reg_request)
 		treatment = reg_process_hint_user(reg_request);
 		if (treatment == REG_REQ_IGNORE ||
 		    treatment == REG_REQ_ALREADY_SET ||
-		    treatment == REG_REQ_USER_HINT_HANDLED ||
-		    treatment == REG_REQ_HANDLED)
+		    treatment == REG_REQ_USER_HINT_HANDLED)
 			return;
 		queue_delayed_work(system_power_efficient_wq,
 				   &reg_timeout, msecs_to_jiffies(3142));
@@ -2207,11 +2175,52 @@ static void reg_process_pending_beacon_hints(void)
 	spin_unlock_bh(&reg_pending_beacons_lock);
 }
 
+static void reg_process_self_managed_hints(void)
+{
+	struct cfg80211_registered_device *rdev;
+	struct wiphy *wiphy;
+	const struct ieee80211_regdomain *tmp;
+	const struct ieee80211_regdomain *regd;
+	enum ieee80211_band band;
+	struct regulatory_request request = {};
+
+	list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
+		wiphy = &rdev->wiphy;
+
+		spin_lock(&reg_requests_lock);
+		regd = rdev->requested_regd;
+		rdev->requested_regd = NULL;
+		spin_unlock(&reg_requests_lock);
+
+		if (regd == NULL)
+			continue;
+
+		tmp = get_wiphy_regdom(wiphy);
+		rcu_assign_pointer(wiphy->regd, regd);
+		rcu_free_regdom(tmp);
+
+		for (band = 0; band < IEEE80211_NUM_BANDS; band++)
+			handle_band_custom(wiphy, wiphy->bands[band], regd);
+
+		reg_process_ht_flags(wiphy);
+
+		request.wiphy_idx = get_wiphy_idx(wiphy);
+		request.alpha2[0] = regd->alpha2[0];
+		request.alpha2[1] = regd->alpha2[1];
+		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
+
+		nl80211_send_wiphy_reg_change_event(&request);
+	}
+
+	reg_check_channels();
+}
+
 static void reg_todo(struct work_struct *work)
 {
 	rtnl_lock();
 	reg_process_pending_hints();
 	reg_process_pending_beacon_hints();
+	reg_process_self_managed_hints();
 	rtnl_unlock();
 }
 
@@ -2289,8 +2298,8 @@ int regulatory_hint_indoor_user(bool is_indoor)
 	return 0;
 }
 
-int regulatory_hint_force_policy(struct wiphy *wiphy, const char *alpha2,
-				 enum driver_reg_hint_type intersect_type)
+/* Driver hints */
+int regulatory_hint(struct wiphy *wiphy, const char *alpha2)
 {
 	struct regulatory_request *request;
 
@@ -2299,7 +2308,7 @@ int regulatory_hint_force_policy(struct wiphy *wiphy, const char *alpha2,
 
 	wiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG;
 
-	request = kzalloc(sizeof(struct regulatory_request), GFP_ATOMIC);
+	request = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);
 	if (!request)
 		return -ENOMEM;
 
@@ -2308,13 +2317,12 @@ int regulatory_hint_force_policy(struct wiphy *wiphy, const char *alpha2,
 	request->alpha2[0] = alpha2[0];
 	request->alpha2[1] = alpha2[1];
 	request->initiator = NL80211_REGDOM_SET_BY_DRIVER;
-	request->driver_reg_hint_type = intersect_type;
 
 	queue_regulatory_request(request);
 
 	return 0;
 }
-EXPORT_SYMBOL(regulatory_hint_force_policy);
+EXPORT_SYMBOL(regulatory_hint);
 
 void regulatory_hint_country_ie(struct wiphy *wiphy, enum ieee80211_band band,
 				const u8 *country_ie, u8 country_ie_len)
@@ -2495,6 +2503,8 @@ static void restore_regulatory_settings(bool reset_user)
 	world_alpha2[1] = cfg80211_world_regdom->alpha2[1];
 
 	list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
+		if (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED)
+			continue;
 		if (rdev->wiphy.regulatory_flags & REGULATORY_CUSTOM_REG)
 			restore_custom_reg_settings(&rdev->wiphy);
 	}
@@ -2710,6 +2720,9 @@ static int reg_set_rd_user(const struct ieee80211_regdomain *rd,
 {
 	const struct ieee80211_regdomain *intersected_rd = NULL;
 
+	if (!regdom_changes(rd->alpha2))
+		return -EALREADY;
+
 	if (!is_valid_rd(rd)) {
 		pr_err("Invalid regulatory domain detected:\n");
 		print_regdomain_info(rd);
@@ -2740,6 +2753,12 @@ static int reg_set_rd_driver(const struct ieee80211_regdomain *rd,
 	const struct ieee80211_regdomain *tmp;
 	struct wiphy *request_wiphy;
 
+	if (is_world_regdom(rd->alpha2))
+		return -EINVAL;
+
+	if (!regdom_changes(rd->alpha2))
+		return -EALREADY;
+
 	if (!is_valid_rd(rd)) {
 		pr_err("Invalid regulatory domain detected:\n");
 		print_regdomain_info(rd);
@@ -2754,9 +2773,7 @@ static int reg_set_rd_driver(const struct ieee80211_regdomain *rd,
 	}
 
 	if (!driver_request->intersect) {
-		if (request_wiphy->regd &&
-		    driver_request->driver_reg_hint_type !=
-		    DRIVER_REG_HINT_OVERRIDE)
+		if (request_wiphy->regd)
 			return -EALREADY;
 
 		regd = reg_copy_regd(rd);
@@ -2891,12 +2908,51 @@ int set_regdom(const struct ieee80211_regdomain *rd)
 	return 0;
 }
 
+int regulatory_set_wiphy_regd(struct wiphy *wiphy,
+			      struct ieee80211_regdomain *rd)
+{
+	const struct ieee80211_regdomain *regd;
+	const struct ieee80211_regdomain *prev_regd;
+	struct cfg80211_registered_device *rdev;
+
+	if (WARN_ON(!wiphy || !rd))
+		return -EINVAL;
+
+	if (WARN(!(wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED),
+		 "wiphy should have REGULATORY_WIPHY_SELF_MANAGED\n"))
+		return -EPERM;
+
+	if (WARN(!is_valid_rd(rd), "Invalid regulatory domain detected\n")) {
+		print_regdomain_info(rd);
+		return -EINVAL;
+	}
+
+	regd = reg_copy_regd(rd);
+	if (IS_ERR(regd))
+		return PTR_ERR(regd);
+
+	rdev = wiphy_to_rdev(wiphy);
+
+	spin_lock(&reg_requests_lock);
+	prev_regd = rdev->requested_regd;
+	rdev->requested_regd = regd;
+	spin_unlock(&reg_requests_lock);
+
+	kfree(prev_regd);
+
+	schedule_work(&reg_work);
+	return 0;
+}
+EXPORT_SYMBOL(regulatory_set_wiphy_regd);
+
 void wiphy_regulatory_register(struct wiphy *wiphy)
 {
 	struct regulatory_request *lr;
 
-	if (wiphy->get_regd && !regd_info_wiphy)
-		regd_info_wiphy = wiphy;
+	/* self-managed devices ignore external hints */
+	if (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED)
+		wiphy->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS |
+					   REGULATORY_COUNTRY_IE_IGNORE;
 
 	if (!reg_dev_ignore_cell_hint(wiphy))
 		reg_num_devs_support_basehint++;
@@ -2910,8 +2966,6 @@ void wiphy_regulatory_deregister(struct wiphy *wiphy)
 	struct wiphy *request_wiphy = NULL;
 	struct regulatory_request *lr;
 
-	ASSERT_RTNL();
-
 	lr = get_last_request();
 
 	if (!reg_dev_ignore_cell_hint(wiphy))
@@ -2920,9 +2974,6 @@ void wiphy_regulatory_deregister(struct wiphy *wiphy)
 	rcu_free_regdom(get_wiphy_regdom(wiphy));
 	RCU_INIT_POINTER(wiphy->regd, NULL);
 
-	if (wiphy == regd_info_wiphy)
-		regd_info_wiphy = NULL;
-
 	if (lr)
 		request_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);
 
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.h kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.h
index 96b413a..2fb4336 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.h
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/net/wireless/reg.h
@@ -44,6 +44,7 @@ unsigned int reg_get_max_bandwidth(const struct ieee80211_regdomain *rd,
 				   const struct ieee80211_reg_rule *rule);
 
 bool reg_last_request_cell_base(void);
+const struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy);
 
 /**
  * regulatory_hint_found_beacon - hints a beacon was found on a channel
diff --git kernel/gmin/uefi/modules/wlan/iwlwifi/versions kernel/gmin/uefi/modules/wlan/iwlwifi/versions
index a7a7811..d812c28 100644
--- kernel/gmin/uefi/modules/wlan/iwlwifi/versions
+++ kernel/gmin/uefi/modules/wlan/iwlwifi/versions
@@ -2,4 +2,4 @@ BACKPORTS_VERSION="(see git)"
 BACKPORTED_KERNEL_VERSION="(see git)"
 BACKPORTED_KERNEL_NAME="iwlwifi"
 BACKPORTS_BUILD_TSTAMP=__DATE__ \" \" __TIME__
-BACKPORTS_GIT_TRACKED="iwlwifi-stack-public-modrename:master:1236:c700e589"
+BACKPORTS_GIT_TRACKED="iwlwifi-stack-public-modrename:master:1328:bcc21b7b"
-- 
1.7.9.5

